*** EVALUATION ***
ANSI-C/cC++ Compiler for HC12 V-5.0.38 Build 9056, Feb 26 2009

    1:  /*----------------------------------------------------------------------------/
    2:  /  FatFs - FAT file system module  R0.08b                 (C)ChaN, 2011
    3:  /-----------------------------------------------------------------------------/
    4:  / FatFs module is a generic FAT file system module for small embedded systems.
    5:  / This is a free software that opened for education, research and commercial
    6:  / developments under license policy of following terms.
    7:  /
    8:  /  Copyright (C) 2011, ChaN, all right reserved.
    9:  /
   10:  / * The FatFs module is a free software and there is NO WARRANTY.
   11:  / * No restriction on use. You can use, modify and redistribute it for
   12:  /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
   13:  / * Redistributions of source code must retain the above copyright notice.
   14:  /
   15:  /-----------------------------------------------------------------------------/
   16:  / Feb 26,'06 R0.00  Prototype.
   17:  /
   18:  / Apr 29,'06 R0.01  First stable version.
   19:  /
   20:  / Jun 01,'06 R0.02  Added FAT12 support.
   21:  /                   Removed unbuffered mode.
   22:  /                   Fixed a problem on small (<32M) partition.
   23:  / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
   24:  /
   25:  / Sep 22,'06 R0.03  Added f_rename().
   26:  /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
   27:  / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
   28:  /                   Fixed f_mkdir() creates incorrect directory on FAT32.
   29:  /
   30:  / Feb 04,'07 R0.04  Supported multiple drive system.
   31:  /                   Changed some interfaces for multiple drive system.
   32:  /                   Changed f_mountdrv() to f_mount().
   33:  /                   Added f_mkfs().
   34:  / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
   35:  /                   Added a capability of extending file size to f_lseek().
   36:  /                   Added minimization level 3.
   37:  /                   Fixed an endian sensitive code in f_mkfs().
   38:  / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
   39:  /                   Added FSInfo support.
   40:  /                   Fixed DBCS name can result FR_INVALID_NAME.
   41:  /                   Fixed short seek (<= csize) collapses the file object.
   42:  /
   43:  / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
   44:  /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
   45:  /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
   46:  / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
   47:  /                   Fixed off by one error at FAT sub-type determination.
   48:  /                   Fixed btr in f_read() can be mistruncated.
   49:  /                   Fixed cached sector is not flushed when create and close without write.
   50:  /
   51:  / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
   52:  /                   Improved performance of f_lseek() on moving to the same or following cluster.
   53:  /
   54:  / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
   55:  /                   Added long file name feature.
   56:  /                   Added multiple code page feature.
   57:  /                   Added re-entrancy for multitask operation.
   58:  /                   Added auto cluster size selection to f_mkfs().
   59:  /                   Added rewind option to f_readdir().
   60:  /                   Changed result code of critical errors.
   61:  /                   Renamed string functions to avoid name collision.
   62:  / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
   63:  /                   Added multiple sector size feature.
   64:  / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
   65:  /                   Fixed wrong cache control in f_lseek().
   66:  /                   Added relative path feature.
   67:  /                   Added f_chdir() and f_chdrive().
   68:  /                   Added proper case conversion to extended char.
   69:  / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
   70:  /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
   71:  /                   Fixed name matching error on the 13 char boundary.
   72:  /                   Added a configuration option, _LFN_UNICODE.
   73:  /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
   74:  /
   75:  / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
   76:  /                   Added file lock feature. (_FS_SHARE)
   77:  /                   Added fast seek feature. (_USE_FASTSEEK)
   78:  /                   Changed some types on the API, XCHAR->TCHAR.
   79:  /                   Changed fname member in the FILINFO structure on Unicode cfg.
   80:  /                   String functions support UTF-8 encoding files on Unicode cfg.
   81:  / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
   82:  /                   Added sector erase feature. (_USE_ERASE)
   83:  /                   Moved file lock semaphore table from fs object to the bss.
   84:  /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
   85:  /                   Fixed f_mkfs() creates wrong FAT32 volume.
   86:  / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
   87:  /                   f_lseek() reports required table size on creating CLMP.
   88:  /                   Extended format syntax of f_printf function.
   89:  /                   Ignores duplicated directory separators in given path names.
   90:  /---------------------------------------------------------------------------*/
   91:  
   92:  #include "ff.h"			/* FatFs configurations and declarations */
   93:  #include "edisk.h"		/* Declarations of low level disk I/O functions */
   94:  
   95:  
   96:  /*--------------------------------------------------------------------------
   97:  
   98:     Module Private Definitions
   99:  
  100:  ---------------------------------------------------------------------------*/
  101:  
  102:  #if _FATFS != 8237
  103:  #error Wrong include file (ff.h).
  104:  #endif
  105:  
  106:  
  107:  /* Definitions on sector size */
  108:  #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
  109:  #error Wrong sector size.
  110:  #endif
  111:  #if _MAX_SS != 512
  112:  #define	SS(fs)	((fs)->ssize)	/* Multiple sector size */
  113:  #else
  114:  #define	SS(fs)	512U			/* Fixed sector size */
  115:  #endif
  116:  
  117:  
  118:  /* Reentrancy related */
  119:  #if _FS_REENTRANT
  120:  #if _USE_LFN == 1
  121:  #error Static LFN work area must not be used in re-entrant configuration.
  122:  #endif
  123:  #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
  124:  #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
  125:  #else
  126:  #define	ENTER_FF(fs)
  127:  #define LEAVE_FF(fs, res)	return res
  128:  #endif
  129:  
  130:  #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
  131:  
  132:  
  133:  /* File shareing feature */
  134:  #if _FS_SHARE
  135:  #if _FS_READONLY
  136:  #error _FS_SHARE must be 0 on read-only cfg.
  137:  #endif
  138:  typedef struct {
  139:  	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
  140:  	DWORD clu;				/* File ID 2, directory */
  141:  	WORD idx;				/* File ID 3, directory index */
  142:  	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
  143:  } FILESEM;
  144:  #endif
  145:  
  146:  
  147:  /* Misc definitions */
  148:  #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
  149:  #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
  150:  
  151:  
  152:  /* DBCS code ranges and SBCS extend char conversion table */
  153:  
  154:  #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
  155:  #define _DF1S	0x81	/* DBC 1st byte range 1 start */
  156:  #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
  157:  #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
  158:  #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
  159:  #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
  160:  #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
  161:  #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
  162:  #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
  163:  
  164:  #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
  165:  #define _DF1S	0x81
  166:  #define _DF1E	0xFE
  167:  #define _DS1S	0x40
  168:  #define _DS1E	0x7E
  169:  #define _DS2S	0x80
  170:  #define _DS2E	0xFE
  171:  
  172:  #elif _CODE_PAGE == 949	/* Korean */
  173:  #define _DF1S	0x81
  174:  #define _DF1E	0xFE
  175:  #define _DS1S	0x41
  176:  #define _DS1E	0x5A
  177:  #define _DS2S	0x61
  178:  #define _DS2E	0x7A
  179:  #define _DS3S	0x81
  180:  #define _DS3E	0xFE
  181:  
  182:  #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
  183:  #define _DF1S	0x81
  184:  #define _DF1E	0xFE
  185:  #define _DS1S	0x40
  186:  #define _DS1E	0x7E
  187:  #define _DS2S	0xA1
  188:  #define _DS2E	0xFE
  189:  
  190:  #elif _CODE_PAGE == 437	/* U.S. (OEM) */
  191:  #define _DF1S	0
  192:  #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  193:  				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  194:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  195:  				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  196:  
  197:  #elif _CODE_PAGE == 720	/* Arabic (OEM) */
  198:  #define _DF1S	0
  199:  #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  200:  				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  201:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  202:  				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  203:  
  204:  #elif _CODE_PAGE == 737	/* Greek (OEM) */
  205:  #define _DF1S	0
  206:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
  207:  				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  208:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  209:  				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  210:  
  211:  #elif _CODE_PAGE == 775	/* Baltic (OEM) */
  212:  #define _DF1S	0
  213:  #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
  214:  				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  215:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  216:  				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  217:  
  218:  #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
  219:  #define _DF1S	0
  220:  #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
  221:  				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  222:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  223:  				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  224:  
  225:  #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
  226:  #define _DF1S	0
  227:  #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
  228:  				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
  229:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  230:  				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
  231:  
  232:  #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
  233:  #define _DF1S	0
  234:  #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
  235:  				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
  236:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
  237:  				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
  238:  
  239:  #elif _CODE_PAGE == 857	/* Turkish (OEM) */
  240:  #define _DF1S	0
  241:  #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
  242:  				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  243:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  244:  				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  245:  
  246:  #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
  247:  #define _DF1S	0
  248:  #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
  249:  				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  250:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  251:  				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  252:  
  253:  #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
  254:  #define _DF1S	0
  255:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  256:  				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  257:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  258:  				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  259:  
  260:  #elif _CODE_PAGE == 866	/* Russian (OEM) */
  261:  #define _DF1S	0
  262:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  263:  				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  264:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  265:  				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  266:  
  267:  #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
  268:  #define _DF1S	0
  269:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  270:  				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  271:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  272:  				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  273:  
  274:  #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
  275:  #define _DF1S	0
  276:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
  277:  				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
  278:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  279:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
  280:  
  281:  #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
  282:  #define _DF1S	0
  283:  #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
  284:  				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
  285:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  286:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
  287:  
  288:  #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
  289:  #define _DF1S	0
  290:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
  291:  				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  292:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  293:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
  294:  
  295:  #elif _CODE_PAGE == 1253 /* Greek (Windows) */
  296:  #define _DF1S	0
  297:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  298:  				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  299:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
  300:  				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
  301:  
  302:  #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
  303:  #define _DF1S	0
  304:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
  305:  				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  306:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  307:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
  308:  
  309:  #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
  310:  #define _DF1S	0
  311:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  312:  				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  313:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  314:  				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
  315:  
  316:  #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
  317:  #define _DF1S	0
  318:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
  319:  				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  320:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  321:  				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
  322:  
  323:  #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
  324:  #define _DF1S	0
  325:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
  326:  				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
  327:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  328:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
  329:  
  330:  #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
  331:  #define _DF1S	0
  332:  #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
  333:  				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
  334:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
  335:  				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
  336:  
  337:  #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
  338:  #if _USE_LFN
  339:  #error Cannot use LFN feature without valid code page.
  340:  #endif
  341:  #define _DF1S	0
  342:  
  343:  #else
  344:  #error Unknown code page
  345:  
  346:  #endif
  347:  
  348:  
  349:  /* Character code support macros */
  350:  #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
  351:  #define IsLower(c)	(((c)>='a')&&((c)<='z'))
  352:  #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
  353:  
  354:  #if _DF1S		/* Code page is DBCS */
  355:  
  356:  #ifdef _DF2S	/* Two 1st byte areas */
  357:  #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
  358:  #else			/* One 1st byte area */
  359:  #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
  360:  #endif
  361:  
  362:  #ifdef _DS3S	/* Three 2nd byte areas */
  363:  #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
  364:  #else			/* Two 2nd byte areas */
  365:  #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
  366:  #endif
  367:  
  368:  #else			/* Code page is SBCS */
  369:  
  370:  #define IsDBCS1(c)	0
  371:  #define IsDBCS2(c)	0
  372:  
  373:  #endif /* _DF1S */
  374:  
  375:  
  376:  /* Name status flags */
  377:  #define NS			11		/* Index of name status byte in fn[] */
  378:  #define NS_LOSS		0x01	/* Out of 8.3 format */
  379:  #define NS_LFN		0x02	/* Force to create LFN entry */
  380:  #define NS_LAST		0x04	/* Last segment */
  381:  #define NS_BODY		0x08	/* Lower case flag (body) */
  382:  #define NS_EXT		0x10	/* Lower case flag (ext) */
  383:  #define NS_DOT		0x20	/* Dot entry */
  384:  
  385:  
  386:  /* FAT sub-type boundaries */
  387:  /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
  388:  #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
  389:  #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
  390:  
  391:  
  392:  /* FatFs refers the members in the FAT structures as byte array instead of
  393:  / structure member because the structure is not binary compatible between
  394:  / different platforms */
  395:  
  396:  #define BS_jmpBoot			0	/* Jump instruction (3) */
  397:  #define BS_OEMName			3	/* OEM name (8) */
  398:  #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
  399:  #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
  400:  #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
  401:  #define BPB_NumFATs			16	/* Number of FAT copies (1) */
  402:  #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
  403:  #define BPB_TotSec16		19	/* Volume size [sector] (2) */
  404:  #define BPB_Media			21	/* Media descriptor (1) */
  405:  #define BPB_FATSz16			22	/* FAT size [sector] (2) */
  406:  #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
  407:  #define BPB_NumHeads		26	/* Number of heads (2) */
  408:  #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
  409:  #define BPB_TotSec32		32	/* Volume size [sector] (4) */
  410:  #define BS_DrvNum			36	/* Physical drive number (2) */
  411:  #define BS_BootSig			38	/* Extended boot signature (1) */
  412:  #define BS_VolID			39	/* Volume serial number (4) */
  413:  #define BS_VolLab			43	/* Volume label (8) */
  414:  #define BS_FilSysType		54	/* File system type (1) */
  415:  #define BPB_FATSz32			36	/* FAT size [sector] (4) */
  416:  #define BPB_ExtFlags		40	/* Extended flags (2) */
  417:  #define BPB_FSVer			42	/* File system version (2) */
  418:  #define BPB_RootClus		44	/* Root dir first cluster (4) */
  419:  #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
  420:  #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
  421:  #define BS_DrvNum32			64	/* Physical drive number (2) */
  422:  #define BS_BootSig32		66	/* Extended boot signature (1) */
  423:  #define BS_VolID32			67	/* Volume serial number (4) */
  424:  #define BS_VolLab32			71	/* Volume label (8) */
  425:  #define BS_FilSysType32		82	/* File system type (1) */
  426:  #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
  427:  #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
  428:  #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
  429:  #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
  430:  #define MBR_Table			446	/* MBR: Partition table offset (2) */
  431:  #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
  432:  #define BS_55AA				510	/* Boot sector signature (2) */
  433:  
  434:  #define	DIR_Name			0	/* Short file name (11) */
  435:  #define	DIR_Attr			11	/* Attribute (1) */
  436:  #define	DIR_NTres			12	/* NT flag (1) */
  437:  #define	DIR_CrtTime			14	/* Created time (2) */
  438:  #define	DIR_CrtDate			16	/* Created date (2) */
  439:  #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
  440:  #define	DIR_WrtTime			22	/* Modified time (2) */
  441:  #define	DIR_WrtDate			24	/* Modified date (2) */
  442:  #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
  443:  #define	DIR_FileSize		28	/* File size (4) */
  444:  #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
  445:  #define	LDIR_Attr			11	/* LFN attribute (1) */
  446:  #define	LDIR_Type			12	/* LFN type (1) */
  447:  #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
  448:  #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
  449:  #define	SZ_DIR				32		/* Size of a directory entry */
  450:  #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
  451:  #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
  452:  #define	NDDE				0x05	/* Replacement of a character collides with DDE */
  453:  
  454:  
  455:  /*------------------------------------------------------------*/
  456:  /* Work area                                                  */
  457:  
  458:  #if _VOLUMES
  459:  static
  460:  FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
  461:  #else
  462:  #error Number of drives must not be 0.
  463:  #endif
  464:  
  465:  static
  466:  WORD Fsid;				/* File system mount ID */
  467:  
  468:  #if _FS_RPATH
  469:  static
  470:  BYTE CurrVol;			/* Current drive */
  471:  #endif
  472:  
  473:  #if _FS_SHARE
  474:  static
  475:  FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
  476:  #endif
  477:  
  478:  #if _USE_LFN == 0			/* No LFN */
  479:  #define	DEF_NAMEBUF			BYTE sfn[12]
  480:  #define INIT_BUF(dobj)		(dobj).fn = sfn
  481:  #define	FREE_BUF()
  482:  
  483:  #elif _USE_LFN == 1			/* LFN with static LFN working buffer */
  484:  static WCHAR LfnBuf[_MAX_LFN+1];
  485:  #define	DEF_NAMEBUF			BYTE sfn[12]
  486:  #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
  487:  #define	FREE_BUF()
  488:  
  489:  #elif _USE_LFN == 2 		/* LFN with dynamic LFN working buffer on the stack */
  490:  #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
  491:  #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
  492:  #define	FREE_BUF()
  493:  
  494:  #elif _USE_LFN == 3 		/* LFN with dynamic LFN working buffer on the heap */
  495:  #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
  496:  #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
  497:  							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
  498:  							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
  499:  #define	FREE_BUF()			ff_memfree(lfn)
  500:  
  501:  #else
  502:  #error Wrong LFN configuration.
  503:  #endif
  504:  
  505:  
  506:  
  507:  
  508:  /*--------------------------------------------------------------------------
  509:  
  510:     Module Private Functions
  511:  
  512:  ---------------------------------------------------------------------------*/
  513:  
  514:  
  515:  /*-----------------------------------------------------------------------*/
  516:  /* String functions                                                      */
  517:  /*-----------------------------------------------------------------------*/
  518:  
  519:  /* Copy memory to memory */
  520:  static
  521:  void mem_cpy (void* dst, const void* src, UINT cnt) {
*** EVALUATION ***

Function: mem_cpy
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
  522:  	BYTE *d = (BYTE*)dst;
  523:  	const BYTE *s = (const BYTE*)src;
  0002 ec86         [3]     LDD   6,SP
  0004 6c82         [2]     STD   2,SP
  524:  
  525:  #if _WORD_ACCESS == 1
  526:  	while (cnt >= sizeof(int)) {
  527:  		*(int*)d = *(int*)s;
  528:  		d += sizeof(int); s += sizeof(int);
  529:  		cnt -= sizeof(int);
  530:  	}
  531:  #endif
  532:  	while (cnt--)
  0006 ee88         [3]     LDX   8,SP
  0008 2008         [3]     BRA   *+10 ;abs = 0012
  533:  		*d++ = *s++;
  000a ed82         [3]     LDY   2,SP
  000c e670         [3]     LDAB  1,Y+
  000e 6b30         [2]     STAB  1,X+
  0010 6d82         [2]     STY   2,SP
  0012 ed80         [3]     LDY   0,SP
  0014 34           [2]     PSHX  
  0015 1a5f         [2]     LEAX  -1,Y
  0017 6e82         [2]     STX   2,SP
  0019 8d0000       [2]     CPY   #0
  001c 30           [3]     PULX  
  001d 26eb         [3/1]   BNE   *-19 ;abs = 000a
  534:  }
  001f 1b84         [2]     LEAS  4,SP
  0021 3d           [5]     RTS   
  535:  
  536:  /* Fill memory */
  537:  static
  538:  void mem_set (void* dst, int val, UINT cnt) {
*** EVALUATION ***

Function: mem_set
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  539:  	BYTE *d = (BYTE*)dst;
  540:  
  541:  	while (cnt--)
  0000 ee84         [3]     LDX   4,SP
  0002 b746         [1]     TFR   D,Y
  0004 2004         [3]     BRA   *+6 ;abs = 000a
  542:  		*d++ = (BYTE)val;
  0006 e683         [3]     LDAB  3,SP
  0008 6b30         [2]     STAB  1,X+
  000a 34           [2]     PSHX  
  000b 1a5f         [2]     LEAX  -1,Y
  000d 8d0000       [2]     CPY   #0
  0010 b756         [1]     TFR   X,Y
  0012 30           [3]     PULX  
  0013 26f1         [3/1]   BNE   *-13 ;abs = 0006
  543:  }
  0015 3d           [5]     RTS   
  544:  
  545:  /* Compare memory to memory */
  546:  static
  547:  int mem_cmp (const void* dst, const void* src, UINT cnt) {
*** EVALUATION ***

Function: mem_cmp
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca8         [2]     STD   8,-SP
  548:  	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
  0002 ec8c         [3]     LDD   12,SP
  0004 6c86         [2]     STD   6,SP
  0006 ec8a         [3]     LDD   10,SP
  0008 6c84         [2]     STD   4,SP
  549:  	int r = 0;
  000a c7           [1]     CLRB  
  000b 87           [1]     CLRA  
  000c 6c82         [2]     STD   2,SP
  550:  
  551:  	while (cnt-- && (r = *d++ - *s++) == 0) ;
  000e ee80         [3]     LDX   0,SP
  0010 191f         [2]     LEAY  -1,X
  0012 6d80         [2]     STY   0,SP
  0014 044519       [3]     TBEQ  X,*+28 ;abs = 0030
  0017 ee86         [3]     LDX   6,SP
  0019 e630         [3]     LDAB  1,X+
  001b 6e86         [2]     STX   6,SP
  001d 87           [1]     CLRA  
  001e ee84         [3]     LDX   4,SP
  0020 3b           [2]     PSHD  
  0021 e630         [3]     LDAB  1,X+
  0023 6e86         [2]     STX   6,SP
  0025 3b           [2]     PSHD  
  0026 ec82         [3]     LDD   2,SP
  0028 a3b1         [3]     SUBD  2,SP+
  002a 6c84         [2]     STD   4,SP
  002c 1b82         [2]     LEAS  2,SP
  002e 27de         [3/1]   BEQ   *-32 ;abs = 000e
  552:  	return r;
  0030 ec82         [3]     LDD   2,SP
  553:  }
  0032 1b88         [2]     LEAS  8,SP
  0034 3d           [5]     RTS   
  554:  
  555:  /* Check if chr is contained in the string */
  556:  static
  557:  int chk_chr (const char* str, int chr) {
*** EVALUATION ***

Function: chk_chr
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 3b           [2]     PSHD  
  558:  	while (*str && *str != chr) str++;
  0001 2005         [3]     BRA   *+7 ;abs = 0008
  0003 ee84         [3]     LDX   4,SP
  0005 08           [1]     INX   
  0006 6e84         [2]     STX   4,SP
  0008 ee84         [3]     LDX   4,SP
  000a e600         [3]     LDAB  0,X
  000c 2706         [3/1]   BEQ   *+8 ;abs = 0014
  000e b715         [1]     SEX   B,X
  0010 ae80         [3]     CPX   0,SP
  0012 26ef         [3/1]   BNE   *-15 ;abs = 0003
  559:  	return *str;
  0014 ee84         [3]     LDX   4,SP
  0016 e600         [3]     LDAB  0,X
  0018 b714         [1]     SEX   B,D
  560:  }
  001a 30           [3]     PULX  
  001b 3d           [5]     RTS   
  561:  
  562:  
  563:  
  564:  /*-----------------------------------------------------------------------*/
  565:  /* Request/Release grant to access the volume                            */
  566:  /*-----------------------------------------------------------------------*/
  567:  #if _FS_REENTRANT
  568:  
  569:  static
  570:  int lock_fs (
  571:  	FATFS *fs		/* File system object */
  572:  )
  573:  {
  574:  	return ff_req_grant(fs->sobj);
  575:  }
  576:  
  577:  
  578:  static
  579:  void unlock_fs (
  580:  	FATFS *fs,		/* File system object */
  581:  	FRESULT res		/* Result code to be returned */
  582:  )
  583:  {
  584:  	if (res != FR_NOT_ENABLED &&
  585:  		res != FR_INVALID_DRIVE &&
  586:  		res != FR_INVALID_OBJECT &&
  587:  		res != FR_TIMEOUT) {
  588:  		ff_rel_grant(fs->sobj);
  589:  	}
  590:  }
  591:  #endif
  592:  
  593:  
  594:  
  595:  /*-----------------------------------------------------------------------*/
  596:  /* File shareing control functions                                       */
  597:  /*-----------------------------------------------------------------------*/
  598:  #if _FS_SHARE
  599:  
  600:  static
  601:  FRESULT chk_lock (	/* Check if the file can be accessed */
  602:  	DIR* dj,		/* Directory object pointing the file to be checked */
  603:  	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
  604:  )
  605:  {
  606:  	UINT i, be;
  607:  
  608:  	/* Search file semaphore table */
  609:  	for (i = be = 0; i < _FS_SHARE; i++) {
  610:  		if (Files[i].fs) {	/* Existing entry */
  611:  			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  612:  				Files[i].clu == dj->sclust &&
  613:  				Files[i].idx == dj->index) break;
  614:  		} else {			/* Blank entry */
  615:  			be++;
  616:  		}
  617:  	}
  618:  	if (i == _FS_SHARE)	/* The file is not opened */
  619:  		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  620:  
  621:  	/* The file has been opened. Reject any open against writing file and all write mode open */
  622:  	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  623:  }
  624:  
  625:  
  626:  static
  627:  int enq_lock (	/* Check if an entry is available for a new file */
  628:  	FATFS* fs	/* File system object */
  629:  )
  630:  {
  631:  	UINT i;
  632:  
  633:  	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  634:  	return (i == _FS_SHARE) ? 0 : 1;
  635:  }
  636:  
  637:  
  638:  static
  639:  UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
  640:  	DIR* dj,	/* Directory object pointing the file to register or increment */
  641:  	int acc		/* Desired access mode (0:Read, !0:Write) */
  642:  )
  643:  {
  644:  	UINT i;
  645:  
  646:  
  647:  	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  648:  		if (Files[i].fs == dj->fs &&
  649:  			Files[i].clu == dj->sclust &&
  650:  			Files[i].idx == dj->index) break;
  651:  	}
  652:  
  653:  	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
  654:  		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  655:  		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
  656:  		Files[i].fs = dj->fs;
  657:  		Files[i].clu = dj->sclust;
  658:  		Files[i].idx = dj->index;
  659:  		Files[i].ctr = 0;
  660:  	}
  661:  
  662:  	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  663:  
  664:  	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  665:  
  666:  	return i + 1;
  667:  }
  668:  
  669:  
  670:  static
  671:  FRESULT dec_lock (	/* Decrement file open counter */
  672:  	UINT i			/* Semaphore index */
  673:  )
  674:  {
  675:  	WORD n;
  676:  	FRESULT res;
  677:  
  678:  
  679:  	if (--i < _FS_SHARE) {
  680:  		n = Files[i].ctr;
  681:  		if (n == 0x100) n = 0;
  682:  		if (n) n--;
  683:  		Files[i].ctr = n;
  684:  		if (!n) Files[i].fs = 0;
  685:  		res = FR_OK;
  686:  	} else {
  687:  		res = FR_INT_ERR;
  688:  	}
  689:  	return res;
  690:  }
  691:  
  692:  
  693:  static
  694:  void clear_lock (	/* Clear lock entries of the volume */
  695:  	FATFS *fs
  696:  )
  697:  {
  698:  	UINT i;
  699:  
  700:  	for (i = 0; i < _FS_SHARE; i++) {
  701:  		if (Files[i].fs == fs) Files[i].fs = 0;
  702:  	}
  703:  }
  704:  #endif
  705:  
  706:  
  707:  
  708:  /*-----------------------------------------------------------------------*/
  709:  /* Change window offset                                                  */
  710:  /*-----------------------------------------------------------------------*/
  711:  
  712:  static
  713:  FRESULT move_window (
  714:  	FATFS *fs,		/* File system object */
  715:  	DWORD sector	/* Sector number to make appearance in the fs->win[] */
  716:  )					/* Move to zero only writes back dirty window */
  717:  {
*** EVALUATION ***

Function: move_window
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca9         [2]     STD   7,-SP
  0002 34           [2]     PSHX  
  718:  	DWORD wsect;
  719:  
  720:  
  721:  	wsect = fs->winsect;
  0003 ee8b         [3]     LDX   11,SP
  0005 ece02a       [3]     LDD   42,X
  0008 6c84         [2]     STD   4,SP
  000a ece02c       [3]     LDD   44,X
  000d 6c86         [2]     STD   6,SP
  722:  	if (wsect != sector) {	/* Changed current window */
  000f ac82         [3]     CPD   2,SP
  0011 2606         [3/1]   BNE   *+8 ;abs = 0019
  0013 ec84         [3]     LDD   4,SP
  0015 ac80         [3]     CPD   0,SP
  0017 2776         [3/1]   BEQ   *+120 ;abs = 008f
  723:  #if !_FS_READONLY
  724:  		if (fs->wflag) {	/* Write back dirty window if needed */
  0019 e604         [3]     LDAB  4,X
  001b 276c         [3/1]   BEQ   *+110 ;abs = 0089
  725:  			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  001d e601         [3]     LDAB  1,X
  001f 37           [2]     PSHB  
  0020 1ae02e       [2]     LEAX  46,X
  0023 34           [2]     PSHX  
  0024 ec89         [3]     LDD   9,SP
  0026 3b           [2]     PSHD  
  0027 ec89         [3]     LDD   9,SP
  0029 3b           [2]     PSHD  
  002a c601         [1]     LDAB  #1
  002c 160000       [4]     JSR   eDisk_Write
  002f 1b87         [2]     LEAS  7,SP
  0031 046476       [3]     TBNE  D,*+121 ;abs = 00aa
  726:  				return FR_DISK_ERR;
  727:  			fs->wflag = 0;
  0034 ee8b         [3]     LDX   11,SP
  0036 6904         [2]     CLR   4,X
  728:  			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  0038 ece020       [3]     LDD   32,X
  003b e3e01c       [3]     ADDD  28,X
  003e 3b           [2]     PSHD  
  003f ece01a       [3]     LDD   26,X
  0042 e9e01f       [3]     ADCB  31,X
  0045 a9e01e       [3]     ADCA  30,X
  0048 1986         [2]     LEAY  6,SP
  004a b745         [1]     TFR   D,X
  004c 3a           [3]     PULD  
  004d 160000       [4]     JSR   _LCMP_P
  0050 2337         [3/1]   BLS   *+57 ;abs = 0089
  729:  				BYTE nf;
  730:  				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  0052 ee8b         [3]     LDX   11,SP
  0054 e603         [3]     LDAB  3,X
  0056 6b88         [2]     STAB  8,SP
  0058 2029         [3]     BRA   *+43 ;abs = 0083
  731:  					wsect += fs->fsize;
  005a ee8b         [3]     LDX   11,SP
  005c ece01c       [3]     LDD   28,X
  005f e386         [3]     ADDD  6,SP
  0061 6c86         [2]     STD   6,SP
  0063 ec84         [3]     LDD   4,SP
  0065 e9e01b       [3]     ADCB  27,X
  0068 a9e01a       [3]     ADCA  26,X
  006b 6c84         [2]     STD   4,SP
  732:  					disk_write(fs->drv, fs->win, wsect, 1);
  006d e601         [3]     LDAB  1,X
  006f 37           [2]     PSHB  
  0070 1ae02e       [2]     LEAX  46,X
  0073 34           [2]     PSHX  
  0074 ec89         [3]     LDD   9,SP
  0076 3b           [2]     PSHD  
  0077 ec89         [3]     LDD   9,SP
  0079 3b           [2]     PSHD  
  007a c601         [1]     LDAB  #1
  007c 160000       [4]     JSR   eDisk_Write
  007f 1b87         [2]     LEAS  7,SP
  0081 6388         [3]     DEC   8,SP
  0083 e688         [3]     LDAB  8,SP
  0085 c101         [1]     CMPB  #1
  0087 22d1         [3/1]   BHI   *-45 ;abs = 005a
  733:  				}
  734:  			}
  735:  		}
  736:  #endif
  737:  		if (sector) {
  0089 ec82         [3]     LDD   2,SP
  008b 2604         [3/1]   BNE   *+6 ;abs = 0091
  008d ec80         [3]     LDD   0,SP
  008f 2729         [3/1]   BEQ   *+43 ;abs = 00ba
  738:  			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  0091 ee8b         [3]     LDX   11,SP
  0093 e601         [3]     LDAB  1,X
  0095 37           [2]     PSHB  
  0096 1ae02e       [2]     LEAX  46,X
  0099 34           [2]     PSHX  
  009a ec85         [3]     LDD   5,SP
  009c 3b           [2]     PSHD  
  009d ec85         [3]     LDD   5,SP
  009f 3b           [2]     PSHD  
  00a0 c601         [1]     LDAB  #1
  00a2 160000       [4]     JSR   eDisk_Read
  00a5 1b87         [2]     LEAS  7,SP
  00a7 044404       [3]     TBEQ  D,*+7 ;abs = 00ae
  739:  				return FR_DISK_ERR;
  00aa c601         [1]     LDAB  #1
  00ac 200d         [3]     BRA   *+15 ;abs = 00bb
  740:  			fs->winsect = sector;
  00ae ee8b         [3]     LDX   11,SP
  00b0 ec80         [3]     LDD   0,SP
  00b2 6ce02a       [3]     STD   42,X
  00b5 ec82         [3]     LDD   2,SP
  00b7 6ce02c       [3]     STD   44,X
  741:  		}
  742:  	}
  743:  
  744:  	return FR_OK;
  00ba c7           [1]     CLRB  
  00bb 87           [1]     CLRA  
  745:  }
  00bc 1b89         [2]     LEAS  9,SP
  00be 3d           [5]     RTS   
  746:  
  747:  
  748:  
  749:  
  750:  /*-----------------------------------------------------------------------*/
  751:  /* Clean-up cached data                                                  */
  752:  /*-----------------------------------------------------------------------*/
  753:  #if !_FS_READONLY
  754:  static
  755:  FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
  756:  	FATFS *fs	/* File system object */
  757:  )
  758:  {
*** EVALUATION ***

Function: sync
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
  759:  	FRESULT res;
  760:  
  761:  
  762:  	res = move_window(fs, 0);
  0002 3b           [2]     PSHD  
  0003 c7           [1]     CLRB  
  0004 87           [1]     CLRA  
  0005 b745         [1]     TFR   D,X
  0007 160000       [4]     JSR   move_window
  000a 1b82         [2]     LEAS  2,SP
  000c 6c82         [2]     STD   2,SP
  763:  	if (res == FR_OK) {
  000e 182600c1     [4/3]   LBNE  *+197 ;abs = 00d3
  764:  		/* Update FSInfo sector if needed */
  765:  		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  0012 ee80         [3]     LDX   0,SP
  0014 e600         [3]     LDAB  0,X
  0016 c103         [1]     CMPB  #3
  0018 182600a2     [4/3]   LBNE  *+166 ;abs = 00be
  001c e605         [3]     LDAB  5,X
  001e 1827009c     [4/3]   LBEQ  *+160 ;abs = 00be
  766:  			fs->winsect = 0;
  0022 c7           [1]     CLRB  
  0023 87           [1]     CLRA  
  0024 6ce02a       [3]     STD   42,X
  0027 6ce02c       [3]     STD   44,X
  767:  			/* Create FSInfo structure */
  768:  			mem_set(fs->win, 0, 512);
  002a 1ae02e       [2]     LEAX  46,X
  002d 34           [2]     PSHX  
  002e 3b           [2]     PSHD  
  002f 8602         [1]     LDAA  #2
  0031 160000       [4]     JSR   mem_set
  769:  			ST_WORD(fs->win+BS_55AA, 0xAA55);
  0034 eea3         [3]     LDX   4,+SP
  0036 cc5255       [2]     LDD   #21077
  0039 6be2022c     [3]     STAB  556,X
  003d 19e2022c     [2]     LEAY  556,X
  0041 58           [1]     LSLB  
  0042 6b41         [2]     STAB  1,Y
  770:  			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  0044 c652         [1]     LDAB  #82
  0046 6ce02e       [3]     STD   46,X
  0049 cc6141       [2]     LDD   #24897
  004c 6ce030       [3]     STD   48,X
  771:  			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  004f cc7272       [2]     LDD   #29298
  0052 6be20212     [3]     STAB  530,X
  0056 1ae20212     [2]     LEAX  530,X
  005a c641         [1]     LDAB  #65
  005c 6c01         [2]     STD   1,X
  005e ee80         [3]     LDX   0,SP
  0060 19e20212     [2]     LEAY  530,X
  0064 c661         [1]     LDAB  #97
  0066 6b43         [2]     STAB  3,Y
  772:  			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  0068 e6e011       [3]     LDAB  17,X
  006b 6be20216     [3]     STAB  534,X
  006f 19e20216     [2]     LEAY  534,X
  0073 e6e010       [3]     LDAB  16,X
  0076 6b41         [2]     STAB  1,Y
  0078 1a0e         [2]     LEAX  14,X
  007a e601         [3]     LDAB  1,X
  007c 6b42         [2]     STAB  2,Y
  007e ee80         [3]     LDX   0,SP
  0080 19e20216     [2]     LEAY  534,X
  0084 e60e         [3]     LDAB  14,X
  0086 6b43         [2]     STAB  3,Y
  773:  			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  0088 e60d         [3]     LDAB  13,X
  008a 6be2021a     [3]     STAB  538,X
  008e 19e2021a     [2]     LEAY  538,X
  0092 e60c         [3]     LDAB  12,X
  0094 6b41         [2]     STAB  1,Y
  0096 1a0a         [2]     LEAX  10,X
  0098 e601         [3]     LDAB  1,X
  009a 6b42         [2]     STAB  2,Y
  009c ee80         [3]     LDX   0,SP
  009e 19e2021a     [2]     LEAY  538,X
  00a2 e60a         [3]     LDAB  10,X
  00a4 6b43         [2]     STAB  3,Y
  774:  			/* Write it into the FSInfo sector */
  775:  			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  00a6 e601         [3]     LDAB  1,X
  00a8 37           [2]     PSHB  
  00a9 19e02e       [2]     LEAY  46,X
  00ac 35           [2]     PSHY  
  00ad ece014       [3]     LDD   20,X
  00b0 3b           [2]     PSHD  
  00b1 ece012       [3]     LDD   18,X
  00b4 3b           [2]     PSHD  
  00b5 c601         [1]     LDAB  #1
  00b7 160000       [4]     JSR   eDisk_Write
  776:  			fs->fsi_flag = 0;
  00ba eea6         [3]     LDX   7,+SP
  00bc 6905         [2]     CLR   5,X
  777:  		}
  778:  		/* Make sure that no pending write process in the physical drive */
  779:  		if (disk_ioctl(fs->drv, CTRL_SYNC, (void*)0) != RES_OK)
  00be ee80         [3]     LDX   0,SP
  00c0 e601         [3]     LDAB  1,X
  00c2 37           [2]     PSHB  
  00c3 c7           [1]     CLRB  
  00c4 37           [2]     PSHB  
  00c5 87           [1]     CLRA  
  00c6 160000       [4]     JSR   disk_ioctl
  00c9 1b82         [2]     LEAS  2,SP
  00cb 044405       [3]     TBEQ  D,*+8 ;abs = 00d3
  780:  			res = FR_DISK_ERR;
  00ce c601         [1]     LDAB  #1
  00d0 87           [1]     CLRA  
  00d1 6c82         [2]     STD   2,SP
  781:  	}
  782:  
  783:  	return res;
  00d3 ec82         [3]     LDD   2,SP
  784:  }
  00d5 1b84         [2]     LEAS  4,SP
  00d7 3d           [5]     RTS   
  785:  #endif
  786:  
  787:  
  788:  
  789:  
  790:  /*-----------------------------------------------------------------------*/
  791:  /* Get sector# from cluster#                                             */
  792:  /*-----------------------------------------------------------------------*/
  793:  
  794:  
  795:  DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
  796:  	FATFS *fs,		/* File system object */
  797:  	DWORD clst		/* Cluster# to be converted */
  798:  )
  799:  {
*** EVALUATION ***

Function: clust2sect
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 3b           [2]     PSHD  
  0001 34           [2]     PSHX  
  800:  	clst -= 2;
  0002 830002       [2]     SUBD  #2
  0005 6c82         [2]     STD   2,SP
  0007 b754         [1]     TFR   X,D
  0009 c200         [1]     SBCB  #0
  000b 8200         [1]     SBCA  #0
  000d 6c80         [2]     STD   0,SP
  801:  	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  000f ee86         [3]     LDX   6,SP
  0011 ece018       [3]     LDD   24,X
  0014 830002       [2]     SUBD  #2
  0017 3b           [2]     PSHD  
  0018 ece016       [3]     LDD   22,X
  001b c200         [1]     SBCB  #0
  001d 8200         [1]     SBCA  #0
  001f 1982         [2]     LEAY  2,SP
  0021 3b           [2]     PSHD  
  0022 ec82         [3]     LDD   2,SP
  0024 30           [3]     PULX  
  0025 160000       [4]     JSR   _LCMP_P
  0028 1b82         [2]     LEAS  2,SP
  002a 2207         [3/1]   BHI   *+9 ;abs = 0033
  002c ce0000       [2]     LDX   #0
  002f b754         [1]     TFR   X,D
  0031 201d         [3]     BRA   *+31 ;abs = 0050
  802:  	return clst * fs->csize + fs->database;
  0033 ee86         [3]     LDX   6,SP
  0035 e602         [3]     LDAB  2,X
  0037 87           [1]     CLRA  
  0038 b746         [1]     TFR   D,Y
  003a ec82         [3]     LDD   2,SP
  003c ee80         [3]     LDX   0,SP
  003e 160000       [4]     JSR   _LMULU16x32
  0041 ed86         [3]     LDY   6,SP
  0043 e3e828       [3]     ADDD  40,Y
  0046 b7c5         [1]     EXG   D,X
  0048 e9e827       [3]     ADCB  39,Y
  004b a9e826       [3]     ADCA  38,Y
  004e b7c5         [1]     EXG   D,X
  803:  }
  0050 1b84         [2]     LEAS  4,SP
  0052 3d           [5]     RTS   
  804:  
  805:  
  806:  
  807:  
  808:  /*-----------------------------------------------------------------------*/
  809:  /* FAT access - Read value of a FAT entry                                */
  810:  /*-----------------------------------------------------------------------*/
  811:  
  812:  
  813:  DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  814:  	FATFS *fs,	/* File system object */
  815:  	DWORD clst	/* Cluster# to get the link information */
  816:  )
  817:  {
*** EVALUATION ***

Function: get_fat
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6caa         [2]     STD   6,-SP
  0002 6eae         [2]     STX   2,-SP
  818:  	UINT wc, bc;
  819:  	BYTE *p;
  820:  
  821:  
  822:  	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  0004 2605         [3/1]   BNE   *+7 ;abs = 000b
  0006 8c0002       [2]     CPD   #2
  0009 2510         [3/1]   BCS   *+18 ;abs = 001b
  000b ed8a         [3]     LDY   10,SP
  000d 1ae816       [2]     LEAX  22,Y
  0010 ec82         [3]     LDD   2,SP
  0012 34           [2]     PSHX  
  0013 ee82         [3]     LDX   2,SP
  0015 31           [3]     PULY  
  0016 160000       [4]     JSR   _LCMP_P
  0019 2508         [3/1]   BCS   *+10 ;abs = 0023
  823:  		return 1;
  001b c601         [1]     LDAB  #1
  001d 87           [1]     CLRA  
  001e b705         [1]     SEX   A,X
  0020 060000       [3]     JMP   get_fat:0x0159
  824:  
  825:  	switch (fs->fs_type) {
  0023 ee8a         [3]     LDX   10,SP
  0025 e600         [3]     LDAB  0,X
  0027 c103         [1]     CMPB  #3
  0029 18220127     [4/3]   LBHI  *+299 ;abs = 0154
  002d 53           [1]     DECB  
  002e 87           [1]     CLRA  
  002f 160000       [4]     JSR   _CASE_CHECKED
  0032 0003         DC.W  3
  0034 0000         DC.W  get_fat:0x0154
  0036 0000         DC.W  get_fat:0x003c
  0038 0000         DC.W  get_fat:0x00ae
  003a 0000         DC.W  get_fat:0x00ea
  826:  	case FS_FAT12 :
  827:  		bc = (UINT)clst; bc += bc / 2;
  003c ec82         [3]     LDD   2,SP
  003e 6c84         [2]     STD   4,SP
  0040 49           [1]     LSRD  
  0041 e384         [3]     ADDD  4,SP
  0043 6c84         [2]     STD   4,SP
  828:  		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  0045 ee8a         [3]     LDX   10,SP
  0047 34           [2]     PSHX  
  0048 160000       [4]     JSR   get_fat:0x0174
  004b cc0000       [2]     LDD   #0
  004e 160000       [4]     JSR   get_fat:0x0169
  0051 160000       [4]     JSR   move_window
  0054 1b82         [2]     LEAS  2,SP
  0056 0464fb       [3]     TBNE  D,*+254 ;abs = 0154
  829:  		wc = fs->win[bc % SS(fs)]; bc++;
  0059 ec84         [3]     LDD   4,SP
  005b 8401         [1]     ANDA  #1
  005d ee8a         [3]     LDX   10,SP
  005f e38a         [3]     ADDD  10,SP
  0061 b746         [1]     TFR   D,Y
  0063 e6e82e       [3]     LDAB  46,Y
  0066 87           [1]     CLRA  
  0067 6c86         [2]     STD   6,SP
  0069 ed84         [3]     LDY   4,SP
  006b 02           [1]     INY   
  006c 6d84         [2]     STY   4,SP
  830:  		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  006e 34           [2]     PSHX  
  006f b764         [1]     TFR   Y,D
  0071 160000       [4]     JSR   get_fat:0x0174
  0074 cc0000       [2]     LDD   #0
  0077 160000       [4]     JSR   get_fat:0x0169
  007a 160000       [4]     JSR   move_window
  007d 1b82         [2]     LEAS  2,SP
  007f 0464d2       [3]     TBNE  D,*+213 ;abs = 0154
  831:  		wc |= fs->win[bc % SS(fs)] << 8;
  0082 ec84         [3]     LDD   4,SP
  0084 8401         [1]     ANDA  #1
  0086 b745         [1]     TFR   D,X
  0088 ec8a         [3]     LDD   10,SP
  008a 1ae6         [2]     LEAX  D,X
  008c e6e02e       [3]     LDAB  46,X
  008f b710         [1]     TFR   B,A
  0091 c7           [1]     CLRB  
  0092 ea87         [3]     ORAB  7,SP
  0094 aa86         [3]     ORAA  6,SP
  0096 6c86         [2]     STD   6,SP
  832:  		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  0098 0e830104     [4]     BRSET 3,SP,#1,*+8 ;abs = 00a0
  009c 840f         [1]     ANDA  #15
  009e 2004         [3]     BRA   *+6 ;abs = 00a4
  00a0 49           [1]     LSRD  
  00a1 49           [1]     LSRD  
  00a2 49           [1]     LSRD  
  00a3 49           [1]     LSRD  
  00a4 b746         [1]     TFR   D,Y
  00a6 ce0000       [2]     LDX   #0
  00a9 b764         [1]     TFR   Y,D
  00ab 060000       [3]     JMP   get_fat:0x0159
  833:  
  834:  	case FS_FAT16 :
  835:  		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  00ae ee8a         [3]     LDX   10,SP
  00b0 34           [2]     PSHX  
  00b1 ec84         [3]     LDD   4,SP
  00b3 ed82         [3]     LDY   2,SP
  00b5 36           [2]     PSHA  
  00b6 35           [2]     PSHY  
  00b7 33           [3]     PULB  
  00b8 31           [3]     PULY  
  00b9 87           [1]     CLRA  
  00ba b7c6         [1]     EXG   D,Y
  00bc e3e020       [3]     ADDD  32,X
  00bf b7c6         [1]     EXG   D,Y
  00c1 e9e01f       [3]     ADCB  31,X
  00c4 a9e01e       [3]     ADCA  30,X
  00c7 b7c6         [1]     EXG   D,Y
  00c9 b765         [1]     TFR   Y,X
  00cb 160000       [4]     JSR   move_window
  00ce 1b82         [2]     LEAS  2,SP
  00d0 046481       [3]     TBNE  D,*+132 ;abs = 0154
  836:  		p = &fs->win[clst * 2 % SS(fs)];
  00d3 ec82         [3]     LDD   2,SP
  00d5 160000       [4]     JSR   get_fat:0x015c
  837:  		return LD_WORD(p);
  00d8 e601         [3]     LDAB  1,X
  00da b710         [1]     TFR   B,A
  00dc c7           [1]     CLRB  
  00dd 3b           [2]     PSHD  
  00de e600         [3]     LDAB  0,X
  00e0 87           [1]     CLRA  
  00e1 ea81         [3]     ORAB  1,SP
  00e3 aa80         [3]     ORAA  0,SP
  00e5 ce0000       [2]     LDX   #0
  00e8 2066         [3]     BRA   *+104 ;abs = 0150
  838:  
  839:  	case FS_FAT32 :
  840:  		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  00ea ee8a         [3]     LDX   10,SP
  00ec 34           [2]     PSHX  
  00ed ed84         [3]     LDY   4,SP
  00ef ee82         [3]     LDX   2,SP
  00f1 c607         [1]     LDAB  #7
  00f3 160000       [4]     JSR   _LSHRU
  00f6 ed8c         [3]     LDY   12,SP
  00f8 e3e820       [3]     ADDD  32,Y
  00fb b7c5         [1]     EXG   D,X
  00fd e9e81f       [3]     ADCB  31,Y
  0100 a9e81e       [3]     ADCA  30,Y
  0103 b7c5         [1]     EXG   D,X
  0105 160000       [4]     JSR   move_window
  0108 1b82         [2]     LEAS  2,SP
  010a 046447       [3]     TBNE  D,*+74 ;abs = 0154
  841:  		p = &fs->win[clst * 4 % SS(fs)];
  010d ec82         [3]     LDD   2,SP
  010f 59           [1]     LSLD  
  0110 074a         [4]     BSR   *+76 ;abs = 015c
  842:  		return LD_DWORD(p) & 0x0FFFFFFF;
  0112 e603         [3]     LDAB  3,X
  0114 87           [1]     CLRA  
  0115 34           [2]     PSHX  
  0116 b705         [1]     SEX   A,X
  0118 b781         [1]     EXG   A,B
  011a c7           [1]     CLRB  
  011b b756         [1]     TFR   X,Y
  011d ee80         [3]     LDX   0,SP
  011f 3b           [2]     PSHD  
  0120 e602         [3]     LDAB  2,X
  0122 87           [1]     CLRA  
  0123 b7c6         [1]     EXG   D,Y
  0125 ca00         [1]     ORAB  #0
  0127 8a00         [1]     ORAA  #0
  0129 b7c6         [1]     EXG   D,Y
  012b ea81         [3]     ORAB  1,SP
  012d aa80         [3]     ORAA  0,SP
  012f ee82         [3]     LDX   2,SP
  0131 6c80         [2]     STD   0,SP
  0133 e601         [3]     LDAB  1,X
  0135 b710         [1]     TFR   B,A
  0137 c7           [1]     CLRB  
  0138 35           [2]     PSHY  
  0139 ea81         [3]     ORAB  1,SP
  013b aab1         [3]     ORAA  2,SP+
  013d 3b           [2]     PSHD  
  013e e600         [3]     LDAB  0,X
  0140 87           [1]     CLRA  
  0141 ea81         [3]     ORAB  1,SP
  0143 aa80         [3]     ORAA  0,SP
  0145 6c80         [2]     STD   0,SP
  0147 ec82         [3]     LDD   2,SP
  0149 840f         [1]     ANDA  #15
  014b b745         [1]     TFR   D,X
  014d 3a           [3]     PULD  
  014e 1b82         [2]     LEAS  2,SP
  0150 1b82         [2]     LEAS  2,SP
  0152 2005         [3]     BRA   *+7 ;abs = 0159
  843:  	}
  844:  
  845:  	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  0154 ceffff       [2]     LDX   #65535
  0157 b754         [1]     TFR   X,D
  846:  }
  0159 1b88         [2]     LEAS  8,SP
  015b 3d           [5]     RTS   
  015c 59           [1]     LSLD  
  015d 8401         [1]     ANDA  #1
  015f b745         [1]     TFR   D,X
  0161 ec8c         [3]     LDD   12,SP
  0163 c3002e       [2]     ADDD  #46
  0166 1ae6         [2]     LEAX  D,X
  0168 3d           [5]     RTS   
  0169 e9e01f       [3]     ADCB  31,X
  016c a9e01e       [3]     ADCA  30,X
  016f b745         [1]     TFR   D,X
  0171 b764         [1]     TFR   Y,D
  0173 3d           [5]     RTS   
  0174 b701         [1]     TFR   A,B
  0176 87           [1]     CLRA  
  0177 49           [1]     LSRD  
  0178 e3e020       [3]     ADDD  32,X
  017b b746         [1]     TFR   D,Y
  017d 3d           [5]     RTS   
  847:  
  848:  
  849:  
  850:  
  851:  /*-----------------------------------------------------------------------*/
  852:  /* FAT access - Change value of a FAT entry                              */
  853:  /*-----------------------------------------------------------------------*/
  854:  #if !_FS_READONLY
  855:  
  856:  FRESULT put_fat (
  857:  	FATFS *fs,	/* File system object */
  858:  	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
  859:  	DWORD val	/* New value to mark the cluster */
  860:  )
  861:  {
*** EVALUATION ***

Function: put_fat
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca8         [2]     STD   8,-SP
  0002 34           [2]     PSHX  
  0003 36           [2]     PSHA  
  862:  	UINT bc;
  863:  	BYTE *p;
  864:  	FRESULT res;
  865:  
  866:  
  867:  	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  0004 ec8d         [3]     LDD   13,SP
  0006 2607         [3/1]   BNE   *+9 ;abs = 000f
  0008 ec8f         [3]     LDD   15,SP
  000a 8c0002       [2]     CPD   #2
  000d 2511         [3/1]   BCS   *+19 ;abs = 0020
  000f edf011       [3]     LDY   17,SP
  0012 1ae816       [2]     LEAX  22,Y
  0015 ec8f         [3]     LDD   15,SP
  0017 34           [2]     PSHX  
  0018 ee8f         [3]     LDX   15,SP
  001a 31           [3]     PULY  
  001b 160000       [4]     JSR   _LCMP_P
  001e 2508         [3/1]   BCS   *+10 ;abs = 0028
  868:  		res = FR_INT_ERR;
  0020 c602         [1]     LDAB  #2
  0022 87           [1]     CLRA  
  0023 6c87         [2]     STD   7,SP
  869:  
  870:  	} else {
  0025 060000       [3]     JMP   put_fat:0x0188
  871:  		switch (fs->fs_type) {
  0028 eef011       [3]     LDX   17,SP
  002b e600         [3]     LDAB  0,X
  002d c103         [1]     CMPB  #3
  002f 18220149     [4/3]   LBHI  *+333 ;abs = 017c
  0033 53           [1]     DECB  
  0034 87           [1]     CLRA  
  0035 160000       [4]     JSR   _CASE_CHECKED
  0038 0003         DC.W  3
  003a 0000         DC.W  put_fat:0x017c
  003c 0000         DC.W  put_fat:0x0042
  003e 0000         DC.W  put_fat:0x00ca
  0040 0000         DC.W  put_fat:0x0102
  872:  		case FS_FAT12 :
  873:  			bc = clst; bc += bc / 2;
  0042 ec8f         [3]     LDD   15,SP
  0044 6c85         [2]     STD   5,SP
  0046 49           [1]     LSRD  
  0047 e385         [3]     ADDD  5,SP
  0049 6c85         [2]     STD   5,SP
  874:  			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  004b eef011       [3]     LDX   17,SP
  004e 34           [2]     PSHX  
  004f 160000       [4]     JSR   put_fat:0x019a
  0052 160000       [4]     JSR   move_window
  0055 1b82         [2]     LEAS  2,SP
  0057 6c87         [2]     STD   7,SP
  875:  			if (res != FR_OK) break;
  0059 263f         [3/1]   BNE   *+65 ;abs = 009a
  876:  			p = &fs->win[bc % SS(fs)];
  005b ec85         [3]     LDD   5,SP
  005d 160000       [4]     JSR   put_fat:0x018d
  0060 6e89         [2]     STX   9,SP
  877:  			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  0062 0ef0100106   [5]     BRSET 16,SP,#1,*+11 ;abs = 006d
  0067 e684         [3]     LDAB  4,SP
  0069 6b80         [2]     STAB  0,SP
  006b 200e         [3]     BRA   *+16 ;abs = 007b
  006d e600         [3]     LDAB  0,X
  006f c40f         [1]     ANDB  #15
  0071 8610         [1]     LDAA  #16
  0073 37           [2]     PSHB  
  0074 e685         [3]     LDAB  5,SP
  0076 12           [1]     MUL   
  0077 ea80         [3]     ORAB  0,SP
  0079 6ba0         [2]     STAB  1,+SP
  007b a680         [3]     LDAA  0,SP
  007d 6a00         [2]     STAA  0,X
  878:  			bc++;
  007f ec85         [3]     LDD   5,SP
  0081 c30001       [2]     ADDD  #1
  0084 6c85         [2]     STD   5,SP
  879:  			fs->wflag = 1;
  0086 eef011       [3]     LDX   17,SP
  0089 c601         [1]     LDAB  #1
  008b 6b04         [2]     STAB  4,X
  880:  			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  008d 34           [2]     PSHX  
  008e ec87         [3]     LDD   7,SP
  0090 160000       [4]     JSR   put_fat:0x019a
  0093 160000       [4]     JSR   move_window
  0096 1b82         [2]     LEAS  2,SP
  0098 6c87         [2]     STD   7,SP
  881:  			if (res != FR_OK) break;
  009a 2664         [3/1]   BNE   *+102 ;abs = 0100
  882:  			p = &fs->win[bc % SS(fs)];
  009c ec85         [3]     LDD   5,SP
  009e 160000       [4]     JSR   put_fat:0x018d
  00a1 6e89         [2]     STX   9,SP
  883:  			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  00a3 0ef010010f   [5]     BRSET 16,SP,#1,*+20 ;abs = 00b7
  00a8 e683         [3]     LDAB  3,SP
  00aa c40f         [1]     ANDB  #15
  00ac a600         [3]     LDAA  0,X
  00ae 84f0         [1]     ANDA  #240
  00b0 37           [2]     PSHB  
  00b1 aab0         [3]     ORAA  1,SP+
  00b3 6a80         [2]     STAA  0,SP
  00b5 200b         [3]     BRA   *+13 ;abs = 00c2
  00b7 ed83         [3]     LDY   3,SP
  00b9 ee81         [3]     LDX   1,SP
  00bb c604         [1]     LDAB  #4
  00bd 160000       [4]     JSR   _LSHRU
  00c0 6b80         [2]     STAB  0,SP
  00c2 ee89         [3]     LDX   9,SP
  00c4 e680         [3]     LDAB  0,SP
  00c6 6b00         [2]     STAB  0,X
  884:  			break;
  00c8 2036         [3]     BRA   *+56 ;abs = 0100
  885:  
  886:  		case FS_FAT16 :
  887:  			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  00ca eef011       [3]     LDX   17,SP
  00cd 34           [2]     PSHX  
  00ce ecf011       [3]     LDD   17,SP
  00d1 ed8f         [3]     LDY   15,SP
  00d3 36           [2]     PSHA  
  00d4 35           [2]     PSHY  
  00d5 33           [3]     PULB  
  00d6 31           [3]     PULY  
  00d7 87           [1]     CLRA  
  00d8 b7c6         [1]     EXG   D,Y
  00da e3e020       [3]     ADDD  32,X
  00dd b7c6         [1]     EXG   D,Y
  00df e9e01f       [3]     ADCB  31,X
  00e2 a9e01e       [3]     ADCA  30,X
  00e5 b7c6         [1]     EXG   D,Y
  00e7 b765         [1]     TFR   Y,X
  00e9 160000       [4]     JSR   move_window
  00ec 1b82         [2]     LEAS  2,SP
  00ee 6c87         [2]     STD   7,SP
  888:  			if (res != FR_OK) break;
  00f0 260e         [3/1]   BNE   *+16 ;abs = 0100
  889:  			p = &fs->win[clst * 2 % SS(fs)];
  00f2 ec8f         [3]     LDD   15,SP
  00f4 59           [1]     LSLD  
  00f5 160000       [4]     JSR   put_fat:0x018d
  890:  			ST_WORD(p, (WORD)val);
  00f8 e684         [3]     LDAB  4,SP
  00fa 6b00         [2]     STAB  0,X
  00fc e683         [3]     LDAB  3,SP
  00fe 6b01         [2]     STAB  1,X
  891:  			break;
  0100 2078         [3]     BRA   *+122 ;abs = 017a
  892:  
  893:  		case FS_FAT32 :
  894:  			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  0102 eef011       [3]     LDX   17,SP
  0105 34           [2]     PSHX  
  0106 edf011       [3]     LDY   17,SP
  0109 ee8f         [3]     LDX   15,SP
  010b c607         [1]     LDAB  #7
  010d 160000       [4]     JSR   _LSHRU
  0110 edf013       [3]     LDY   19,SP
  0113 e3e820       [3]     ADDD  32,Y
  0116 b7c5         [1]     EXG   D,X
  0118 e9e81f       [3]     ADCB  31,Y
  011b a9e81e       [3]     ADCA  30,Y
  011e b7c5         [1]     EXG   D,X
  0120 160000       [4]     JSR   move_window
  0123 1b82         [2]     LEAS  2,SP
  0125 6c87         [2]     STD   7,SP
  895:  			if (res != FR_OK) break;
  0127 2658         [3/1]   BNE   *+90 ;abs = 0181
  896:  			p = &fs->win[clst * 4 % SS(fs)];
  0129 ec8f         [3]     LDD   15,SP
  012b 59           [1]     LSLD  
  012c 59           [1]     LSLD  
  012d 075e         [4]     BSR   *+96 ;abs = 018d
  897:  			val |= LD_DWORD(p) & 0xF0000000;
  012f e603         [3]     LDAB  3,X
  0131 87           [1]     CLRA  
  0132 34           [2]     PSHX  
  0133 b705         [1]     SEX   A,X
  0135 b781         [1]     EXG   A,B
  0137 c7           [1]     CLRB  
  0138 b756         [1]     TFR   X,Y
  013a ee80         [3]     LDX   0,SP
  013c 3b           [2]     PSHD  
  013d e602         [3]     LDAB  2,X
  013f 87           [1]     CLRA  
  0140 b7c6         [1]     EXG   D,Y
  0142 ca00         [1]     ORAB  #0
  0144 8a00         [1]     ORAA  #0
  0146 b7c6         [1]     EXG   D,Y
  0148 ea81         [3]     ORAB  1,SP
  014a aa80         [3]     ORAA  0,SP
  014c ee82         [3]     LDX   2,SP
  014e 6c80         [2]     STD   0,SP
  0150 e601         [3]     LDAB  1,X
  0152 b710         [1]     TFR   B,A
  0154 c7           [1]     CLRB  
  0155 35           [2]     PSHY  
  0156 ea81         [3]     ORAB  1,SP
  0158 aab1         [3]     ORAA  2,SP+
  015a 3b           [2]     PSHD  
  015b ec82         [3]     LDD   2,SP
  015d c7           [1]     CLRB  
  015e 84f0         [1]     ANDA  #240
  0160 ed89         [3]     LDY   9,SP
  0162 ea88         [3]     ORAB  8,SP
  0164 aa87         [3]     ORAA  7,SP
  0166 6c87         [2]     STD   7,SP
  898:  			ST_DWORD(p, val);
  0168 e68a         [3]     LDAB  10,SP
  016a 6b00         [2]     STAB  0,X
  016c e689         [3]     LDAB  9,SP
  016e 6b01         [2]     STAB  1,X
  0170 e688         [3]     LDAB  8,SP
  0172 6b02         [2]     STAB  2,X
  0174 e687         [3]     LDAB  7,SP
  0176 6b03         [2]     STAB  3,X
  899:  			break;
  0178 1b86         [2]     LEAS  6,SP
  017a 2005         [3]     BRA   *+7 ;abs = 0181
  900:  
  901:  		default :
  902:  			res = FR_INT_ERR;
  017c c602         [1]     LDAB  #2
  017e 87           [1]     CLRA  
  017f 6c87         [2]     STD   7,SP
  903:  		}
  904:  		fs->wflag = 1;
  0181 eef011       [3]     LDX   17,SP
  0184 c601         [1]     LDAB  #1
  0186 6b04         [2]     STAB  4,X
  905:  	}
  906:  
  907:  	return res;
  0188 ec87         [3]     LDD   7,SP
  908:  }
  018a 1b8b         [2]     LEAS  11,SP
  018c 3d           [5]     RTS   
  018d 8401         [1]     ANDA  #1
  018f b745         [1]     TFR   D,X
  0191 ecf013       [3]     LDD   19,SP
  0194 c3002e       [2]     ADDD  #46
  0197 1ae6         [2]     LEAX  D,X
  0199 3d           [5]     RTS   
  019a b701         [1]     TFR   A,B
  019c 87           [1]     CLRA  
  019d 49           [1]     LSRD  
  019e e3e020       [3]     ADDD  32,X
  01a1 b746         [1]     TFR   D,Y
  01a3 cc0000       [2]     LDD   #0
  01a6 e9e01f       [3]     ADCB  31,X
  01a9 a9e01e       [3]     ADCA  30,X
  01ac b745         [1]     TFR   D,X
  01ae b764         [1]     TFR   Y,D
  01b0 3d           [5]     RTS   
  909:  #endif /* !_FS_READONLY */
  910:  
  911:  
  912:  
  913:  
  914:  /*-----------------------------------------------------------------------*/
  915:  /* FAT handling - Remove a cluster chain                                 */
  916:  /*-----------------------------------------------------------------------*/
  917:  #if !_FS_READONLY
  918:  static
  919:  FRESULT remove_chain (
  920:  	FATFS *fs,			/* File system object */
  921:  	DWORD clst			/* Cluster# to remove a chain from */
  922:  )
  923:  {
*** EVALUATION ***

Function: remove_chain
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca8         [2]     STD   8,-SP
  0002 6eae         [2]     STX   2,-SP
  924:  	FRESULT res;
  925:  	DWORD nxt;
  926:  #if _USE_ERASE
  927:  	DWORD scl = clst, ecl = clst, resion[2];
  928:  #endif
  929:  
  930:  	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  0004 2605         [3/1]   BNE   *+7 ;abs = 000b
  0006 8c0002       [2]     CPD   #2
  0009 252e         [3/1]   BCS   *+48 ;abs = 0039
  000b ed8c         [3]     LDY   12,SP
  000d 19e816       [2]     LEAY  22,Y
  0010 ec82         [3]     LDD   2,SP
  0012 160000       [4]     JSR   _LCMP_P
  0015 2422         [3/1]   BCC   *+36 ;abs = 0039
  931:  		res = FR_INT_ERR;
  932:  
  933:  	} else {
  934:  		res = FR_OK;
  0017 c7           [1]     CLRB  
  0018 87           [1]     CLRA  
  0019 6c88         [2]     STD   8,SP
  935:  		while (clst < fs->n_fatent) {			/* Not a last link? */
  001b 2072         [3]     BRA   *+116 ;abs = 008f
  936:  			nxt = get_fat(fs, clst);			/* Get cluster status */
  001d ec8c         [3]     LDD   12,SP
  001f 3b           [2]     PSHD  
  0020 ec84         [3]     LDD   4,SP
  0022 ee82         [3]     LDX   2,SP
  0024 160000       [4]     JSR   get_fat
  0027 1b82         [2]     LEAS  2,SP
  0029 6c86         [2]     STD   6,SP
  002b 6e84         [2]     STX   4,SP
  937:  			if (nxt == 0) break;				/* Empty cluster? */
  002d 046402       [3]     TBNE  D,*+5 ;abs = 0032
  0030 276d         [3/1]   BEQ   *+111 ;abs = 009f
  938:  			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  0032 04240b       [3]     DBNE  D,*+14 ;abs = 0040
  0035 ec84         [3]     LDD   4,SP
  0037 2607         [3/1]   BNE   *+9 ;abs = 0040
  0039 c602         [1]     LDAB  #2
  003b 87           [1]     CLRA  
  003c 6c88         [2]     STD   8,SP
  003e 205f         [3]     BRA   *+97 ;abs = 009f
  939:  			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  0040 ec86         [3]     LDD   6,SP
  0042 04a40c       [3]     IBNE  D,*+15 ;abs = 0051
  0045 ec84         [3]     LDD   4,SP
  0047 04a407       [3]     IBNE  D,*+10 ;abs = 0051
  004a c601         [1]     LDAB  #1
  004c 87           [1]     CLRA  
  004d 6c88         [2]     STD   8,SP
  004f 204e         [3]     BRA   *+80 ;abs = 009f
  940:  			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
  0051 ec8c         [3]     LDD   12,SP
  0053 3b           [2]     PSHD  
  0054 ec84         [3]     LDD   4,SP
  0056 3b           [2]     PSHD  
  0057 ec84         [3]     LDD   4,SP
  0059 3b           [2]     PSHD  
  005a c7           [1]     CLRB  
  005b 87           [1]     CLRA  
  005c b745         [1]     TFR   D,X
  005e 160000       [4]     JSR   put_fat
  0061 1b86         [2]     LEAS  6,SP
  0063 6c88         [2]     STD   8,SP
  941:  			if (res != FR_OK) break;
  0065 2638         [3/1]   BNE   *+58 ;abs = 009f
  942:  			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  0067 ee8c         [3]     LDX   12,SP
  0069 ece010       [3]     LDD   16,X
  006c 04a405       [3]     IBNE  D,*+8 ;abs = 0074
  006f ec0e         [3]     LDD   14,X
  0071 048413       [3]     IBEQ  D,*+22 ;abs = 0087
  943:  				fs->free_clust++;
  0074 ee0e         [3]     LDX   14,X
  0076 ed8c         [3]     LDY   12,SP
  0078 ece810       [3]     LDD   16,Y
  007b 160000       [4]     JSR   _LINC
  007e 6ce810       [3]     STD   16,Y
  0081 6e4e         [2]     STX   14,Y
  944:  				fs->fsi_flag = 1;
  0083 c601         [1]     LDAB  #1
  0085 6b45         [2]     STAB  5,Y
  945:  			}
  946:  #if _USE_ERASE
  947:  			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
  948:  				ecl = nxt;
  949:  			} else {				/* End of contiguous clusters */ 
  950:  				resion[0] = clust2sect(fs, scl);					/* Start sector */
  951:  				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
  952:  				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
  953:  				scl = ecl = nxt;
  954:  			}
  955:  #endif
  956:  			clst = nxt;	/* Next cluster */
  0087 ec86         [3]     LDD   6,SP
  0089 6c82         [2]     STD   2,SP
  008b ec84         [3]     LDD   4,SP
  008d 6c80         [2]     STD   0,SP
  008f ed8c         [3]     LDY   12,SP
  0091 19e816       [2]     LEAY  22,Y
  0094 ec82         [3]     LDD   2,SP
  0096 ee80         [3]     LDX   0,SP
  0098 160000       [4]     JSR   _LCMP_P
  009b 1825ff7e     [4/3]   LBCS  *-126 ;abs = 001d
  957:  		}
  958:  	}
  959:  
  960:  	return res;
  009f ec88         [3]     LDD   8,SP
  961:  }
  00a1 1b8a         [2]     LEAS  10,SP
  00a3 3d           [5]     RTS   
  962:  #endif
  963:  
  964:  
  965:  
  966:  
  967:  /*-----------------------------------------------------------------------*/
  968:  /* FAT handling - Stretch or Create a cluster chain                      */
  969:  /*-----------------------------------------------------------------------*/
  970:  #if !_FS_READONLY
  971:  static
  972:  DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
  973:  	FATFS *fs,			/* File system object */
  974:  	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
  975:  )
  976:  {
*** EVALUATION ***

Function: create_chain
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b92         [2]     LEAS  -14,SP
  0002 3b           [2]     PSHD  
  0003 6eae         [2]     STX   2,-SP
  977:  	DWORD cs, ncl, scl;
  978:  	FRESULT res;
  979:  
  980:  
  981:  	if (clst == 0) {		/* Create a new chain */
  0005 046429       [3]     TBNE  D,*+44 ;abs = 0031
  0008 2627         [3/1]   BNE   *+41 ;abs = 0031
  982:  		scl = fs->last_clust;			/* Get suggested start point */
  000a eef014       [3]     LDX   20,SP
  000d ec0a         [3]     LDD   10,X
  000f 6c8c         [2]     STD   12,SP
  0011 ec0c         [3]     LDD   12,X
  0013 6c8e         [2]     STD   14,SP
  983:  		if (!scl || scl >= fs->n_fatent) scl = 1;
  0015 2604         [3/1]   BNE   *+6 ;abs = 001b
  0017 ec8c         [3]     LDD   12,SP
  0019 270e         [3/1]   BEQ   *+16 ;abs = 0029
  001b 1ae016       [2]     LEAX  22,X
  001e ec8e         [3]     LDD   14,SP
  0020 b756         [1]     TFR   X,Y
  0022 ee8c         [3]     LDX   12,SP
  0024 160000       [4]     JSR   _LCMP_P
  0027 253e         [3/1]   BCS   *+64 ;abs = 0067
  0029 c601         [1]     LDAB  #1
  002b 87           [1]     CLRA  
  002c 6c8e         [2]     STD   14,SP
  002e c7           [1]     CLRB  
  002f 2034         [3]     BRA   *+54 ;abs = 0065
  984:  	}
  985:  	else {					/* Stretch the current chain */
  986:  		cs = get_fat(fs, clst);			/* Check the cluster status */
  0031 ecf014       [3]     LDD   20,SP
  0034 3b           [2]     PSHD  
  0035 ec84         [3]     LDD   4,SP
  0037 ee82         [3]     LDX   2,SP
  0039 160000       [4]     JSR   get_fat
  003c 1b82         [2]     LEAS  2,SP
  003e 6c8a         [2]     STD   10,SP
  0040 6e88         [2]     STX   8,SP
  987:  		if (cs < 2) return 1;			/* It is an invalid cluster */
  0042 260c         [3/1]   BNE   *+14 ;abs = 0050
  0044 8c0002       [2]     CPD   #2
  0047 2407         [3/1]   BCC   *+9 ;abs = 0050
  0049 c601         [1]     LDAB  #1
  004b 87           [1]     CLRA  
  004c b705         [1]     SEX   A,X
  004e 207b         [3]     BRA   *+125 ;abs = 00cb
  988:  		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  0050 edf014       [3]     LDY   20,SP
  0053 19e816       [2]     LEAY  22,Y
  0056 ec8a         [3]     LDD   10,SP
  0058 160000       [4]     JSR   _LCMP_P
  005b 2402         [3/1]   BCC   *+4 ;abs = 005f
  005d 206c         [3]     BRA   *+110 ;abs = 00cb
  989:  		scl = clst;
  005f ec82         [3]     LDD   2,SP
  0061 6c8e         [2]     STD   14,SP
  0063 ec80         [3]     LDD   0,SP
  0065 6c8c         [2]     STD   12,SP
  990:  	}
  991:  
  992:  	ncl = scl;				/* Start cluster */
  0067 ec8e         [3]     LDD   14,SP
  0069 6c86         [2]     STD   6,SP
  006b ec8c         [3]     LDD   12,SP
  006d 6c84         [2]     STD   4,SP
  993:  	for (;;) {
  994:  		ncl++;							/* Next cluster */
  006f ec86         [3]     LDD   6,SP
  0071 ee84         [3]     LDX   4,SP
  0073 160000       [4]     JSR   _LINC
  0076 6c86         [2]     STD   6,SP
  0078 6e84         [2]     STX   4,SP
  995:  		if (ncl >= fs->n_fatent) {		/* Wrap around */
  007a edf014       [3]     LDY   20,SP
  007d 19e816       [2]     LEAY  22,Y
  0080 160000       [4]     JSR   _LCMP_P
  0083 251b         [3/1]   BCS   *+29 ;abs = 00a0
  996:  			ncl = 2;
  0085 c602         [1]     LDAB  #2
  0087 87           [1]     CLRA  
  0088 6c86         [2]     STD   6,SP
  008a 6985         [2]     CLR   5,SP
  008c 6984         [2]     CLR   4,SP
  997:  			if (ncl > scl) return 0;	/* No free cluster */
  008e c7           [1]     CLRB  
  008f ac8c         [3]     CPD   12,SP
  0091 2209         [3/1]   BHI   *+11 ;abs = 009c
  0093 260b         [3/1]   BNE   *+13 ;abs = 00a0
  0095 ce0002       [2]     LDX   #2
  0098 ae8e         [3]     CPX   14,SP
  009a 2304         [3/1]   BLS   *+6 ;abs = 00a0
  009c b745         [1]     TFR   D,X
  009e 203e         [3]     BRA   *+64 ;abs = 00de
  998:  		}
  999:  		cs = get_fat(fs, ncl);			/* Get the cluster status */
  00a0 ecf014       [3]     LDD   20,SP
  00a3 3b           [2]     PSHD  
  00a4 ec88         [3]     LDD   8,SP
  00a6 ee86         [3]     LDX   6,SP
  00a8 160000       [4]     JSR   get_fat
  00ab 1b82         [2]     LEAS  2,SP
  00ad 6c8a         [2]     STD   10,SP
  00af 6e88         [2]     STX   8,SP
 1000:  		if (cs == 0) break;				/* Found a free cluster */
  00b1 046402       [3]     TBNE  D,*+5 ;abs = 00b6
  00b4 272b         [3/1]   BEQ   *+45 ;abs = 00e1
 1001:  		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  00b6 04a405       [3]     IBNE  D,*+8 ;abs = 00be
  00b9 ec88         [3]     LDD   8,SP
  00bb 048409       [3]     IBEQ  D,*+12 ;abs = 00c7
  00be ec8a         [3]     LDD   10,SP
  00c0 04240a       [3]     DBNE  D,*+13 ;abs = 00cd
  00c3 ec88         [3]     LDD   8,SP
  00c5 2606         [3/1]   BNE   *+8 ;abs = 00cd
 1002:  			return cs;
  00c7 ec8a         [3]     LDD   10,SP
  00c9 ee88         [3]     LDX   8,SP
  00cb 2011         [3]     BRA   *+19 ;abs = 00de
 1003:  		if (ncl == scl) return 0;		/* No free cluster */
  00cd ec86         [3]     LDD   6,SP
  00cf ac8e         [3]     CPD   14,SP
  00d1 269c         [3/1]   BNE   *-98 ;abs = 006f
  00d3 ec84         [3]     LDD   4,SP
  00d5 ac8c         [3]     CPD   12,SP
  00d7 2696         [3/1]   BNE   *-104 ;abs = 006f
  00d9 ce0000       [2]     LDX   #0
  00dc b754         [1]     TFR   X,D
  00de 060000       [3]     JMP   create_chain:0x0161
 1004:  	}
 1005:  
 1006:  	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
  00e1 ecf014       [3]     LDD   20,SP
  00e4 3b           [2]     PSHD  
  00e5 ec88         [3]     LDD   8,SP
  00e7 3b           [2]     PSHD  
  00e8 ec88         [3]     LDD   8,SP
  00ea 3b           [2]     PSHD  
  00eb ccffff       [2]     LDD   #65535
  00ee ce0fff       [2]     LDX   #4095
  00f1 160000       [4]     JSR   put_fat
  00f4 1b86         [2]     LEAS  6,SP
  00f6 6cf010       [3]     STD   16,SP
 1007:  	if (res == FR_OK && clst != 0) {
  00f9 261e         [3/1]   BNE   *+32 ;abs = 0119
  00fb ec82         [3]     LDD   2,SP
  00fd 2604         [3/1]   BNE   *+6 ;abs = 0103
  00ff ec80         [3]     LDD   0,SP
  0101 2716         [3/1]   BEQ   *+24 ;abs = 0119
 1008:  		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
  0103 ecf014       [3]     LDD   20,SP
  0106 3b           [2]     PSHD  
  0107 ec84         [3]     LDD   4,SP
  0109 3b           [2]     PSHD  
  010a ec84         [3]     LDD   4,SP
  010c 3b           [2]     PSHD  
  010d ec8c         [3]     LDD   12,SP
  010f ee8a         [3]     LDX   10,SP
  0111 160000       [4]     JSR   put_fat
  0114 1b86         [2]     LEAS  6,SP
  0116 6cf010       [3]     STD   16,SP
 1009:  	}
 1010:  	if (res == FR_OK) {
  0119 ecf010       [3]     LDD   16,SP
  011c 262c         [3/1]   BNE   *+46 ;abs = 014a
 1011:  		fs->last_clust = ncl;			/* Update FSINFO */
  011e eef014       [3]     LDX   20,SP
  0121 ec84         [3]     LDD   4,SP
  0123 6c0a         [2]     STD   10,X
  0125 ec86         [3]     LDD   6,SP
  0127 6c0c         [2]     STD   12,X
 1012:  		if (fs->free_clust != 0xFFFFFFFF) {
  0129 ece010       [3]     LDD   16,X
  012c 04a405       [3]     IBNE  D,*+8 ;abs = 0134
  012f ec0e         [3]     LDD   14,X
  0131 048429       [3]     IBEQ  D,*+44 ;abs = 015d
 1013:  			fs->free_clust--;
  0134 ee0e         [3]     LDX   14,X
  0136 edf014       [3]     LDY   20,SP
  0139 ece810       [3]     LDD   16,Y
  013c 160000       [4]     JSR   _LDEC
  013f 6ce810       [3]     STD   16,Y
  0142 6e4e         [2]     STX   14,Y
 1014:  			fs->fsi_flag = 1;
  0144 c601         [1]     LDAB  #1
  0146 6b45         [2]     STAB  5,Y
 1015:  		}
 1016:  	} else {
  0148 2013         [3]     BRA   *+21 ;abs = 015d
 1017:  		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  014a 040407       [3]     DBEQ  D,*+10 ;abs = 0154
  014d c601         [1]     LDAB  #1
  014f 87           [1]     CLRA  
  0150 b705         [1]     SEX   A,X
  0152 2005         [3]     BRA   *+7 ;abs = 0159
  0154 ceffff       [2]     LDX   #65535
  0157 b754         [1]     TFR   X,D
  0159 6c86         [2]     STD   6,SP
  015b 6e84         [2]     STX   4,SP
 1018:  	}
 1019:  
 1020:  	return ncl;		/* Return new cluster number or error code */
  015d ec86         [3]     LDD   6,SP
  015f ee84         [3]     LDX   4,SP
 1021:  }
  0161 1bf012       [2]     LEAS  18,SP
  0164 3d           [5]     RTS   
 1022:  #endif /* !_FS_READONLY */
 1023:  
 1024:  
 1025:  
 1026:  /*-----------------------------------------------------------------------*/
 1027:  /* FAT handling - Convert offset into cluster with link map table        */
 1028:  /*-----------------------------------------------------------------------*/
 1029:  
 1030:  #if _USE_FASTSEEK
 1031:  static
 1032:  DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
 1033:  	FIL* fp,		/* Pointer to the file object */
 1034:  	DWORD ofs		/* File offset to be converted to cluster# */
 1035:  )
 1036:  {
 1037:  	DWORD cl, ncl, *tbl;
 1038:  
 1039:  
 1040:  	tbl = fp->cltbl + 1;	/* Top of CLMT */
 1041:  	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
 1042:  	for (;;) {
 1043:  		ncl = *tbl++;			/* Number of cluters in the fragment */
 1044:  		if (!ncl) return 0;		/* End of table? (error) */
 1045:  		if (cl < ncl) break;	/* In this fragment? */
 1046:  		cl -= ncl; tbl++;		/* Next fragment */
 1047:  	}
 1048:  	return cl + *tbl;	/* Return the cluster number */
 1049:  }
 1050:  #endif	/* _USE_FASTSEEK */
 1051:  
 1052:  
 1053:  
 1054:  /*-----------------------------------------------------------------------*/
 1055:  /* Directory handling - Set directory index                              */
 1056:  /*-----------------------------------------------------------------------*/
 1057:  
 1058:  static
 1059:  FRESULT dir_sdi (
 1060:  	DIR *dj,		/* Pointer to directory object */
 1061:  	WORD idx		/* Directory index number */
 1062:  )
 1063:  {
*** EVALUATION ***

Function: dir_sdi
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca8         [2]     STD   8,-SP
  0002 3b           [2]     PSHD  
 1064:  	DWORD clst;
 1065:  	WORD ic;
 1066:  
 1067:  
 1068:  	dj->index = idx;
  0003 ee8c         [3]     LDX   12,SP
  0005 6c04         [2]     STD   4,X
 1069:  	clst = dj->sclust;
  0007 ec06         [3]     LDD   6,X
  0009 6c84         [2]     STD   4,SP
  000b ec08         [3]     LDD   8,X
  000d 6c86         [2]     STD   6,SP
 1070:  	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  000f 042406       [3]     DBNE  D,*+9 ;abs = 0018
  0012 ec84         [3]     LDD   4,SP
  0014 182700a0     [4/3]   LBEQ  *+164 ;abs = 00b8
  0018 ed00         [3]     LDY   0,X
  001a 1ae816       [2]     LEAX  22,Y
  001d ec86         [3]     LDD   6,SP
  001f 34           [2]     PSHX  
  0020 ee86         [3]     LDX   6,SP
  0022 6d82         [2]     STY   2,SP
  0024 31           [3]     PULY  
  0025 160000       [4]     JSR   _LCMP_P
  0028 242e         [3/1]   BCC   *+48 ;abs = 0058
 1071:  		return FR_INT_ERR;
 1072:  	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  002a 046415       [3]     TBNE  D,*+24 ;abs = 0042
  002d 046512       [3]     TBNE  X,*+21 ;abs = 0042
  0030 ee80         [3]     LDX   0,SP
  0032 e600         [3]     LDAB  0,X
  0034 c103         [1]     CMPB  #3
  0036 260a         [3/1]   BNE   *+12 ;abs = 0042
 1073:  		clst = dj->fs->dirbase;
  0038 ece022       [3]     LDD   34,X
  003b 6c84         [2]     STD   4,SP
  003d ece024       [3]     LDD   36,X
  0040 6c86         [2]     STD   6,SP
 1074:  
 1075:  	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  0042 ec86         [3]     LDD   6,SP
  0044 262c         [3/1]   BNE   *+46 ;abs = 0072
  0046 ec84         [3]     LDD   4,SP
  0048 2628         [3/1]   BNE   *+42 ;abs = 0072
 1076:  		dj->clust = clst;
  004a ee8c         [3]     LDX   12,SP
  004c 6c0a         [2]     STD   10,X
  004e ec86         [3]     LDD   6,SP
  0050 6c0c         [2]     STD   12,X
 1077:  		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  0052 ed00         [3]     LDY   0,X
  0054 ec82         [3]     LDD   2,SP
  0056 ac48         [3]     CPD   8,Y
  0058 245e         [3/1]   BCC   *+96 ;abs = 00b8
 1078:  			return FR_INT_ERR;
 1079:  		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  005a 49           [1]     LSRD  
  005b 49           [1]     LSRD  
  005c 49           [1]     LSRD  
  005d 49           [1]     LSRD  
  005e e3e824       [3]     ADDD  36,Y
  0061 3b           [2]     PSHD  
  0062 ece822       [3]     LDD   34,Y
  0065 c900         [1]     ADCB  #0
  0067 8900         [1]     ADCA  #0
  0069 6c0e         [2]     STD   14,X
  006b 3a           [3]     PULD  
  006c 6ce010       [3]     STD   16,X
 1080:  	}
  006f 060000       [3]     JMP   dir_sdi:0x00f8
 1081:  	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
 1082:  		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  0072 ee8c         [3]     LDX   12,SP
  0074 ed00         [3]     LDY   0,X
  0076 e642         [3]     LDAB  2,Y
  0078 37           [2]     PSHB  
  0079 c610         [1]     LDAB  #16
  007b 32           [3]     PULA  
  007c 12           [1]     MUL   
  007d 6c88         [2]     STD   8,SP
 1083:  		while (idx >= ic) {	/* Follow cluster chain */
  007f 2041         [3]     BRA   *+67 ;abs = 00c2
 1084:  			clst = get_fat(dj->fs, clst);				/* Get next cluster */
  0081 ee8c         [3]     LDX   12,SP
  0083 ec00         [3]     LDD   0,X
  0085 3b           [2]     PSHD  
  0086 ec88         [3]     LDD   8,SP
  0088 ee86         [3]     LDX   6,SP
  008a 160000       [4]     JSR   get_fat
  008d 1b82         [2]     LEAS  2,SP
  008f 6c86         [2]     STD   6,SP
  0091 6e84         [2]     STX   4,SP
 1085:  			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  0093 04a407       [3]     IBNE  D,*+10 ;abs = 009d
  0096 04a504       [3]     IBNE  X,*+7 ;abs = 009d
  0099 c601         [1]     LDAB  #1
  009b 2075         [3]     BRA   *+119 ;abs = 0112
 1086:  			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  009d ec84         [3]     LDD   4,SP
  009f 2607         [3/1]   BNE   *+9 ;abs = 00a8
  00a1 ec86         [3]     LDD   6,SP
  00a3 8c0002       [2]     CPD   #2
  00a6 2510         [3/1]   BCS   *+18 ;abs = 00b8
  00a8 ee8c         [3]     LDX   12,SP
  00aa ed00         [3]     LDY   0,X
  00ac 19e816       [2]     LEAY  22,Y
  00af ec86         [3]     LDD   6,SP
  00b1 ee84         [3]     LDX   4,SP
  00b3 160000       [4]     JSR   _LCMP_P
  00b6 2504         [3/1]   BCS   *+6 ;abs = 00bc
 1087:  				return FR_INT_ERR;
  00b8 c602         [1]     LDAB  #2
  00ba 2056         [3]     BRA   *+88 ;abs = 0112
 1088:  			idx -= ic;
  00bc ec82         [3]     LDD   2,SP
  00be a388         [3]     SUBD  8,SP
  00c0 6c82         [2]     STD   2,SP
  00c2 ec82         [3]     LDD   2,SP
  00c4 ac88         [3]     CPD   8,SP
  00c6 24b9         [3/1]   BCC   *-69 ;abs = 0081
 1089:  		}
 1090:  		dj->clust = clst;
  00c8 ee8c         [3]     LDX   12,SP
  00ca ec84         [3]     LDD   4,SP
  00cc 6c0a         [2]     STD   10,X
  00ce ec86         [3]     LDD   6,SP
  00d0 6c0c         [2]     STD   12,X
 1091:  		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  00d2 ec00         [3]     LDD   0,X
  00d4 3b           [2]     PSHD  
  00d5 ec88         [3]     LDD   8,SP
  00d7 ee86         [3]     LDX   6,SP
  00d9 160000       [4]     JSR   clust2sect
  00dc 6c80         [2]     STD   0,SP
  00de ec84         [3]     LDD   4,SP
  00e0 49           [1]     LSRD  
  00e1 49           [1]     LSRD  
  00e2 49           [1]     LSRD  
  00e3 49           [1]     LSRD  
  00e4 e380         [3]     ADDD  0,SP
  00e6 ed8e         [3]     LDY   14,SP
  00e8 6ce810       [3]     STD   16,Y
  00eb cc0000       [2]     LDD   #0
  00ee b7c5         [1]     EXG   D,X
  00f0 c900         [1]     ADCB  #0
  00f2 8900         [1]     ADCA  #0
  00f4 6c4e         [2]     STD   14,Y
  00f6 1b82         [2]     LEAS  2,SP
 1092:  	}
 1093:  
 1094:  	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  00f8 ee8c         [3]     LDX   12,SP
  00fa ec00         [3]     LDD   0,X
  00fc 3b           [2]     PSHD  
  00fd ec84         [3]     LDD   4,SP
  00ff c40f         [1]     ANDB  #15
  0101 87           [1]     CLRA  
  0102 cd0020       [2]     LDY   #32
  0105 13           [3]     EMUL  
  0106 b746         [1]     TFR   D,Y
  0108 3a           [3]     PULD  
  0109 c3002e       [2]     ADDD  #46
  010c 19ee         [2]     LEAY  D,Y
  010e 6de012       [3]     STY   18,X
 1095:  
 1096:  	return FR_OK;	/* Seek succeeded */
  0111 c7           [1]     CLRB  
  0112 87           [1]     CLRA  
 1097:  }
  0113 1b8a         [2]     LEAS  10,SP
  0115 3d           [5]     RTS   
 1098:  
 1099:  
 1100:  
 1101:  
 1102:  /*-----------------------------------------------------------------------*/
 1103:  /* Directory handling - Move directory index next                        */
 1104:  /*-----------------------------------------------------------------------*/
 1105:  
 1106:  static
 1107:  FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
 1108:  	DIR *dj,		/* Pointer to directory object */
 1109:  	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
 1110:  )
 1111:  {
*** EVALUATION ***

Function: dir_next
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b99         [2]     LEAS  -7,SP
  0002 3b           [2]     PSHD  
  0003 3b           [2]     PSHD  
 1112:  	DWORD clst;
 1113:  	WORD i;
 1114:  
 1115:  
 1116:  	i = dj->index + 1;
  0004 ee8d         [3]     LDX   13,SP
  0006 ed04         [3]     LDY   4,X
  0008 02           [1]     INY   
  0009 6d88         [2]     STY   8,SP
 1117:  	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  000b 2707         [3/1]   BEQ   *+9 ;abs = 0014
  000d ece010       [3]     LDD   16,X
  0010 2604         [3/1]   BNE   *+6 ;abs = 0016
  0012 ec0e         [3]     LDD   14,X
  0014 277b         [3/1]   BEQ   *+125 ;abs = 0091
 1118:  		return FR_NO_FILE;
 1119:  
 1120:  	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  0016 0f890f03     [4]     BRCLR 9,SP,#15,*+7 ;abs = 001d
  001a 060000       [3]     JMP   dir_next:0x0146
 1121:  		dj->sect++;					/* Next sector */
  001d ee0e         [3]     LDX   14,X
  001f ed8d         [3]     LDY   13,SP
  0021 ece810       [3]     LDD   16,Y
  0024 160000       [4]     JSR   _LINC
  0027 6ce810       [3]     STD   16,Y
  002a 6e4e         [2]     STX   14,Y
 1122:  
 1123:  		if (dj->clust == 0) {	/* Static table */
  002c ec4c         [3]     LDD   12,Y
  002e 2610         [3/1]   BNE   *+18 ;abs = 0040
  0030 ec4a         [3]     LDD   10,Y
  0032 260c         [3/1]   BNE   *+14 ;abs = 0040
 1124:  			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  0034 ee40         [3]     LDX   0,Y
  0036 ec88         [3]     LDD   8,SP
  0038 ac08         [3]     CPD   8,X
  003a 18250108     [4/3]   LBCS  *+268 ;abs = 0146
 1125:  				return FR_NO_FILE;
  003e 2051         [3]     BRA   *+83 ;abs = 0091
 1126:  		}
 1127:  		else {					/* Dynamic table */
 1128:  			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  0040 ee40         [3]     LDX   0,Y
  0042 e602         [3]     LDAB  2,X
  0044 87           [1]     CLRA  
  0045 3b           [2]     PSHD  
  0046 ec8a         [3]     LDD   10,SP
  0048 49           [1]     LSRD  
  0049 49           [1]     LSRD  
  004a 49           [1]     LSRD  
  004b 49           [1]     LSRD  
  004c 6e82         [2]     STX   2,SP
  004e 30           [3]     PULX  
  004f 09           [1]     DEX   
  0050 34           [2]     PSHX  
  0051 e481         [3]     ANDB  1,SP
  0053 a4b1         [3]     ANDA  2,SP+
  0055 0464ee       [3]     TBNE  D,*+241 ;abs = 0146
 1129:  				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
  0058 ec80         [3]     LDD   0,SP
  005a 3b           [2]     PSHD  
  005b ec4c         [3]     LDD   12,Y
  005d ee4a         [3]     LDX   10,Y
  005f 160000       [4]     JSR   get_fat
  0062 1b82         [2]     LEAS  2,SP
  0064 6c86         [2]     STD   6,SP
  0066 6e84         [2]     STX   4,SP
 1130:  				if (clst <= 1) return FR_INT_ERR;
  0068 2605         [3/1]   BNE   *+7 ;abs = 006f
  006a 8c0001       [2]     CPD   #1
  006d 2348         [3/1]   BLS   *+74 ;abs = 00b7
 1131:  				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  006f ec86         [3]     LDD   6,SP
  0071 04a403       [3]     IBNE  D,*+6 ;abs = 0077
  0074 048582       [3]     IBEQ  X,*+133 ;abs = 00f9
 1132:  				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  0077 ee8d         [3]     LDX   13,SP
  0079 ed00         [3]     LDY   0,X
  007b 1ae816       [2]     LEAX  22,Y
  007e ec86         [3]     LDD   6,SP
  0080 34           [2]     PSHX  
  0081 ee86         [3]     LDX   6,SP
  0083 6d82         [2]     STY   2,SP
  0085 31           [3]     PULY  
  0086 160000       [4]     JSR   _LCMP_P
  0089 182500a8     [4/3]   LBCS  *+172 ;abs = 0135
 1133:  #if !_FS_READONLY
 1134:  					BYTE c;
 1135:  					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  008d ec82         [3]     LDD   2,SP
  008f 2604         [3/1]   BNE   *+6 ;abs = 0095
  0091 c604         [1]     LDAB  #4
  0093 2066         [3]     BRA   *+104 ;abs = 00fb
 1136:  					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  0095 ec80         [3]     LDD   0,SP
  0097 3b           [2]     PSHD  
  0098 ee8f         [3]     LDX   15,SP
  009a ec0c         [3]     LDD   12,X
  009c ee0a         [3]     LDX   10,X
  009e 160000       [4]     JSR   create_chain
  00a1 1b82         [2]     LEAS  2,SP
  00a3 6c86         [2]     STD   6,SP
  00a5 6e84         [2]     STX   4,SP
 1137:  					if (clst == 0) return FR_DENIED;			/* No free cluster */
  00a7 046406       [3]     TBNE  D,*+9 ;abs = 00b0
  00aa 2604         [3/1]   BNE   *+6 ;abs = 00b0
  00ac c607         [1]     LDAB  #7
  00ae 204b         [3]     BRA   *+77 ;abs = 00fb
 1138:  					if (clst == 1) return FR_INT_ERR;
  00b0 042408       [3]     DBNE  D,*+11 ;abs = 00bb
  00b3 ec84         [3]     LDD   4,SP
  00b5 2604         [3/1]   BNE   *+6 ;abs = 00bb
  00b7 c602         [1]     LDAB  #2
  00b9 2040         [3]     BRA   *+66 ;abs = 00fb
 1139:  					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  00bb ec86         [3]     LDD   6,SP
  00bd 04a405       [3]     IBNE  D,*+8 ;abs = 00c5
  00c0 ec84         [3]     LDD   4,SP
  00c2 048434       [3]     IBEQ  D,*+55 ;abs = 00f9
 1140:  					/* Clean-up stretched table */
 1141:  					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  00c5 160000       [4]     JSR   dir_next:0x0168
  00c8 04642e       [3]     TBNE  D,*+49 ;abs = 00f9
 1142:  					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  00cb ee8d         [3]     LDX   13,SP
  00cd ec00         [3]     LDD   0,X
  00cf c3002e       [2]     ADDD  #46
  00d2 3b           [2]     PSHD  
  00d3 c7           [1]     CLRB  
  00d4 87           [1]     CLRA  
  00d5 3b           [2]     PSHD  
  00d6 8602         [1]     LDAA  #2
  00d8 160000       [4]     JSR   mem_set
  00db 1b84         [2]     LEAS  4,SP
 1143:  					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  00dd ee8d         [3]     LDX   13,SP
  00df 160000       [4]     JSR   dir_next:0x0177
  00e2 34           [2]     PSHX  
  00e3 ee40         [3]     LDX   0,Y
  00e5 31           [3]     PULY  
  00e6 6de02a       [3]     STY   42,X
  00e9 6ce02c       [3]     STD   44,X
 1144:  					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  00ec 698a         [2]     CLR   10,SP
  00ee 2022         [3]     BRA   *+36 ;abs = 0112
 1145:  						dj->fs->wflag = 1;
  00f0 c601         [1]     LDAB  #1
  00f2 6b44         [2]     STAB  4,Y
 1146:  						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  00f4 0772         [4]     BSR   *+116 ;abs = 0168
  00f6 044404       [3]     TBEQ  D,*+7 ;abs = 00fd
  00f9 c601         [1]     LDAB  #1
  00fb 2067         [3]     BRA   *+105 ;abs = 0164
 1147:  						dj->fs->winsect++;
  00fd ee8d         [3]     LDX   13,SP
  00ff ed00         [3]     LDY   0,X
  0101 eee82a       [3]     LDX   42,Y
  0104 ece82c       [3]     LDD   44,Y
  0107 160000       [4]     JSR   _LINC
  010a 6ce82c       [3]     STD   44,Y
  010d 6ee82a       [3]     STX   42,Y
  0110 628a         [3]     INC   10,SP
  0112 ee8d         [3]     LDX   13,SP
  0114 ed00         [3]     LDY   0,X
  0116 e68a         [3]     LDAB  10,SP
  0118 e142         [3]     CMPB  2,Y
  011a 25d4         [3/1]   BCS   *-42 ;abs = 00f0
 1148:  					}
 1149:  					dj->fs->winsect -= c;						/* Rewind window address */
  011c 87           [1]     CLRA  
  011d 3b           [2]     PSHD  
  011e ece82c       [3]     LDD   44,Y
  0121 a380         [3]     SUBD  0,SP
  0123 6ce82c       [3]     STD   44,Y
  0126 ece82a       [3]     LDD   42,Y
  0129 ce0000       [2]     LDX   #0
  012c c200         [1]     SBCB  #0
  012e 8200         [1]     SBCA  #0
  0130 6ce82a       [3]     STD   42,Y
  0133 1b82         [2]     LEAS  2,SP
 1150:  #else
 1151:  					return FR_NO_FILE;			/* Report EOT */
 1152:  #endif
 1153:  				}
 1154:  				dj->clust = clst;				/* Initialize data for new cluster */
  0135 ee8d         [3]     LDX   13,SP
  0137 ec84         [3]     LDD   4,SP
  0139 6c0a         [2]     STD   10,X
  013b ec86         [3]     LDD   6,SP
  013d 6c0c         [2]     STD   12,X
 1155:  				dj->sect = clust2sect(dj->fs, clst);
  013f 0736         [4]     BSR   *+56 ;abs = 0177
  0141 6e4e         [2]     STX   14,Y
  0143 6ce810       [3]     STD   16,Y
 1156:  			}
 1157:  		}
 1158:  	}
 1159:  
 1160:  	dj->index = i;
  0146 ee8d         [3]     LDX   13,SP
  0148 ec88         [3]     LDD   8,SP
  014a 6c04         [2]     STD   4,X
 1161:  	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  014c ec00         [3]     LDD   0,X
  014e 3b           [2]     PSHD  
  014f ec8a         [3]     LDD   10,SP
  0151 c40f         [1]     ANDB  #15
  0153 87           [1]     CLRA  
  0154 cd0020       [2]     LDY   #32
  0157 13           [3]     EMUL  
  0158 b746         [1]     TFR   D,Y
  015a 3a           [3]     PULD  
  015b c3002e       [2]     ADDD  #46
  015e 19ee         [2]     LEAY  D,Y
  0160 6de012       [3]     STY   18,X
 1162:  
 1163:  	return FR_OK;
  0163 c7           [1]     CLRB  
  0164 87           [1]     CLRA  
 1164:  }
  0165 1b8b         [2]     LEAS  11,SP
  0167 3d           [5]     RTS   
  0168 ee8f         [3]     LDX   15,SP
  016a ec00         [3]     LDD   0,X
  016c 3b           [2]     PSHD  
  016d c7           [1]     CLRB  
  016e 87           [1]     CLRA  
  016f b745         [1]     TFR   D,X
  0171 160000       [4]     JSR   move_window
  0174 1b82         [2]     LEAS  2,SP
  0176 3d           [5]     RTS   
  0177 ec00         [3]     LDD   0,X
  0179 3b           [2]     PSHD  
  017a ec8a         [3]     LDD   10,SP
  017c ee88         [3]     LDX   8,SP
  017e 160000       [4]     JSR   clust2sect
  0181 31           [3]     PULY  
  0182 ed8f         [3]     LDY   15,SP
  0184 3d           [5]     RTS   
 1165:  
 1166:  
 1167:  
 1168:  
 1169:  /*-----------------------------------------------------------------------*/
 1170:  /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
 1171:  /*-----------------------------------------------------------------------*/
 1172:  #if _USE_LFN
 1173:  static
 1174:  const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
 1175:  
 1176:  
 1177:  static
 1178:  int cmp_lfn (			/* 1:Matched, 0:Not matched */
 1179:  	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
 1180:  	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
 1181:  )
 1182:  {
 1183:  	UINT i, s;
 1184:  	WCHAR wc, uc;
 1185:  
 1186:  
 1187:  	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
 1188:  	s = 0; wc = 1;
 1189:  	do {
 1190:  		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
 1191:  		if (wc) {	/* Last char has not been processed */
 1192:  			wc = ff_wtoupper(uc);		/* Convert it to upper case */
 1193:  			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
 1194:  				return 0;				/* Not matched */
 1195:  		} else {
 1196:  			if (uc != 0xFFFF) return 0;	/* Check filler */
 1197:  		}
 1198:  	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
 1199:  
 1200:  	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
 1201:  		return 0;
 1202:  
 1203:  	return 1;						/* The part of LFN matched */
 1204:  }
 1205:  
 1206:  
 1207:  
 1208:  static
 1209:  int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
 1210:  	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
 1211:  	BYTE *dir			/* Pointer to the directory entry */
 1212:  )
 1213:  {
 1214:  	UINT i, s;
 1215:  	WCHAR wc, uc;
 1216:  
 1217:  
 1218:  	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 1219:  
 1220:  	s = 0; wc = 1;
 1221:  	do {
 1222:  		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
 1223:  		if (wc) {	/* Last char has not been processed */
 1224:  			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 1225:  			lfnbuf[i++] = wc = uc;			/* Store it */
 1226:  		} else {
 1227:  			if (uc != 0xFFFF) return 0;		/* Check filler */
 1228:  		}
 1229:  	} while (++s < 13);						/* Read all character in the entry */
 1230:  
 1231:  	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
 1232:  		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 1233:  		lfnbuf[i] = 0;
 1234:  	}
 1235:  
 1236:  	return 1;
 1237:  }
 1238:  
 1239:  
 1240:  #if !_FS_READONLY
 1241:  static
 1242:  void fit_lfn (
 1243:  	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
 1244:  	BYTE *dir,				/* Pointer to the directory entry */
 1245:  	BYTE ord,				/* LFN order (1-20) */
 1246:  	BYTE sum				/* SFN sum */
 1247:  )
 1248:  {
 1249:  	UINT i, s;
 1250:  	WCHAR wc;
 1251:  
 1252:  
 1253:  	dir[LDIR_Chksum] = sum;			/* Set check sum */
 1254:  	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 1255:  	dir[LDIR_Type] = 0;
 1256:  	ST_WORD(dir+LDIR_FstClusLO, 0);
 1257:  
 1258:  	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
 1259:  	s = wc = 0;
 1260:  	do {
 1261:  		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
 1262:  		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
 1263:  		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
 1264:  	} while (++s < 13);
 1265:  	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
 1266:  	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 1267:  }
 1268:  
 1269:  #endif
 1270:  #endif
 1271:  
 1272:  
 1273:  
 1274:  /*-----------------------------------------------------------------------*/
 1275:  /* Create numbered name                                                  */
 1276:  /*-----------------------------------------------------------------------*/
 1277:  #if _USE_LFN
 1278:  void gen_numname (
 1279:  	BYTE *dst,			/* Pointer to generated SFN */
 1280:  	const BYTE *src,	/* Pointer to source SFN to be modified */
 1281:  	const WCHAR *lfn,	/* Pointer to LFN */
 1282:  	WORD seq			/* Sequence number */
 1283:  )
 1284:  {
 1285:  	BYTE ns[8], c;
 1286:  	UINT i, j;
 1287:  
 1288:  
 1289:  	mem_cpy(dst, src, 11);
 1290:  
 1291:  	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
 1292:  		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
 1293:  	}
 1294:  
 1295:  	/* itoa (hexdecimal) */
 1296:  	i = 7;
 1297:  	do {
 1298:  		c = (seq % 16) + '0';
 1299:  		if (c > '9') c += 7;
 1300:  		ns[i--] = c;
 1301:  		seq /= 16;
 1302:  	} while (seq);
 1303:  	ns[i] = '~';
 1304:  
 1305:  	/* Append the number */
 1306:  	for (j = 0; j < i && dst[j] != ' '; j++) {
 1307:  		if (IsDBCS1(dst[j])) {
 1308:  			if (j == i - 1) break;
 1309:  			j++;
 1310:  		}
 1311:  	}
 1312:  	do {
 1313:  		dst[j++] = (i < 8) ? ns[i++] : ' ';
 1314:  	} while (j < 8);
 1315:  }
 1316:  #endif
 1317:  
 1318:  
 1319:  
 1320:  
 1321:  /*-----------------------------------------------------------------------*/
 1322:  /* Calculate sum of an SFN                                               */
 1323:  /*-----------------------------------------------------------------------*/
 1324:  #if _USE_LFN
 1325:  static
 1326:  BYTE sum_sfn (
 1327:  	const BYTE *dir		/* Ptr to directory entry */
 1328:  )
 1329:  {
 1330:  	BYTE sum = 0;
 1331:  	UINT n = 11;
 1332:  
 1333:  	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
 1334:  	return sum;
 1335:  }
 1336:  #endif
 1337:  
 1338:  
 1339:  
 1340:  
 1341:  /*-----------------------------------------------------------------------*/
 1342:  /* Directory handling - Find an object in the directory                  */
 1343:  /*-----------------------------------------------------------------------*/
 1344:  
 1345:  static
 1346:  FRESULT dir_find (
 1347:  	DIR *dj			/* Pointer to the directory object linked to the file name */
 1348:  )
 1349:  {
*** EVALUATION ***

Function: dir_find
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6caa         [2]     STD   6,-SP
 1350:  	FRESULT res;
 1351:  	BYTE c, *dir;
 1352:  #if _USE_LFN
 1353:  	BYTE a, ord, sum;
 1354:  #endif
 1355:  
 1356:  	res = dir_sdi(dj, 0);			/* Rewind directory object */
  0002 3b           [2]     PSHD  
  0003 c7           [1]     CLRB  
  0004 87           [1]     CLRA  
  0005 160000       [4]     JSR   dir_sdi
  0008 1b82         [2]     LEAS  2,SP
 1357:  	if (res != FR_OK) return res;
  000a 044402       [3]     TBEQ  D,*+5 ;abs = 000f
  000d 2049         [3]     BRA   *+75 ;abs = 0058
 1358:  
 1359:  #if _USE_LFN
 1360:  	ord = sum = 0xFF;
 1361:  #endif
 1362:  	do {
 1363:  		res = move_window(dj->fs, dj->sect);
  000f ee80         [3]     LDX   0,SP
  0011 ec00         [3]     LDD   0,X
  0013 3b           [2]     PSHD  
  0014 ece010       [3]     LDD   16,X
  0017 ee0e         [3]     LDX   14,X
  0019 160000       [4]     JSR   move_window
  001c 1b82         [2]     LEAS  2,SP
  001e 6c82         [2]     STD   2,SP
 1364:  		if (res != FR_OK) break;
  0020 2634         [3/1]   BNE   *+54 ;abs = 0056
 1365:  		dir = dj->dir;					/* Ptr to the directory entry of current index */
  0022 ee80         [3]     LDX   0,SP
  0024 ede012       [3]     LDY   18,X
  0027 6d84         [2]     STY   4,SP
 1366:  		c = dir[DIR_Name];
  0029 e640         [3]     LDAB  0,Y
 1367:  		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  002b 2607         [3/1]   BNE   *+9 ;abs = 0034
  002d c604         [1]     LDAB  #4
  002f 87           [1]     CLRA  
  0030 6c82         [2]     STD   2,SP
  0032 2022         [3]     BRA   *+36 ;abs = 0056
 1368:  #if _USE_LFN	/* LFN configuration */
 1369:  		a = dir[DIR_Attr] & AM_MASK;
 1370:  		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 1371:  			ord = 0xFF;
 1372:  		} else {
 1373:  			if (a == AM_LFN) {			/* An LFN entry is found */
 1374:  				if (dj->lfn) {
 1375:  					if (c & LLE) {		/* Is it start of LFN sequence? */
 1376:  						sum = dir[LDIR_Chksum];
 1377:  						c &= ~LLE; ord = c;	/* LFN start order */
 1378:  						dj->lfn_idx = dj->index;
 1379:  					}
 1380:  					/* Check validity of the LFN entry and compare it with given name */
 1381:  					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 1382:  				}
 1383:  			} else {					/* An SFN entry is found */
 1384:  				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
 1385:  				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
 1386:  				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
 1387:  			}
 1388:  		}
 1389:  #else		/* Non LFN configuration */
 1390:  		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
  0034 0e4b0810     [4]     BRSET 11,Y,#8,*+20 ;abs = 0048
  0038 35           [2]     PSHY  
  0039 ece014       [3]     LDD   20,X
  003c 3b           [2]     PSHD  
  003d c60b         [1]     LDAB  #11
  003f 87           [1]     CLRA  
  0040 160000       [4]     JSR   mem_cmp
  0043 1b84         [2]     LEAS  4,SP
  0045 04440e       [3]     TBEQ  D,*+17 ;abs = 0056
 1391:  			break;
 1392:  #endif
 1393:  		res = dir_next(dj, 0);		/* Next entry */
  0048 ec80         [3]     LDD   0,SP
  004a 3b           [2]     PSHD  
  004b c7           [1]     CLRB  
  004c 87           [1]     CLRA  
  004d 160000       [4]     JSR   dir_next
  0050 1b82         [2]     LEAS  2,SP
  0052 6c82         [2]     STD   2,SP
 1394:  	} while (res == FR_OK);
  0054 27b9         [3/1]   BEQ   *-69 ;abs = 000f
 1395:  
 1396:  	return res;
  0056 ec82         [3]     LDD   2,SP
 1397:  }
  0058 1b86         [2]     LEAS  6,SP
  005a 3d           [5]     RTS   
 1398:  
 1399:  
 1400:  
 1401:  
 1402:  /*-----------------------------------------------------------------------*/
 1403:  /* Read an object from the directory                                     */
 1404:  /*-----------------------------------------------------------------------*/
 1405:  #if _FS_MINIMIZE <= 1
 1406:  static
 1407:  FRESULT dir_read (
 1408:  	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
 1409:  )
 1410:  {
*** EVALUATION ***

Function: dir_read
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca9         [2]     STD   7,-SP
 1411:  	FRESULT res;
 1412:  	BYTE c, *dir;
 1413:  #if _USE_LFN
 1414:  	BYTE a, ord = 0xFF, sum = 0xFF;
 1415:  #endif
 1416:  
 1417:  	res = FR_NO_FILE;
  0002 c604         [1]     LDAB  #4
  0004 87           [1]     CLRA  
  0005 6c82         [2]     STD   2,SP
 1418:  	while (dj->sect) {
  0007 203f         [3]     BRA   *+65 ;abs = 0048
 1419:  		res = move_window(dj->fs, dj->sect);
  0009 ee80         [3]     LDX   0,SP
  000b ec00         [3]     LDD   0,X
  000d 3b           [2]     PSHD  
  000e ece010       [3]     LDD   16,X
  0011 ee0e         [3]     LDX   14,X
  0013 160000       [4]     JSR   move_window
  0016 1b82         [2]     LEAS  2,SP
  0018 6c82         [2]     STD   2,SP
 1420:  		if (res != FR_OK) break;
  001a 2637         [3/1]   BNE   *+57 ;abs = 0053
 1421:  		dir = dj->dir;					/* Ptr to the directory entry of current index */
  001c ee80         [3]     LDX   0,SP
  001e ede012       [3]     LDY   18,X
  0021 6d85         [2]     STY   5,SP
 1422:  		c = dir[DIR_Name];
  0023 e640         [3]     LDAB  0,Y
  0025 6b84         [2]     STAB  4,SP
 1423:  		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  0027 2607         [3/1]   BNE   *+9 ;abs = 0030
  0029 c604         [1]     LDAB  #4
  002b 87           [1]     CLRA  
  002c 6c82         [2]     STD   2,SP
  002e 2027         [3]     BRA   *+41 ;abs = 0057
 1424:  #if _USE_LFN	/* LFN configuration */
 1425:  		a = dir[DIR_Attr] & AM_MASK;
 1426:  		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 1427:  			ord = 0xFF;
 1428:  		} else {
 1429:  			if (a == AM_LFN) {			/* An LFN entry is found */
 1430:  				if (c & LLE) {			/* Is it start of LFN sequence? */
 1431:  					sum = dir[LDIR_Chksum];
 1432:  					c &= ~LLE; ord = c;
 1433:  					dj->lfn_idx = dj->index;
 1434:  				}
 1435:  				/* Check LFN validity and capture it */
 1436:  				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
 1437:  			} else {					/* An SFN entry is found */
 1438:  				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
 1439:  					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
 1440:  				break;
 1441:  			}
 1442:  		}
 1443:  #else		/* Non LFN configuration */
 1444:  		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
  0030 c1e5         [1]     CMPB  #229
  0032 2708         [3/1]   BEQ   *+10 ;abs = 003c
  0034 c12e         [1]     CMPB  #46
  0036 2704         [3/1]   BEQ   *+6 ;abs = 003c
  0038 0f4b0817     [4]     BRCLR 11,Y,#8,*+27 ;abs = 0053
 1445:  			break;
 1446:  #endif
 1447:  		res = dir_next(dj, 0);				/* Next entry */
  003c 34           [2]     PSHX  
  003d c7           [1]     CLRB  
  003e 87           [1]     CLRA  
  003f 160000       [4]     JSR   dir_next
  0042 1b82         [2]     LEAS  2,SP
  0044 6c82         [2]     STD   2,SP
 1448:  		if (res != FR_OK) break;
  0046 260b         [3/1]   BNE   *+13 ;abs = 0053
  0048 ee80         [3]     LDX   0,SP
  004a ece010       [3]     LDD   16,X
  004d 26ba         [3/1]   BNE   *-68 ;abs = 0009
  004f ec0e         [3]     LDD   14,X
  0051 26b6         [3/1]   BNE   *-72 ;abs = 0009
 1449:  	}
 1450:  
 1451:  	if (res != FR_OK) dj->sect = 0;
  0053 ec82         [3]     LDD   2,SP
  0055 2709         [3/1]   BEQ   *+11 ;abs = 0060
  0057 ee80         [3]     LDX   0,SP
  0059 c7           [1]     CLRB  
  005a 87           [1]     CLRA  
  005b 6c0e         [2]     STD   14,X
  005d 6ce010       [3]     STD   16,X
 1452:  
 1453:  	return res;
  0060 ec82         [3]     LDD   2,SP
 1454:  }
  0062 1b87         [2]     LEAS  7,SP
  0064 3d           [5]     RTS   
 1455:  #endif
 1456:  
 1457:  
 1458:  
 1459:  /*-----------------------------------------------------------------------*/
 1460:  /* Register an object to the directory                                   */
 1461:  /*-----------------------------------------------------------------------*/
 1462:  #if !_FS_READONLY
 1463:  static
 1464:  FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
 1465:  	DIR *dj				/* Target directory with object name to be created */
 1466:  )
 1467:  {
*** EVALUATION ***

Function: dir_register
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
 1468:  	FRESULT res;
 1469:  	BYTE c, *dir;
 1470:  #if _USE_LFN	/* LFN configuration */
 1471:  	WORD n, ne, is;
 1472:  	BYTE sn[12], *fn, sum;
 1473:  	WCHAR *lfn;
 1474:  
 1475:  
 1476:  	fn = dj->fn; lfn = dj->lfn;
 1477:  	mem_cpy(sn, fn, 12);
 1478:  
 1479:  	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
 1480:  		return FR_INVALID_NAME;
 1481:  
 1482:  	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 1483:  		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
 1484:  		for (n = 1; n < 100; n++) {
 1485:  			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
 1486:  			res = dir_find(dj);				/* Check if the name collides with existing SFN */
 1487:  			if (res != FR_OK) break;
 1488:  		}
 1489:  		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 1490:  		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 1491:  		fn[NS] = sn[NS]; dj->lfn = lfn;
 1492:  	}
 1493:  
 1494:  	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
 1495:  		for (ne = 0; lfn[ne]; ne++) ;
 1496:  		ne = (ne + 25) / 13;
 1497:  	} else {						/* Otherwise reserve only an SFN entry. */
 1498:  		ne = 1;
 1499:  	}
 1500:  
 1501:  	/* Reserve contiguous entries */
 1502:  	res = dir_sdi(dj, 0);
 1503:  	if (res != FR_OK) return res;
 1504:  	n = is = 0;
 1505:  	do {
 1506:  		res = move_window(dj->fs, dj->sect);
 1507:  		if (res != FR_OK) break;
 1508:  		c = *dj->dir;				/* Check the entry status */
 1509:  		if (c == DDE || c == 0) {	/* Is it a blank entry? */
 1510:  			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
 1511:  			if (++n == ne) break;	/* A contiguous entry that required count is found */
 1512:  		} else {
 1513:  			n = 0;					/* Not a blank entry. Restart to search */
 1514:  		}
 1515:  		res = dir_next(dj, 1);		/* Next entry with table stretch */
 1516:  	} while (res == FR_OK);
 1517:  
 1518:  	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
 1519:  		res = dir_sdi(dj, is);
 1520:  		if (res == FR_OK) {
 1521:  			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
 1522:  			ne--;
 1523:  			do {					/* Store LFN entries in bottom first */
 1524:  				res = move_window(dj->fs, dj->sect);
 1525:  				if (res != FR_OK) break;
 1526:  				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
 1527:  				dj->fs->wflag = 1;
 1528:  				res = dir_next(dj, 0);	/* Next entry */
 1529:  			} while (res == FR_OK && --ne);
 1530:  		}
 1531:  	}
 1532:  
 1533:  #else	/* Non LFN configuration */
 1534:  	res = dir_sdi(dj, 0);
  0002 6cac         [2]     STD   4,-SP
  0004 c7           [1]     CLRB  
  0005 87           [1]     CLRA  
  0006 160000       [4]     JSR   dir_sdi
  0009 1b82         [2]     LEAS  2,SP
  000b 6c84         [2]     STD   4,SP
 1535:  	if (res == FR_OK) {
  000d 261f         [3/1]   BNE   *+33 ;abs = 002e
 1536:  		do {	/* Find a blank entry for the SFN */
 1537:  			res = move_window(dj->fs, dj->sect);
  000f 0753         [4]     BSR   *+85 ;abs = 0064
 1538:  			if (res != FR_OK) break;
  0011 261b         [3/1]   BNE   *+29 ;abs = 002e
 1539:  			c = *dj->dir;
  0013 ee82         [3]     LDX   2,SP
  0015 ede012       [3]     LDY   18,X
  0018 e640         [3]     LDAB  0,Y
 1540:  			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
  001a c1e5         [1]     CMPB  #229
  001c 2710         [3/1]   BEQ   *+18 ;abs = 002e
  001e 04410d       [3]     TBEQ  B,*+16 ;abs = 002e
 1541:  			res = dir_next(dj, 1);			/* Next entry with table stretch */
  0021 34           [2]     PSHX  
  0022 c601         [1]     LDAB  #1
  0024 87           [1]     CLRA  
  0025 160000       [4]     JSR   dir_next
  0028 1b82         [2]     LEAS  2,SP
  002a 6c84         [2]     STD   4,SP
 1542:  		} while (res == FR_OK);
  002c 27e1         [3/1]   BEQ   *-29 ;abs = 000f
 1543:  	}
 1544:  #endif
 1545:  
 1546:  	if (res == FR_OK) {		/* Initialize the SFN entry */
  002e ec84         [3]     LDD   4,SP
  0030 262d         [3/1]   BNE   *+47 ;abs = 005f
 1547:  		res = move_window(dj->fs, dj->sect);
  0032 0730         [4]     BSR   *+50 ;abs = 0064
 1548:  		if (res == FR_OK) {
  0034 2629         [3/1]   BNE   *+43 ;abs = 005f
 1549:  			dir = dj->dir;
  0036 ee82         [3]     LDX   2,SP
  0038 ece012       [3]     LDD   18,X
 1550:  			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
  003b 3b           [2]     PSHD  
  003c 6c82         [2]     STD   2,SP
  003e c7           [1]     CLRB  
  003f 87           [1]     CLRA  
  0040 3b           [2]     PSHD  
  0041 c620         [1]     LDAB  #32
  0043 160000       [4]     JSR   mem_set
 1551:  			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  0046 eca3         [3]     LDD   4,+SP
  0048 3b           [2]     PSHD  
  0049 ee84         [3]     LDX   4,SP
  004b ece014       [3]     LDD   20,X
  004e 3b           [2]     PSHD  
  004f c60b         [1]     LDAB  #11
  0051 87           [1]     CLRA  
  0052 160000       [4]     JSR   mem_cpy
  0055 1b84         [2]     LEAS  4,SP
 1552:  #if _USE_LFN
 1553:  			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
 1554:  #endif
 1555:  			dj->fs->wflag = 1;
  0057 ee82         [3]     LDX   2,SP
  0059 ed00         [3]     LDY   0,X
  005b c601         [1]     LDAB  #1
  005d 6b44         [2]     STAB  4,Y
 1556:  		}
 1557:  	}
 1558:  
 1559:  	return res;
  005f ec84         [3]     LDD   4,SP
 1560:  }
  0061 1b86         [2]     LEAS  6,SP
  0063 3d           [5]     RTS   
  0064 ee84         [3]     LDX   4,SP
  0066 ec00         [3]     LDD   0,X
  0068 3b           [2]     PSHD  
  0069 ece010       [3]     LDD   16,X
  006c ee0e         [3]     LDX   14,X
  006e 160000       [4]     JSR   move_window
  0071 1b82         [2]     LEAS  2,SP
  0073 6c86         [2]     STD   6,SP
  0075 3d           [5]     RTS   
 1561:  #endif /* !_FS_READONLY */
 1562:  
 1563:  
 1564:  
 1565:  
 1566:  /*-----------------------------------------------------------------------*/
 1567:  /* Remove an object from the directory                                   */
 1568:  /*-----------------------------------------------------------------------*/
 1569:  #if !_FS_READONLY && !_FS_MINIMIZE
 1570:  static
 1571:  FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
 1572:  	DIR *dj				/* Directory object pointing the entry to be removed */
 1573:  )
 1574:  {
*** EVALUATION ***

Function: dir_remove
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
 1575:  	FRESULT res;
 1576:  #if _USE_LFN	/* LFN configuration */
 1577:  	WORD i;
 1578:  
 1579:  	i = dj->index;	/* SFN index */
 1580:  	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
 1581:  	if (res == FR_OK) {
 1582:  		do {
 1583:  			res = move_window(dj->fs, dj->sect);
 1584:  			if (res != FR_OK) break;
 1585:  			*dj->dir = DDE;			/* Mark the entry "deleted" */
 1586:  			dj->fs->wflag = 1;
 1587:  			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
 1588:  			res = dir_next(dj, 0);		/* Next entry */
 1589:  		} while (res == FR_OK);
 1590:  		if (res == FR_NO_FILE) res = FR_INT_ERR;
 1591:  	}
 1592:  
 1593:  #else			/* Non LFN configuration */
 1594:  	res = dir_sdi(dj, dj->index);
  0002 3b           [2]     PSHD  
  0003 b745         [1]     TFR   D,X
  0005 ec04         [3]     LDD   4,X
  0007 160000       [4]     JSR   dir_sdi
  000a 1b82         [2]     LEAS  2,SP
  000c 6c82         [2]     STD   2,SP
 1595:  	if (res == FR_OK) {
  000e 2621         [3/1]   BNE   *+35 ;abs = 0031
 1596:  		res = move_window(dj->fs, dj->sect);
  0010 ee80         [3]     LDX   0,SP
  0012 ec00         [3]     LDD   0,X
  0014 3b           [2]     PSHD  
  0015 ece010       [3]     LDD   16,X
  0018 ee0e         [3]     LDX   14,X
  001a 160000       [4]     JSR   move_window
  001d 1b82         [2]     LEAS  2,SP
  001f 6c82         [2]     STD   2,SP
 1597:  		if (res == FR_OK) {
  0021 260e         [3/1]   BNE   *+16 ;abs = 0031
 1598:  			*dj->dir = DDE;			/* Mark the entry "deleted" */
  0023 ee80         [3]     LDX   0,SP
  0025 ede012       [3]     LDY   18,X
  0028 cc01e5       [2]     LDD   #485
  002b 6b40         [2]     STAB  0,Y
 1599:  			dj->fs->wflag = 1;
  002d ed00         [3]     LDY   0,X
  002f 6a44         [2]     STAA  4,Y
 1600:  		}
 1601:  	}
 1602:  #endif
 1603:  
 1604:  	return res;
  0031 ec82         [3]     LDD   2,SP
 1605:  }
  0033 1b84         [2]     LEAS  4,SP
  0035 3d           [5]     RTS   
 1606:  #endif /* !_FS_READONLY */
 1607:  
 1608:  
 1609:  
 1610:  
 1611:  /*-----------------------------------------------------------------------*/
 1612:  /* Pick a segment and create the object name in directory form           */
 1613:  /*-----------------------------------------------------------------------*/
 1614:  
 1615:  static
 1616:  FRESULT create_name (
 1617:  	DIR *dj,			/* Pointer to the directory object */
 1618:  	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
 1619:  )
 1620:  {
*** EVALUATION ***

Function: create_name
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b94         [2]     LEAS  -12,SP
  0002 3b           [2]     PSHD  
 1621:  #ifdef _EXCVT
 1622:  	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
 1623:  #endif
 1624:  
 1625:  #if _USE_LFN	/* LFN configuration */
 1626:  	BYTE b, cf;
 1627:  	WCHAR w, *lfn;
 1628:  	UINT i, ni, si, di;
 1629:  	const TCHAR *p;
 1630:  
 1631:  	/* Create LFN in Unicode */
 1632:  	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 1633:  	lfn = dj->lfn;
 1634:  	si = di = 0;
 1635:  	for (;;) {
 1636:  		w = p[si++];					/* Get a character */
 1637:  		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
 1638:  		if (di >= _MAX_LFN)				/* Reject too long name */
 1639:  			return FR_INVALID_NAME;
 1640:  #if !_LFN_UNICODE
 1641:  		w &= 0xFF;
 1642:  		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 1643:  			b = (BYTE)p[si++];			/* Get 2nd byte */
 1644:  			if (!IsDBCS2(b))
 1645:  				return FR_INVALID_NAME;	/* Reject invalid sequence */
 1646:  			w = (w << 8) + b;			/* Create a DBC */
 1647:  		}
 1648:  		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 1649:  		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 1650:  #endif
 1651:  		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
 1652:  			return FR_INVALID_NAME;
 1653:  		lfn[di++] = w;					/* Store the Unicode char */
 1654:  	}
 1655:  	*path = &p[si];						/* Return pointer to the next segment */
 1656:  	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 1657:  #if _FS_RPATH
 1658:  	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
 1659:  		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
 1660:  		lfn[di] = 0;
 1661:  		for (i = 0; i < 11; i++)
 1662:  			dj->fn[i] = (i < di) ? '.' : ' ';
 1663:  		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
 1664:  		return FR_OK;
 1665:  	}
 1666:  #endif
 1667:  	while (di) {						/* Strip trailing spaces and dots */
 1668:  		w = lfn[di-1];
 1669:  		if (w != ' ' && w != '.') break;
 1670:  		di--;
 1671:  	}
 1672:  	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
 1673:  
 1674:  	lfn[di] = 0;						/* LFN is created */
 1675:  
 1676:  	/* Create SFN in directory form */
 1677:  	mem_set(dj->fn, ' ', 11);
 1678:  	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 1679:  	if (si) cf |= NS_LOSS | NS_LFN;
 1680:  	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 1681:  
 1682:  	b = i = 0; ni = 8;
 1683:  	for (;;) {
 1684:  		w = lfn[si++];					/* Get an LFN char */
 1685:  		if (!w) break;					/* Break on end of the LFN */
 1686:  		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 1687:  			cf |= NS_LOSS | NS_LFN; continue;
 1688:  		}
 1689:  
 1690:  		if (i >= ni || si == di) {		/* Extension or end of SFN */
 1691:  			if (ni == 11) {				/* Long extension */
 1692:  				cf |= NS_LOSS | NS_LFN; break;
 1693:  			}
 1694:  			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 1695:  			if (si > di) break;			/* No extension */
 1696:  			si = di; i = 8; ni = 11;	/* Enter extension section */
 1697:  			b <<= 2; continue;
 1698:  		}
 1699:  
 1700:  		if (w >= 0x80) {				/* Non ASCII char */
 1701:  #ifdef _EXCVT
 1702:  			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 1703:  			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
 1704:  #else
 1705:  			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
 1706:  #endif
 1707:  			cf |= NS_LFN;				/* Force create LFN entry */
 1708:  		}
 1709:  
 1710:  		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
 1711:  			if (i >= ni - 1) {
 1712:  				cf |= NS_LOSS | NS_LFN; i = ni; continue;
 1713:  			}
 1714:  			dj->fn[i++] = (BYTE)(w >> 8);
 1715:  		} else {						/* Single byte char */
 1716:  			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
 1717:  				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 1718:  			} else {
 1719:  				if (IsUpper(w)) {		/* ASCII large capital */
 1720:  					b |= 2;
 1721:  				} else {
 1722:  					if (IsLower(w)) {	/* ASCII small capital */
 1723:  						b |= 1; w -= 0x20;
 1724:  					}
 1725:  				}
 1726:  			}
 1727:  		}
 1728:  		dj->fn[i++] = (BYTE)w;
 1729:  	}
 1730:  
 1731:  	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
 1732:  
 1733:  	if (ni == 8) b <<= 2;
 1734:  	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
 1735:  		cf |= NS_LFN;
 1736:  	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
 1737:  		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 1738:  		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 1739:  	}
 1740:  
 1741:  	dj->fn[NS] = cf;	/* SFN is created */
 1742:  
 1743:  	return FR_OK;
 1744:  
 1745:  
 1746:  #else	/* Non-LFN configuration */
 1747:  	BYTE b, c, d, *sfn;
 1748:  	UINT ni, si, i;
 1749:  	const char *p;
 1750:  
 1751:  	/* Create file name in directory form */
 1752:  	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  0003 b745         [1]     TFR   D,X
  0005 ec00         [3]     LDD   0,X
  0007 6c86         [2]     STD   6,SP
  0009 2005         [3]     BRA   *+7 ;abs = 0010
  000b ee86         [3]     LDX   6,SP
  000d 08           [1]     INX   
  000e 6e86         [2]     STX   6,SP
  0010 ee86         [3]     LDX   6,SP
  0012 e600         [3]     LDAB  0,X
  0014 c12f         [1]     CMPB  #47
  0016 27f3         [3/1]   BEQ   *-11 ;abs = 000b
  0018 c15c         [1]     CMPB  #92
  001a 27ef         [3/1]   BEQ   *-15 ;abs = 000b
 1753:  	sfn = dj->fn;
  001c eef010       [3]     LDX   16,SP
  001f ece014       [3]     LDD   20,X
  0022 6c8c         [2]     STD   12,SP
 1754:  	mem_set(sfn, ' ', 11);
  0024 3b           [2]     PSHD  
  0025 c620         [1]     LDAB  #32
  0027 87           [1]     CLRA  
  0028 3b           [2]     PSHD  
  0029 c60b         [1]     LDAB  #11
  002b 160000       [4]     JSR   mem_set
  002e 1b84         [2]     LEAS  4,SP
 1755:  	si = i = b = 0; ni = 8;
  0030 6983         [2]     CLR   3,SP
  0032 c7           [1]     CLRB  
  0033 87           [1]     CLRA  
  0034 6c84         [2]     STD   4,SP
  0036 6c8a         [2]     STD   10,SP
  0038 c608         [1]     LDAB  #8
  003a 6c88         [2]     STD   8,SP
 1756:  #if _FS_RPATH
 1757:  	if (p[si] == '.') { /* Is this a dot entry? */
 1758:  		for (;;) {
 1759:  			c = (BYTE)p[si++];
 1760:  			if (c != '.' || si >= 3) break;
 1761:  			sfn[i++] = c;
 1762:  		}
 1763:  		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 1764:  		*path = &p[si];									/* Return pointer to the next segment */
 1765:  		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 1766:  		return FR_OK;
 1767:  	}
 1768:  #endif
 1769:  	for (;;) {
 1770:  		c = (BYTE)p[si++];
  003c ee8a         [3]     LDX   10,SP
  003e 1901         [2]     LEAY  1,X
  0040 6d8a         [2]     STY   10,SP
  0042 b754         [1]     TFR   X,D
  0044 e386         [3]     ADDD  6,SP
  0046 b745         [1]     TFR   D,X
  0048 e600         [3]     LDAB  0,X
  004a 6b82         [2]     STAB  2,SP
 1771:  		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
  004c c120         [1]     CMPB  #32
  004e 237b         [3/1]   BLS   *+125 ;abs = 00cb
  0050 c12f         [1]     CMPB  #47
  0052 2702         [3/1]   BEQ   *+4 ;abs = 0056
  0054 c15c         [1]     CMPB  #92
  0056 2773         [3/1]   BEQ   *+117 ;abs = 00cb
 1772:  		if (c == '.' || i >= ni) {
  0058 c12e         [1]     CMPB  #46
  005a 2706         [3/1]   BEQ   *+8 ;abs = 0062
  005c ee84         [3]     LDX   4,SP
  005e ae88         [3]     CPX   8,SP
  0060 251c         [3/1]   BCS   *+30 ;abs = 007e
 1773:  			if (ni != 8 || c != '.') return FR_INVALID_NAME;
  0062 ec88         [3]     LDD   8,SP
  0064 8c0008       [2]     CPD   #8
  0067 2604         [3/1]   BNE   *+6 ;abs = 006d
  0069 e682         [3]     LDAB  2,SP
  006b c12e         [1]     CMPB  #46
  006d 2674         [3/1]   BNE   *+118 ;abs = 00e3
 1774:  			i = 8; ni = 11;
  006f c608         [1]     LDAB  #8
  0071 87           [1]     CLRA  
  0072 6c84         [2]     STD   4,SP
  0074 c60b         [1]     LDAB  #11
  0076 6c88         [2]     STD   8,SP
 1775:  			b <<= 2; continue;
  0078 6883         [3]     LSL   3,SP
  007a 6883         [3]     LSL   3,SP
  007c 20be         [3]     BRA   *-64 ;abs = 003c
 1776:  		}
 1777:  		if (c >= 0x80) {				/* Extended char? */
  007e c180         [1]     CMPB  #128
  0080 250a         [3/1]   BCS   *+12 ;abs = 008c
 1778:  			b |= 3;						/* Eliminate NT flag */
  0082 0c8303       [4]     BSET  3,SP,#3
 1779:  #ifdef _EXCVT
 1780:  			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
  0085 ce0000       [2]     LDX   #excvt:65408
  0088 a6e5         [3]     LDAA  B,X
  008a 6a82         [2]     STAA  2,SP
 1781:  #else
 1782:  #if !_DF1S	/* ASCII only cfg */
 1783:  			return FR_INVALID_NAME;
 1784:  #endif
 1785:  #endif
 1786:  		}
 1787:  		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 1788:  			d = (BYTE)p[si++];			/* Get 2nd byte */
 1789:  			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 1790:  				return FR_INVALID_NAME;
 1791:  			sfn[i++] = c;
 1792:  			sfn[i++] = d;
 1793:  		} else {						/* Single byte code */
 1794:  			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
  008c cc0000       [2]     LDD   #""*+,:;<=>?[]|"
  008f 3b           [2]     PSHD  
  0090 e684         [3]     LDAB  4,SP
  0092 87           [1]     CLRA  
  0093 160000       [4]     JSR   chk_chr
  0096 1b82         [2]     LEAS  2,SP
  0098 046448       [3]     TBNE  D,*+75 ;abs = 00e3
 1795:  				return FR_INVALID_NAME;
 1796:  			if (IsUpper(c)) {			/* ASCII large capital? */
  009b e682         [3]     LDAB  2,SP
  009d c041         [1]     SUBB  #65
  009f c119         [1]     CMPB  #25
  00a1 2205         [3/1]   BHI   *+7 ;abs = 00a8
 1797:  				b |= 2;
  00a3 0c8302       [4]     BSET  3,SP,#2
 1798:  			} else {
  00a6 2011         [3]     BRA   *+19 ;abs = 00b9
 1799:  				if (IsLower(c)) {		/* ASCII small capital? */
  00a8 e682         [3]     LDAB  2,SP
  00aa c061         [1]     SUBB  #97
  00ac c119         [1]     CMPB  #25
  00ae 2209         [3/1]   BHI   *+11 ;abs = 00b9
 1800:  					b |= 1; c -= 0x20;
  00b0 0c8301       [4]     BSET  3,SP,#1
  00b3 e682         [3]     LDAB  2,SP
  00b5 c020         [1]     SUBB  #32
  00b7 6b82         [2]     STAB  2,SP
 1801:  				}
 1802:  			}
 1803:  			sfn[i++] = c;
  00b9 ee84         [3]     LDX   4,SP
  00bb 1901         [2]     LEAY  1,X
  00bd 6d84         [2]     STY   4,SP
  00bf b754         [1]     TFR   X,D
  00c1 e38c         [3]     ADDD  12,SP
  00c3 b745         [1]     TFR   D,X
  00c5 e682         [3]     LDAB  2,SP
  00c7 6b00         [2]     STAB  0,X
  00c9 20b1         [3]     BRA   *-77 ;abs = 007c
 1804:  		}
 1805:  	}
 1806:  	*path = &p[si];						/* Return pointer to the next segment */
  00cb ec86         [3]     LDD   6,SP
  00cd e38a         [3]     ADDD  10,SP
  00cf ee80         [3]     LDX   0,SP
  00d1 6c00         [2]     STD   0,X
 1807:  	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  00d3 e682         [3]     LDAB  2,SP
  00d5 c120         [1]     CMPB  #32
  00d7 2302         [3/1]   BLS   *+4 ;abs = 00db
  00d9 c7           [1]     CLRB  
  00da 8f           [2]     SKIP2 
  00db c604         [1]     LDAB  #4
  00dd 6b82         [2]     STAB  2,SP
 1808:  
 1809:  	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
  00df ec84         [3]     LDD   4,SP
  00e1 2604         [3/1]   BNE   *+6 ;abs = 00e7
  00e3 c606         [1]     LDAB  #6
  00e5 2031         [3]     BRA   *+51 ;abs = 0118
 1810:  	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
  00e7 ee8c         [3]     LDX   12,SP
  00e9 e600         [3]     LDAB  0,X
  00eb c1e5         [1]     CMPB  #229
  00ed 2604         [3/1]   BNE   *+6 ;abs = 00f3
  00ef c605         [1]     LDAB  #5
  00f1 6b00         [2]     STAB  0,X
 1811:  
 1812:  	if (ni == 8) b <<= 2;
  00f3 ec88         [3]     LDD   8,SP
  00f5 8c0008       [2]     CPD   #8
  00f8 2604         [3/1]   BNE   *+6 ;abs = 00fe
  00fa 6883         [3]     LSL   3,SP
  00fc 6883         [3]     LSL   3,SP
 1813:  	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
  00fe e683         [3]     LDAB  3,SP
  0100 c403         [1]     ANDB  #3
  0102 042103       [3]     DBNE  B,*+6 ;abs = 0108
  0105 0c8210       [4]     BSET  2,SP,#16
 1814:  	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
  0108 e683         [3]     LDAB  3,SP
  010a c40c         [1]     ANDB  #12
  010c c104         [1]     CMPB  #4
  010e 2603         [3/1]   BNE   *+5 ;abs = 0113
  0110 0c8208       [4]     BSET  2,SP,#8
 1815:  
 1816:  	sfn[NS] = c;		/* Store NT flag, File name is created */
  0113 e682         [3]     LDAB  2,SP
  0115 6b0b         [2]     STAB  11,X
 1817:  
 1818:  	return FR_OK;
  0117 c7           [1]     CLRB  
  0118 87           [1]     CLRA  
 1819:  #endif
 1820:  }
  0119 1b8e         [2]     LEAS  14,SP
  011b 3d           [5]     RTS   
 1821:  
 1822:  
 1823:  
 1824:  
 1825:  /*-----------------------------------------------------------------------*/
 1826:  /* Get file information from directory entry                             */
 1827:  /*-----------------------------------------------------------------------*/
 1828:  #if _FS_MINIMIZE <= 1
 1829:  static
 1830:  void get_fileinfo (		/* No return code */
 1831:  	DIR *dj,			/* Pointer to the directory object */
 1832:  	FILINFO *fno	 	/* Pointer to the file information to be filled */
 1833:  )
 1834:  {
*** EVALUATION ***

Function: get_fileinfo
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b99         [2]     LEAS  -7,SP
  0002 3b           [2]     PSHD  
 1835:  	UINT i;
 1836:  	BYTE nt, *dir;
 1837:  	TCHAR *p, c;
 1838:  
 1839:  
 1840:  	p = fno->fname;
  0003 c30009       [2]     ADDD  #9
  0006 6c84         [2]     STD   4,SP
 1841:  	if (dj->sect) {
  0008 ee8b         [3]     LDX   11,SP
  000a ece010       [3]     LDD   16,X
  000d 2606         [3/1]   BNE   *+8 ;abs = 0015
  000f ec0e         [3]     LDD   14,X
  0011 182700b9     [4/3]   LBEQ  *+189 ;abs = 00ce
 1842:  		dir = dj->dir;
  0015 ece012       [3]     LDD   18,X
  0018 6c86         [2]     STD   6,SP
 1843:  		nt = dir[DIR_NTres];		/* NT flag */
 1844:  		for (i = 0; i < 8; i++) {	/* Copy name body */
  001a c7           [1]     CLRB  
  001b 87           [1]     CLRA  
  001c 6c82         [2]     STD   2,SP
 1845:  			c = dir[i];
  001e 160000       [4]     JSR   get_fileinfo:0x00d5
 1846:  			if (c == ' ') break;
  0021 2714         [3/1]   BEQ   *+22 ;abs = 0037
 1847:  			if (c == NDDE) c = (TCHAR)DDE;
  0023 c105         [1]     CMPB  #5
  0025 2604         [3/1]   BNE   *+6 ;abs = 002b
  0027 c6e5         [1]     LDAB  #229
  0029 6b88         [2]     STAB  8,SP
 1848:  			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
 1849:  #if _LFN_UNICODE
 1850:  			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
 1851:  				c = (c << 8) | dir[++i];
 1852:  			c = ff_convert(c, 1);
 1853:  			if (!c) c = '?';
 1854:  #endif
 1855:  			*p++ = c;
  002b ee84         [3]     LDX   4,SP
  002d e688         [3]     LDAB  8,SP
  002f 160000       [4]     JSR   get_fileinfo:0x00e2
  0032 8e0008       [2]     CPX   #8
  0035 25e7         [3/1]   BCS   *-23 ;abs = 001e
 1856:  		}
 1857:  		if (dir[8] != ' ') {		/* Copy name extension */
  0037 ee86         [3]     LDX   6,SP
  0039 e608         [3]     LDAB  8,X
  003b c120         [1]     CMPB  #32
  003d 271c         [3/1]   BEQ   *+30 ;abs = 005b
 1858:  			*p++ = '.';
  003f ee84         [3]     LDX   4,SP
  0041 c62e         [1]     LDAB  #46
  0043 6b30         [2]     STAB  1,X+
  0045 6e84         [2]     STX   4,SP
 1859:  			for (i = 8; i < 11; i++) {
  0047 c608         [1]     LDAB  #8
  0049 87           [1]     CLRA  
  004a 6c82         [2]     STD   2,SP
 1860:  				c = dir[i];
  004c 160000       [4]     JSR   get_fileinfo:0x00d5
 1861:  				if (c == ' ') break;
  004f 270a         [3/1]   BEQ   *+12 ;abs = 005b
 1862:  				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
 1863:  #if _LFN_UNICODE
 1864:  				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
 1865:  					c = (c << 8) | dir[++i];
 1866:  				c = ff_convert(c, 1);
 1867:  				if (!c) c = '?';
 1868:  #endif
 1869:  				*p++ = c;
  0051 ee84         [3]     LDX   4,SP
  0053 160000       [4]     JSR   get_fileinfo:0x00e2
  0056 8e000b       [2]     CPX   #11
  0059 25f1         [3/1]   BCS   *-13 ;abs = 004c
 1870:  			}
 1871:  		}
 1872:  		fno->fattrib = dir[DIR_Attr];				/* Attribute */
  005b ee86         [3]     LDX   6,SP
  005d e60b         [3]     LDAB  11,X
  005f ed80         [3]     LDY   0,SP
  0061 6b48         [2]     STAB  8,Y
 1873:  		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
  0063 19e01c       [2]     LEAY  28,X
  0066 e643         [3]     LDAB  3,Y
  0068 87           [1]     CLRA  
  0069 b781         [1]     EXG   A,B
  006b c7           [1]     CLRB  
  006c 3b           [2]     PSHD  
  006d e642         [3]     LDAB  2,Y
  006f 87           [1]     CLRA  
  0070 ce0000       [2]     LDX   #0
  0073 3b           [2]     PSHD  
  0074 b754         [1]     TFR   X,D
  0076 ca00         [1]     ORAB  #0
  0078 8a00         [1]     ORAA  #0
  007a 3b           [2]     PSHD  
  007b ec84         [3]     LDD   4,SP
  007d ea83         [3]     ORAB  3,SP
  007f aa82         [3]     ORAA  2,SP
  0081 6c82         [2]     STD   2,SP
  0083 e641         [3]     LDAB  1,Y
  0085 b710         [1]     TFR   B,A
  0087 c7           [1]     CLRB  
  0088 ea81         [3]     ORAB  1,SP
  008a aa80         [3]     ORAA  0,SP
  008c ed8c         [3]     LDY   12,SP
  008e 6c80         [2]     STD   0,SP
  0090 e6e81c       [3]     LDAB  28,Y
  0093 87           [1]     CLRA  
  0094 ea81         [3]     ORAB  1,SP
  0096 aa80         [3]     ORAA  0,SP
  0098 ee86         [3]     LDX   6,SP
  009a 6c02         [2]     STD   2,X
  009c ec82         [3]     LDD   2,SP
  009e 6c00         [2]     STD   0,X
 1874:  		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
  00a0 1ae818       [2]     LEAX  24,Y
  00a3 e601         [3]     LDAB  1,X
  00a5 b710         [1]     TFR   B,A
  00a7 c7           [1]     CLRB  
  00a8 6c82         [2]     STD   2,SP
  00aa e6e818       [3]     LDAB  24,Y
  00ad 87           [1]     CLRA  
  00ae ea83         [3]     ORAB  3,SP
  00b0 aa82         [3]     ORAA  2,SP
  00b2 ee86         [3]     LDX   6,SP
  00b4 6c04         [2]     STD   4,X
 1875:  		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
  00b6 1ae816       [2]     LEAX  22,Y
  00b9 e601         [3]     LDAB  1,X
  00bb b710         [1]     TFR   B,A
  00bd c7           [1]     CLRB  
  00be 6c82         [2]     STD   2,SP
  00c0 e6e816       [3]     LDAB  22,Y
  00c3 87           [1]     CLRA  
  00c4 ea83         [3]     ORAB  3,SP
  00c6 aa82         [3]     ORAA  2,SP
  00c8 ee86         [3]     LDX   6,SP
  00ca 6c06         [2]     STD   6,X
  00cc 1b86         [2]     LEAS  6,SP
 1876:  	}
 1877:  	*p = 0;		/* Terminate SFN str by a \0 */
  00ce ee84         [3]     LDX   4,SP
  00d0 6900         [2]     CLR   0,X
 1878:  
 1879:  #if _USE_LFN
 1880:  	if (fno->lfname && fno->lfsize) {
 1881:  		TCHAR *tp = fno->lfname;
 1882:  		WCHAR w, *lfn;
 1883:  
 1884:  		i = 0;
 1885:  		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
 1886:  			lfn = dj->lfn;
 1887:  			while ((w = *lfn++) != 0) {			/* Get an LFN char */
 1888:  #if !_LFN_UNICODE
 1889:  				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
 1890:  				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
 1891:  				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
 1892:  					tp[i++] = (TCHAR)(w >> 8);
 1893:  #endif
 1894:  				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
 1895:  				tp[i++] = (TCHAR)w;
 1896:  			}
 1897:  		}
 1898:  		tp[i] = 0;	/* Terminate the LFN str by a \0 */
 1899:  	}
 1900:  #endif
 1901:  }
  00d2 1b89         [2]     LEAS  9,SP
  00d4 3d           [5]     RTS   
  00d5 ec88         [3]     LDD   8,SP
  00d7 e384         [3]     ADDD  4,SP
  00d9 b745         [1]     TFR   D,X
  00db e600         [3]     LDAB  0,X
  00dd 6b8a         [2]     STAB  10,SP
  00df c120         [1]     CMPB  #32
  00e1 3d           [5]     RTS   
  00e2 6b30         [2]     STAB  1,X+
  00e4 6e86         [2]     STX   6,SP
  00e6 ee84         [3]     LDX   4,SP
  00e8 08           [1]     INX   
  00e9 6e84         [2]     STX   4,SP
  00eb 3d           [5]     RTS   
 1902:  #endif /* _FS_MINIMIZE <= 1 */
 1903:  
 1904:  
 1905:  
 1906:  
 1907:  /*-----------------------------------------------------------------------*/
 1908:  /* Follow a file path                                                    */
 1909:  /*-----------------------------------------------------------------------*/
 1910:  
 1911:  static
 1912:  FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 1913:  	DIR *dj,			/* Directory object to return last directory and found object */
 1914:  	const TCHAR *path	/* Full-path string to find a file or directory */
 1915:  )
 1916:  {
*** EVALUATION ***

Function: follow_path
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca9         [2]     STD   7,-SP
 1917:  	FRESULT res;
 1918:  	BYTE *dir, ns;
 1919:  
 1920:  
 1921:  #if _FS_RPATH
 1922:  	if (*path == '/' || *path == '\\') { /* There is a heading separator */
 1923:  		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 1924:  	} else {							/* No heading separator */
 1925:  		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
 1926:  	}
 1927:  #else
 1928:  	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  0002 b745         [1]     TFR   D,X
  0004 e600         [3]     LDAB  0,X
  0006 c12f         [1]     CMPB  #47
  0008 2704         [3/1]   BEQ   *+6 ;abs = 000e
  000a c15c         [1]     CMPB  #92
  000c 2603         [3/1]   BNE   *+5 ;abs = 0011
 1929:  		path++;
  000e 08           [1]     INX   
  000f 6e80         [2]     STX   0,SP
 1930:  	dj->sclust = 0;						/* Start from the root dir */
  0011 ee89         [3]     LDX   9,SP
  0013 c7           [1]     CLRB  
  0014 87           [1]     CLRA  
  0015 6c06         [2]     STD   6,X
  0017 6c08         [2]     STD   8,X
 1931:  #endif
 1932:  
 1933:  	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  0019 ee80         [3]     LDX   0,SP
  001b e600         [3]     LDAB  0,X
  001d c120         [1]     CMPB  #32
  001f 18240090     [4/3]   LBCC  *+148 ;abs = 00b3
 1934:  		res = dir_sdi(dj, 0);
  0023 ec89         [3]     LDD   9,SP
  0025 3b           [2]     PSHD  
  0026 c7           [1]     CLRB  
  0027 87           [1]     CLRA  
  0028 160000       [4]     JSR   dir_sdi
  002b 30           [3]     PULX  
  002c 6c82         [2]     STD   2,SP
 1935:  		dj->dir = 0;
  002e ee89         [3]     LDX   9,SP
  0030 c7           [1]     CLRB  
  0031 87           [1]     CLRA  
  0032 6ce012       [3]     STD   18,X
 1936:  
 1937:  	} else {							/* Follow path */
 1938:  		for (;;) {
 1939:  			res = create_name(dj, &path);	/* Get a segment */
 1940:  			if (res != FR_OK) break;
 1941:  			res = dir_find(dj);				/* Find it */
 1942:  			ns = *(dj->fn+NS);
 1943:  			if (res != FR_OK) {				/* Failed to find the object */
 1944:  				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
 1945:  				/* Object not found */
 1946:  				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
 1947:  					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
 1948:  					res = FR_OK;
 1949:  					if (!(ns & NS_LAST)) continue;
 1950:  				} else {							/* Could not find the object */
 1951:  					if (!(ns & NS_LAST)) res = FR_NO_PATH;
 1952:  				}
 1953:  				break;
 1954:  			}
 1955:  			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 1956:  			dir = dj->dir;						/* There is next segment. Follow the sub directory */
 1957:  			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 1958:  				res = FR_NO_PATH; break;
 1959:  			}
 1960:  			dj->sclust = LD_CLUST(dir);
 1961:  		}
 1962:  	}
 1963:  
 1964:  	return res;
  0035 ec82         [3]     LDD   2,SP
  0037 207c         [3]     BRA   *+126 ;abs = 00b5
  0039 ec89         [3]     LDD   9,SP
  003b 3b           [2]     PSHD  
  003c 1a82         [2]     LEAX  2,SP
  003e b754         [1]     TFR   X,D
  0040 160000       [4]     JSR   create_name
  0043 1b82         [2]     LEAS  2,SP
  0045 6c82         [2]     STD   2,SP
  0047 26ec         [3/1]   BNE   *-18 ;abs = 0035
  0049 ec89         [3]     LDD   9,SP
  004b 160000       [4]     JSR   dir_find
  004e 6c82         [2]     STD   2,SP
  0050 ee89         [3]     LDX   9,SP
  0052 ede014       [3]     LDY   20,X
  0055 e64b         [3]     LDAB  11,Y
  0057 6b84         [2]     STAB  4,SP
  0059 ec82         [3]     LDD   2,SP
  005b 2710         [3/1]   BEQ   *+18 ;abs = 006d
  005d 8c0004       [2]     CPD   #4
  0060 26d3         [3/1]   BNE   *-43 ;abs = 0035
  0062 0e8404cf     [4]     BRSET 4,SP,#4,*-45 ;abs = 0035
  0066 c605         [1]     LDAB  #5
  0068 87           [1]     CLRA  
  0069 6c82         [2]     STD   2,SP
  006b 20c8         [3]     BRA   *-54 ;abs = 0035
  006d 0e8404c4     [4]     BRSET 4,SP,#4,*-56 ;abs = 0035
  0071 ede012       [3]     LDY   18,X
  0074 6d85         [2]     STY   5,SP
  0076 0e4b1007     [4]     BRSET 11,Y,#16,*+11 ;abs = 0081
  007a c605         [1]     LDAB  #5
  007c 87           [1]     CLRA  
  007d 6c82         [2]     STD   2,SP
  007f 20b4         [3]     BRA   *-74 ;abs = 0035
  0081 1ae814       [2]     LEAX  20,Y
  0084 e601         [3]     LDAB  1,X
  0086 b710         [1]     TFR   B,A
  0088 c7           [1]     CLRB  
  0089 3b           [2]     PSHD  
  008a e6e814       [3]     LDAB  20,Y
  008d 87           [1]     CLRA  
  008e ea81         [3]     ORAB  1,SP
  0090 aa80         [3]     ORAA  0,SP
  0092 1ae81a       [2]     LEAX  26,Y
  0095 6c80         [2]     STD   0,SP
  0097 e601         [3]     LDAB  1,X
  0099 b710         [1]     TFR   B,A
  009b c7           [1]     CLRB  
  009c 3b           [2]     PSHD  
  009d e6e81a       [3]     LDAB  26,Y
  00a0 87           [1]     CLRA  
  00a1 ea81         [3]     ORAB  1,SP
  00a3 aa80         [3]     ORAA  0,SP
  00a5 ca00         [1]     ORAB  #0
  00a7 8a00         [1]     ORAA  #0
  00a9 ee8d         [3]     LDX   13,SP
  00ab 6c08         [2]     STD   8,X
  00ad ec82         [3]     LDD   2,SP
  00af 6c06         [2]     STD   6,X
  00b1 1b84         [2]     LEAS  4,SP
  00b3 2084         [3]     BRA   *-122 ;abs = 0039
 1965:  }
  00b5 1b87         [2]     LEAS  7,SP
  00b7 3d           [5]     RTS   
 1966:  
 1967:  
 1968:  
 1969:  
 1970:  /*-----------------------------------------------------------------------*/
 1971:  /* Load boot record and check if it is an FAT boot record                */
 1972:  /*-----------------------------------------------------------------------*/
 1973:  
 1974:  static
 1975:  BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
 1976:  	FATFS *fs,	/* File system object */
 1977:  	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
 1978:  )
 1979:  {
*** EVALUATION ***

Function: check_fs
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 3b           [2]     PSHD  
  0001 34           [2]     PSHX  
  0002 3b           [2]     PSHD  
 1980:  	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  0003 ee88         [3]     LDX   8,SP
  0005 e601         [3]     LDAB  1,X
  0007 37           [2]     PSHB  
  0008 19e02e       [2]     LEAY  46,X
  000b 35           [2]     PSHY  
  000c ec87         [3]     LDD   7,SP
  000e 3b           [2]     PSHD  
  000f ec87         [3]     LDD   7,SP
  0011 3b           [2]     PSHD  
  0012 c601         [1]     LDAB  #1
  0014 160000       [4]     JSR   eDisk_Read
  0017 1b87         [2]     LEAS  7,SP
  0019 044404       [3]     TBEQ  D,*+7 ;abs = 0020
 1981:  		return 3;
  001c c603         [1]     LDAB  #3
  001e 201c         [3]     BRA   *+30 ;abs = 003c
 1982:  	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  0020 ee88         [3]     LDX   8,SP
  0022 19e2022c     [2]     LEAY  556,X
  0026 e641         [3]     LDAB  1,Y
  0028 b710         [1]     TFR   B,A
  002a c7           [1]     CLRB  
  002b 3b           [2]     PSHD  
  002c e6e2022c     [4]     LDAB  556,X
  0030 87           [1]     CLRA  
  0031 ea81         [3]     ORAB  1,SP
  0033 aab1         [3]     ORAA  2,SP+
  0035 8caa55       [2]     CPD   #43605
  0038 2704         [3/1]   BEQ   *+6 ;abs = 003e
 1983:  		return 2;
  003a c602         [1]     LDAB  #2
  003c 206b         [3]     BRA   *+109 ;abs = 00a9
 1984:  
 1985:  	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  003e 19e064       [2]     LEAY  100,X
  0041 e643         [3]     LDAB  3,Y
  0043 87           [1]     CLRA  
  0044 b781         [1]     EXG   A,B
  0046 c7           [1]     CLRB  
  0047 3b           [2]     PSHD  
  0048 e642         [3]     LDAB  2,Y
  004a 87           [1]     CLRA  
  004b ce0000       [2]     LDX   #0
  004e 3b           [2]     PSHD  
  004f b754         [1]     TFR   X,D
  0051 ca00         [1]     ORAB  #0
  0053 8a00         [1]     ORAA  #0
  0055 3b           [2]     PSHD  
  0056 0754         [4]     BSR   *+86 ;abs = 00ac
  0058 e6e864       [3]     LDAB  100,Y
  005b 0766         [4]     BSR   *+104 ;abs = 00c3
  005d ce4146       [2]     LDX   #16710
  0060 34           [2]     PSHX  
  0061 6c88         [2]     STD   8,SP
  0063 c654         [1]     LDAB  #84
  0065 3b           [2]     PSHD  
  0066 ec84         [3]     LDD   4,SP
  0068 ee8a         [3]     LDX   10,SP
  006a 160000       [4]     JSR   _LCMP
  006d 1b86         [2]     LEAS  6,SP
  006f 2734         [3/1]   BEQ   *+54 ;abs = 00a5
 1986:  		return 0;
 1987:  	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  0071 ee88         [3]     LDX   8,SP
  0073 19e080       [2]     LEAY  128,X
  0076 e643         [3]     LDAB  3,Y
  0078 87           [1]     CLRA  
  0079 b781         [1]     EXG   A,B
  007b c7           [1]     CLRB  
  007c 3b           [2]     PSHD  
  007d e642         [3]     LDAB  2,Y
  007f 87           [1]     CLRA  
  0080 ce0000       [2]     LDX   #0
  0083 3b           [2]     PSHD  
  0084 b754         [1]     TFR   X,D
  0086 ca00         [1]     ORAB  #0
  0088 8a00         [1]     ORAA  #0
  008a 3b           [2]     PSHD  
  008b 071f         [4]     BSR   *+33 ;abs = 00ac
  008d e6e880       [3]     LDAB  128,Y
  0090 0731         [4]     BSR   *+51 ;abs = 00c3
  0092 cd4146       [2]     LDY   #16710
  0095 35           [2]     PSHY  
  0096 ce0054       [2]     LDX   #84
  0099 34           [2]     PSHX  
  009a b745         [1]     TFR   D,X
  009c ec84         [3]     LDD   4,SP
  009e 160000       [4]     JSR   _LCMP
  00a1 1b86         [2]     LEAS  6,SP
  00a3 2602         [3/1]   BNE   *+4 ;abs = 00a7
 1988:  		return 0;
  00a5 c7           [1]     CLRB  
  00a6 8f           [2]     SKIP2 
 1989:  
 1990:  	return 1;
  00a7 c601         [1]     LDAB  #1
 1991:  }
  00a9 1b86         [2]     LEAS  6,SP
  00ab 3d           [5]     RTS   
  00ac ec86         [3]     LDD   6,SP
  00ae ea85         [3]     ORAB  5,SP
  00b0 aa84         [3]     ORAA  4,SP
  00b2 6c84         [2]     STD   4,SP
  00b4 e641         [3]     LDAB  1,Y
  00b6 b710         [1]     TFR   B,A
  00b8 c7           [1]     CLRB  
  00b9 ea83         [3]     ORAB  3,SP
  00bb aa82         [3]     ORAA  2,SP
  00bd edf010       [3]     LDY   16,SP
  00c0 6c82         [2]     STD   2,SP
  00c2 3d           [5]     RTS   
  00c3 87           [1]     CLRA  
  00c4 ea83         [3]     ORAB  3,SP
  00c6 aa82         [3]     ORAA  2,SP
  00c8 6c82         [2]     STD   2,SP
  00ca ec84         [3]     LDD   4,SP
  00cc 87           [1]     CLRA  
  00cd 3d           [5]     RTS   
 1992:  
 1993:  
 1994:  
 1995:  
 1996:  /*-----------------------------------------------------------------------*/
 1997:  /* Check if the file system object is valid or not                       */
 1998:  /*-----------------------------------------------------------------------*/
 1999:  
 2000:  static
 2001:  FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
 2002:  	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
 2003:  	FATFS **rfs,		/* Pointer to pointer to the found file system object */
 2004:  	BYTE chk_wp			/* !=0: Check media write protection for write access */
 2005:  )
 2006:  {
*** EVALUATION ***

Function: chk_mounted
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6bad         [2]     STAB  3,-SP
  0002 1bf1dd       [2]     LEAS  -35,SP
 2007:  	BYTE fmt, b, *tbl;
 2008:  	UINT vol;
 2009:  	DSTATUS stat;
 2010:  	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
 2011:  	WORD nrsv;
 2012:  	const TCHAR *p = *path;
  0005 eef02a       [3]     LDX   42,SP
  0008 ed00         [3]     LDY   0,X
  000a 6df024       [3]     STY   36,SP
 2013:  	FATFS *fs;
 2014:  
 2015:  	/* Get logical drive number from the path name */
 2016:  	vol = p[0] - '0';					/* Is there a drive number? */
  000d e640         [3]     LDAB  0,Y
  000f b716         [1]     SEX   B,Y
  0011 19e9d0       [2]     LEAY  -48,Y
  0014 6df01e       [3]     STY   30,SP
 2017:  	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  0017 8d0009       [2]     CPY   #9
  001a 220f         [3/1]   BHI   *+17 ;abs = 002b
  001c edf024       [3]     LDY   36,SP
  001f e641         [3]     LDAB  1,Y
  0021 c13a         [1]     CMPB  #58
  0023 2606         [3/1]   BNE   *+8 ;abs = 002b
 2018:  		p += 2; *path = p;				/* Return pointer to the path name */
  0025 1942         [2]     LEAY  2,Y
  0027 6d00         [2]     STY   0,X
 2019:  	} else {							/* No drive number is given */
  0029 2005         [3]     BRA   *+7 ;abs = 0030
 2020:  #if _FS_RPATH
 2021:  		vol = CurrVol;					/* Use current drive */
 2022:  #else
 2023:  		vol = 0;						/* Use drive 0 */
  002b c7           [1]     CLRB  
  002c 87           [1]     CLRA  
  002d 6cf01e       [3]     STD   30,SP
 2024:  #endif
 2025:  	}
 2026:  
 2027:  	/* Check if the logical drive is valid or not */
 2028:  	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  0030 ecf01e       [3]     LDD   30,SP
  0033 2704         [3/1]   BEQ   *+6 ;abs = 0039
 2029:  		return FR_INVALID_DRIVE;
  0035 c60b         [1]     LDAB  #11
  0037 205a         [3]     BRA   *+92 ;abs = 0093
 2030:  	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  0039 59           [1]     LSLD  
  003a b745         [1]     TFR   D,X
  003c ece20000     [4]     LDD   FatFs,X
  0040 6c82         [2]     STD   2,SP
  0042 eef028       [3]     LDX   40,SP
  0045 6c00         [2]     STD   0,X
 2031:  	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  0047 2604         [3/1]   BNE   *+6 ;abs = 004d
  0049 c60c         [1]     LDAB  #12
  004b 2046         [3]     BRA   *+72 ;abs = 0093
 2032:  
 2033:  	ENTER_FF(fs);						/* Lock file system */
 2034:  
 2035:  	if (fs->fs_type) {					/* If the logical drive has been mounted */
  004d b745         [1]     TFR   D,X
  004f e600         [3]     LDAB  0,X
  0051 271d         [3/1]   BEQ   *+31 ;abs = 0070
 2036:  		stat = disk_status(fs->drv);
  0053 e601         [3]     LDAB  1,X
  0055 160000       [4]     JSR   eDisk_Status
  0058 6bf01d       [3]     STAB  29,SP
 2037:  		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  005b c401         [1]     ANDB  #1
  005d 2611         [3/1]   BNE   *+19 ;abs = 0070
 2038:  #if !_FS_READONLY
 2039:  			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  005f e6f023       [3]     LDAB  35,SP
  0062 18270490     [4/3]   LBEQ  *+1172 ;abs = 04f6
  0066 0ef01d0403   [5]     BRSET 29,SP,#4,*+8 ;abs = 006e
  006b 060000       [3]     JMP   chk_mounted:0x04f6
 2040:  				return FR_WRITE_PROTECTED;
  006e 2021         [3]     BRA   *+35 ;abs = 0091
 2041:  #endif
 2042:  			return FR_OK;				/* The file system object is valid */
 2043:  		}
 2044:  	}
 2045:  
 2046:  	/* The logical drive must be mounted. */
 2047:  	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */
 2048:  
 2049:  	fs->fs_type = 0;					/* Clear the file system object */
  0070 ee82         [3]     LDX   2,SP
  0072 6900         [2]     CLR   0,X
 2050:  	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
  0074 e6f01f       [3]     LDAB  31,SP
  0077 6b01         [2]     STAB  1,X
 2051:  	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  0079 160000       [4]     JSR   eDisk_Init
  007c 6bf01d       [3]     STAB  29,SP
 2052:  	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  007f c401         [1]     ANDB  #1
  0081 2704         [3/1]   BEQ   *+6 ;abs = 0087
 2053:  		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  0083 c603         [1]     LDAB  #3
  0085 2064         [3]     BRA   *+102 ;abs = 00eb
 2054:  #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
 2055:  	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
 2056:  		return FR_DISK_ERR;
 2057:  #endif
 2058:  #if !_FS_READONLY
 2059:  	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  0087 e6f023       [3]     LDAB  35,SP
  008a 2709         [3/1]   BEQ   *+11 ;abs = 0095
  008c 0ff01d0404   [5]     BRCLR 29,SP,#4,*+9 ;abs = 0095
 2060:  		return FR_WRITE_PROTECTED;
  0091 c60a         [1]     LDAB  #10
  0093 2056         [3]     BRA   *+88 ;abs = 00eb
 2061:  #endif
 2062:  	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
 2063:  	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
  0095 ee82         [3]     LDX   2,SP
  0097 34           [2]     PSHX  
  0098 c7           [1]     CLRB  
  0099 87           [1]     CLRA  
  009a 6c88         [2]     STD   8,SP
  009c 6c86         [2]     STD   6,SP
  009e b745         [1]     TFR   D,X
  00a0 160000       [4]     JSR   check_fs
  00a3 1b82         [2]     LEAS  2,SP
  00a5 6b8c         [2]     STAB  12,SP
 2064:  	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
  00a7 042139       [3]     DBNE  B,*+60 ;abs = 00e3
 2065:  		/* Check the partition listed in top of the partition table */
 2066:  		tbl = &fs->win[MBR_Table + LD2PT(vol) * SZ_PTE];/* Partition table */
  00aa ee82         [3]     LDX   2,SP
  00ac 19e201ec     [2]     LEAY  492,X
 2067:  		if (tbl[4]) {									/* Is the partition existing? */
  00b0 e644         [3]     LDAB  4,Y
  00b2 272f         [3/1]   BEQ   *+49 ;abs = 00e3
 2068:  			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
  00b4 1a48         [2]     LEAX  8,Y
  00b6 e603         [3]     LDAB  3,X
  00b8 87           [1]     CLRA  
  00b9 34           [2]     PSHX  
  00ba b781         [1]     EXG   A,B
  00bc c7           [1]     CLRB  
  00bd ee80         [3]     LDX   0,SP
  00bf 3b           [2]     PSHD  
  00c0 160000       [4]     JSR   chk_mounted:0x052d
  00c3 3b           [2]     PSHD  
  00c4 160000       [4]     JSR   chk_mounted:0x051a
  00c7 3b           [2]     PSHD  
  00c8 160000       [4]     JSR   chk_mounted:0x0509
  00cb e648         [3]     LDAB  8,Y
  00cd 160000       [4]     JSR   chk_mounted:0x04fc
  00d0 6c8e         [2]     STD   14,SP
  00d2 ee82         [3]     LDX   2,SP
  00d4 6e8c         [2]     STX   12,SP
 2069:  			fmt = check_fs(fs, bsect);					/* Check the partition */
  00d6 ed8a         [3]     LDY   10,SP
  00d8 35           [2]     PSHY  
  00d9 160000       [4]     JSR   check_fs
  00dc 1b82         [2]     LEAS  2,SP
  00de 6bf014       [3]     STAB  20,SP
  00e1 1b88         [2]     LEAS  8,SP
 2070:  		}
 2071:  	}
 2072:  	if (fmt == 3) return FR_DISK_ERR;
  00e3 e68c         [3]     LDAB  12,SP
  00e5 c103         [1]     CMPB  #3
  00e7 2605         [3/1]   BNE   *+7 ;abs = 00ee
  00e9 c601         [1]     LDAB  #1
  00eb 060000       [3]     JMP   chk_mounted:0x04f7
 2073:  	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
  00ee 044103       [3]     TBEQ  B,*+6 ;abs = 00f4
  00f1 060000       [3]     JMP   chk_mounted:0x03a5
 2074:  
 2075:  	/* Following code initializes the file system object */
 2076:  
 2077:  	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  00f4 ee82         [3]     LDX   2,SP
  00f6 19e039       [2]     LEAY  57,X
  00f9 160000       [4]     JSR   chk_mounted:0x0527
  00fc 3b           [2]     PSHD  
  00fd e6e039       [3]     LDAB  57,X
  0100 160000       [4]     JSR   chk_mounted:0x04fc
  0103 8c0200       [2]     CPD   #512
  0106 1b82         [2]     LEAS  2,SP
  0108 266a         [3/1]   BNE   *+108 ;abs = 0174
 2078:  		return FR_NO_FILESYSTEM;
 2079:  
 2080:  	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  010a 19e044       [2]     LEAY  68,X
  010d 160000       [4]     JSR   chk_mounted:0x0527
  0110 3b           [2]     PSHD  
  0111 e6e044       [3]     LDAB  68,X
  0114 160000       [4]     JSR   chk_mounted:0x04fc
  0117 6c8c         [2]     STD   12,SP
  0119 ce0000       [2]     LDX   #0
  011c 6e8a         [2]     STX   10,SP
 2081:  	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  011e 8c0000       [2]     CPD   #0
  0121 1b82         [2]     LEAS  2,SP
  0123 2635         [3/1]   BNE   *+55 ;abs = 015a
  0125 ed82         [3]     LDY   2,SP
  0127 1ae852       [2]     LEAX  82,Y
  012a e603         [3]     LDAB  3,X
  012c 87           [1]     CLRA  
  012d b781         [1]     EXG   A,B
  012f c7           [1]     CLRB  
  0130 cd0000       [2]     LDY   #0
  0133 3b           [2]     PSHD  
  0134 e602         [3]     LDAB  2,X
  0136 87           [1]     CLRA  
  0137 34           [2]     PSHX  
  0138 160000       [4]     JSR   chk_mounted:0x0547
  013b 160000       [4]     JSR   chk_mounted:0x0534
  013e 30           [3]     PULX  
  013f 6c80         [2]     STD   0,SP
  0141 160000       [4]     JSR   chk_mounted:0x0521
  0144 35           [2]     PSHY  
  0145 ea81         [3]     ORAB  1,SP
  0147 aab1         [3]     ORAA  2,SP+
  0149 ee84         [3]     LDX   4,SP
  014b 3b           [2]     PSHD  
  014c e6e052       [3]     LDAB  82,X
  014f 160000       [4]     JSR   chk_mounted:0x04fc
  0152 6c8e         [2]     STD   14,SP
  0154 ec82         [3]     LDD   2,SP
  0156 6c8c         [2]     STD   12,SP
  0158 1b84         [2]     LEAS  4,SP
 2082:  	fs->fsize = fasize;
  015a ee82         [3]     LDX   2,SP
  015c ec88         [3]     LDD   8,SP
  015e 6ce01a       [3]     STD   26,X
  0161 ec8a         [3]     LDD   10,SP
  0163 6ce01c       [3]     STD   28,X
 2083:  
 2084:  	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  0166 e6e03e       [3]     LDAB  62,X
  0169 6bf022       [3]     STAB  34,SP
  016c 6b03         [2]     STAB  3,X
 2085:  	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  016e c101         [1]     CMPB  #1
  0170 2704         [3/1]   BEQ   *+6 ;abs = 0176
  0172 c102         [1]     CMPB  #2
  0174 2625         [3/1]   BNE   *+39 ;abs = 019b
 2086:  	fasize *= b;										/* Number of sectors for FAT area */
  0176 87           [1]     CLRA  
  0177 b746         [1]     TFR   D,Y
  0179 ec8a         [3]     LDD   10,SP
  017b ee88         [3]     LDX   8,SP
  017d 160000       [4]     JSR   _LMULU16x32
  0180 6c8a         [2]     STD   10,SP
  0182 6e88         [2]     STX   8,SP
 2087:  
 2088:  	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  0184 ee82         [3]     LDX   2,SP
  0186 e6e03b       [3]     LDAB  59,X
  0189 6bf022       [3]     STAB  34,SP
  018c 6b02         [2]     STAB  2,X
 2089:  	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  018e ce0000       [2]     LDX   #0
  0191 046103       [3]     TBNE  B,*+6 ;abs = 0197
  0194 060000       [3]     JMP   chk_mounted:0x03a5
  0197 53           [1]     DECB  
  0198 e4f022       [3]     ANDB  34,SP
  019b 18260206     [4/3]   LBNE  *+522 ;abs = 03a5
 2090:  
 2091:  	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  019f ed82         [3]     LDY   2,SP
  01a1 1ae83f       [2]     LEAX  63,Y
  01a4 160000       [4]     JSR   chk_mounted:0x0521
  01a7 3b           [2]     PSHD  
  01a8 e6e83f       [3]     LDAB  63,Y
  01ab 160000       [4]     JSR   chk_mounted:0x04fc
  01ae 6c48         [2]     STD   8,Y
 2092:  	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  01b0 1b82         [2]     LEAS  2,SP
  01b2 0f490f03     [4]     BRCLR 9,Y,#15,*+7 ;abs = 01b9
  01b6 060000       [3]     JMP   chk_mounted:0x03a5
 2093:  
 2094:  	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  01b9 1ae841       [2]     LEAX  65,Y
  01bc 160000       [4]     JSR   chk_mounted:0x0521
  01bf 3b           [2]     PSHD  
  01c0 e6e841       [3]     LDAB  65,Y
  01c3 160000       [4]     JSR   chk_mounted:0x04fc
  01c6 6cf015       [3]     STD   21,SP
  01c9 ce0000       [2]     LDX   #0
  01cc 6ef013       [3]     STX   19,SP
 2095:  	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  01cf 8c0000       [2]     CPD   #0
  01d2 1b82         [2]     LEAS  2,SP
  01d4 2628         [3/1]   BNE   *+42 ;abs = 01fe
  01d6 1ae84e       [2]     LEAX  78,Y
  01d9 e603         [3]     LDAB  3,X
  01db 87           [1]     CLRA  
  01dc 34           [2]     PSHX  
  01dd b781         [1]     EXG   A,B
  01df c7           [1]     CLRB  
  01e0 ee80         [3]     LDX   0,SP
  01e2 3b           [2]     PSHD  
  01e3 160000       [4]     JSR   chk_mounted:0x052d
  01e6 3b           [2]     PSHD  
  01e7 160000       [4]     JSR   chk_mounted:0x051a
  01ea 3b           [2]     PSHD  
  01eb 160000       [4]     JSR   chk_mounted:0x0509
  01ee e6e84e       [3]     LDAB  78,Y
  01f1 160000       [4]     JSR   chk_mounted:0x04fc
  01f4 6cf01b       [3]     STD   27,SP
  01f7 ec82         [3]     LDD   2,SP
  01f9 6cf019       [3]     STD   25,SP
  01fc 1b88         [2]     LEAS  8,SP
 2096:  
 2097:  	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  01fe 1ae83c       [2]     LEAX  60,Y
  0201 160000       [4]     JSR   chk_mounted:0x0521
  0204 3b           [2]     PSHD  
  0205 e6e83c       [3]     LDAB  60,Y
  0208 160000       [4]     JSR   chk_mounted:0x04fc
  020b 6cf022       [3]     STD   34,SP
 2098:  	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  020e 1b82         [2]     LEAS  2,SP
  0210 18270191     [4/3]   LBEQ  *+405 ;abs = 03a5
 2099:  
 2100:  	/* Determine the FAT sub type */
 2101:  	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  0214 ec48         [3]     LDD   8,Y
  0216 49           [1]     LSRD  
  0217 49           [1]     LSRD  
  0218 49           [1]     LSRD  
  0219 49           [1]     LSRD  
  021a 3b           [2]     PSHD  
  021b ecf022       [3]     LDD   34,SP
  021e e38c         [3]     ADDD  12,SP
  0220 3b           [2]     PSHD  
  0221 cc0000       [2]     LDD   #0
  0224 e98d         [3]     ADCB  13,SP
  0226 a98c         [3]     ADCA  12,SP
  0228 3b           [2]     PSHD  
  0229 ec84         [3]     LDD   4,SP
  022b e382         [3]     ADDD  2,SP
  022d 6cf01d       [3]     STD   29,SP
  0230 cc0000       [2]     LDD   #0
  0233 e981         [3]     ADCB  1,SP
  0235 a980         [3]     ADCA  0,SP
  0237 6cf01b       [3]     STD   27,SP
 2102:  	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  023a acf017       [3]     CPD   23,SP
  023d 1b86         [2]     LEAS  6,SP
  023f 18220162     [4/3]   LBHI  *+358 ;abs = 03a5
  0243 ecf011       [3]     LDD   17,SP
  0246 acf015       [3]     CPD   21,SP
  0249 260a         [3/1]   BNE   *+12 ;abs = 0255
  024b ecf013       [3]     LDD   19,SP
  024e acf017       [3]     CPD   23,SP
  0251 18250150     [4/3]   LBCS  *+340 ;abs = 03a5
 2103:  	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  0255 e642         [3]     LDAB  2,Y
  0257 87           [1]     CLRA  
  0258 b745         [1]     TFR   D,X
  025a ecf013       [3]     LDD   19,SP
  025d a3f017       [3]     SUBD  23,SP
  0260 3b           [2]     PSHD  
  0261 ecf013       [3]     LDD   19,SP
  0264 e2f018       [3]     SBCB  24,SP
  0267 a2f017       [3]     SBCA  23,SP
  026a 34           [2]     PSHX  
  026b b745         [1]     TFR   D,X
  026d c7           [1]     CLRB  
  026e 87           [1]     CLRA  
  026f 3b           [2]     PSHD  
  0270 ec84         [3]     LDD   4,SP
  0272 160000       [4]     JSR   _LDIVU
  0275 6cf011       [3]     STD   17,SP
  0278 6e8f         [2]     STX   15,SP
 2104:  	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  027a 8c0000       [2]     CPD   #0
  027d 1b82         [2]     LEAS  2,SP
  027f 2606         [3/1]   BNE   *+8 ;abs = 0287
  0281 046503       [3]     TBNE  X,*+6 ;abs = 0287
  0284 060000       [3]     JMP   chk_mounted:0x03a5
 2105:  	fmt = FS_FAT12;
  0287 c601         [1]     LDAB  #1
  0289 6b8c         [2]     STAB  12,SP
 2106:  	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  028b ec8d         [3]     LDD   13,SP
  028d 2607         [3/1]   BNE   *+9 ;abs = 0296
  028f ec8f         [3]     LDD   15,SP
  0291 8c0ff6       [2]     CPD   #4086
  0294 2504         [3/1]   BCS   *+6 ;abs = 029a
  0296 c602         [1]     LDAB  #2
  0298 6b8c         [2]     STAB  12,SP
 2107:  	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  029a ec8d         [3]     LDD   13,SP
  029c 2607         [3/1]   BNE   *+9 ;abs = 02a5
  029e ec8f         [3]     LDD   15,SP
  02a0 8cfff6       [2]     CPD   #65526
  02a3 2504         [3/1]   BCS   *+6 ;abs = 02a9
  02a5 c603         [1]     LDAB  #3
  02a7 6b8c         [2]     STAB  12,SP
 2108:  
 2109:  	/* Boundaries and Limits */
 2110:  	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  02a9 ec8f         [3]     LDD   15,SP
  02ab c30002       [2]     ADDD  #2
  02ae ee82         [3]     LDX   2,SP
  02b0 6ce018       [3]     STD   24,X
  02b3 ec8d         [3]     LDD   13,SP
  02b5 c900         [1]     ADCB  #0
  02b7 8900         [1]     ADCA  #0
  02b9 6ce016       [3]     STD   22,X
 2111:  	fs->database = bsect + sysect;						/* Data start sector */
  02bc ec86         [3]     LDD   6,SP
  02be e3f017       [3]     ADDD  23,SP
  02c1 6ce028       [3]     STD   40,X
  02c4 ecf015       [3]     LDD   21,SP
  02c7 e985         [3]     ADCB  5,SP
  02c9 a984         [3]     ADCA  4,SP
  02cb 6ce026       [3]     STD   38,X
 2112:  	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  02ce ecf020       [3]     LDD   32,SP
  02d1 e386         [3]     ADDD  6,SP
  02d3 6ce020       [3]     STD   32,X
  02d6 cc0000       [2]     LDD   #0
  02d9 e985         [3]     ADCB  5,SP
  02db a984         [3]     ADCA  4,SP
  02dd 6ce01e       [3]     STD   30,X
 2113:  	if (fmt == FS_FAT32) {
  02e0 e68c         [3]     LDAB  12,SP
  02e2 c103         [1]     CMPB  #3
  02e4 2640         [3/1]   BNE   *+66 ;abs = 0326
 2114:  		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  02e6 ec08         [3]     LDD   8,X
  02e8 182600b9     [4/3]   LBNE  *+189 ;abs = 03a5
 2115:  		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  02ec 19e05a       [2]     LEAY  90,X
  02ef 160000       [4]     JSR   chk_mounted:0x0540
  02f2 3b           [2]     PSHD  
  02f3 160000       [4]     JSR   chk_mounted:0x0539
  02f6 3b           [2]     PSHD  
  02f7 160000       [4]     JSR   chk_mounted:0x051a
  02fa 3b           [2]     PSHD  
  02fb ec84         [3]     LDD   4,SP
  02fd 160000       [4]     JSR   chk_mounted:0x0534
  0300 b745         [1]     TFR   D,X
  0302 160000       [4]     JSR   chk_mounted:0x0500
  0305 e6e85a       [3]     LDAB  90,Y
  0308 160000       [4]     JSR   chk_mounted:0x04fc
  030b 6ce824       [3]     STD   36,Y
  030e 6ee822       [3]     STX   34,Y
 2116:  		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  0311 eee816       [3]     LDX   22,Y
  0314 ede818       [3]     LDY   24,Y
  0317 c602         [1]     LDAB  #2
  0319 160000       [4]     JSR   _LSHL
  031c 6cf021       [3]     STD   33,SP
  031f 6ef01f       [3]     STX   31,SP
 2117:  	} else {
  0322 1b86         [2]     LEAS  6,SP
  0324 2058         [3]     BRA   *+90 ;abs = 037e
 2118:  		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  0326 ec08         [3]     LDD   8,X
  0328 277b         [3/1]   BEQ   *+125 ;abs = 03a5
 2119:  		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  032a ece020       [3]     LDD   32,X
  032d e38a         [3]     ADDD  10,SP
  032f 6ce024       [3]     STD   36,X
  0332 ec88         [3]     LDD   8,SP
  0334 e9e01f       [3]     ADCB  31,X
  0337 a9e01e       [3]     ADCA  30,X
  033a 6ce022       [3]     STD   34,X
 2120:  		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
  033d e68c         [3]     LDAB  12,SP
  033f c102         [1]     CMPB  #2
  0341 2726         [3/1]   BEQ   *+40 ;abs = 0369
 2121:  			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  0343 ece018       [3]     LDD   24,X
  0346 eee016       [3]     LDX   22,X
  0349 cd0003       [2]     LDY   #3
  034c 160000       [4]     JSR   _LMULU16x32
  034f b7c5         [1]     EXG   D,X
  0351 49           [1]     LSRD  
  0352 b7c5         [1]     EXG   D,X
  0354 46           [1]     RORA  
  0355 56           [1]     RORB  
  0356 ed82         [3]     LDY   2,SP
  0358 3b           [2]     PSHD  
  0359 e6e819       [3]     LDAB  25,Y
  035c c401         [1]     ANDB  #1
  035e 87           [1]     CLRA  
  035f e3b1         [3]     ADDD  2,SP+
  0361 b7c5         [1]     EXG   D,X
  0363 c900         [1]     ADCB  #0
  0365 8900         [1]     ADCA  #0
  0367 200d         [3]     BRA   *+15 ;abs = 0376
  0369 eee016       [3]     LDX   22,X
  036c ed82         [3]     LDY   2,SP
  036e ece818       [3]     LDD   24,Y
  0371 59           [1]     LSLD  
  0372 b7c5         [1]     EXG   D,X
  0374 55           [1]     ROLB  
  0375 45           [1]     ROLA  
  0376 b7c5         [1]     EXG   D,X
  0378 6cf01b       [3]     STD   27,SP
  037b 6ef019       [3]     STX   25,SP
 2122:  	}
 2123:  	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  037e ecf01b       [3]     LDD   27,SP
  0381 c301ff       [2]     ADDD  #511
  0384 b746         [1]     TFR   D,Y
  0386 ecf019       [3]     LDD   25,SP
  0389 c900         [1]     ADCB  #0
  038b 8900         [1]     ADCA  #0
  038d b745         [1]     TFR   D,X
  038f c609         [1]     LDAB  #9
  0391 160000       [4]     JSR   _LSHRU
  0394 ed82         [3]     LDY   2,SP
  0396 34           [2]     PSHX  
  0397 1ae81a       [2]     LEAX  26,Y
  039a 34           [2]     PSHX  
  039b ee82         [3]     LDX   2,SP
  039d 31           [3]     PULY  
  039e 160000       [4]     JSR   _LCMP_P
  03a1 1b82         [2]     LEAS  2,SP
  03a3 2305         [3/1]   BLS   *+7 ;abs = 03aa
 2124:  		return FR_NO_FILESYSTEM;
  03a5 c60d         [1]     LDAB  #13
  03a7 060000       [3]     JMP   chk_mounted:0x04f7
 2125:  
 2126:  #if !_FS_READONLY
 2127:  	/* Initialize cluster allocation information */
 2128:  	fs->free_clust = 0xFFFFFFFF;
  03aa ccffff       [2]     LDD   #65535
  03ad ee82         [3]     LDX   2,SP
  03af 6c0e         [2]     STD   14,X
  03b1 6ce010       [3]     STD   16,X
 2129:  	fs->last_clust = 0;
  03b4 c7           [1]     CLRB  
  03b5 87           [1]     CLRA  
  03b6 6c0a         [2]     STD   10,X
  03b8 6c0c         [2]     STD   12,X
 2130:  
 2131:  	/* Get fsinfo if available */
 2132:  	if (fmt == FS_FAT32) {
  03ba e68c         [3]     LDAB  12,SP
  03bc c103         [1]     CMPB  #3
  03be 2637         [3/1]   BNE   *+57 ;abs = 03f7
 2133:  	 	fs->fsi_flag = 0;
  03c0 6a05         [2]     STAA  5,X
 2134:  		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  03c2 19e05e       [2]     LEAY  94,X
  03c5 160000       [4]     JSR   chk_mounted:0x0527
  03c8 3b           [2]     PSHD  
  03c9 e6e05e       [3]     LDAB  94,X
  03cc 160000       [4]     JSR   chk_mounted:0x04fc
  03cf e388         [3]     ADDD  8,SP
  03d1 6ce014       [3]     STD   20,X
  03d4 b746         [1]     TFR   D,Y
  03d6 cc0000       [2]     LDD   #0
  03d9 e987         [3]     ADCB  7,SP
  03db a986         [3]     ADCA  6,SP
  03dd 6ce012       [3]     STD   18,X
 2135:  		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  03e0 6c82         [2]     STD   2,SP
  03e2 e601         [3]     LDAB  1,X
  03e4 37           [2]     PSHB  
  03e5 1ae02e       [2]     LEAX  46,X
  03e8 34           [2]     PSHX  
  03e9 35           [2]     PSHY  
  03ea ec87         [3]     LDD   7,SP
  03ec 3b           [2]     PSHD  
  03ed c601         [1]     LDAB  #1
  03ef 160000       [4]     JSR   eDisk_Read
  03f2 8c0000       [2]     CPD   #0
  03f5 1b89         [2]     LEAS  9,SP
  03f7 2616         [3/1]   BNE   *+24 ;abs = 040f
 2136:  			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  03f9 ee82         [3]     LDX   2,SP
  03fb 19e2022c     [2]     LEAY  556,X
  03ff 160000       [4]     JSR   chk_mounted:0x0527
  0402 3b           [2]     PSHD  
  0403 e6e2022c     [4]     LDAB  556,X
  0407 160000       [4]     JSR   chk_mounted:0x04fc
  040a 8caa55       [2]     CPD   #43605
  040d 1b82         [2]     LEAS  2,SP
  040f 263b         [3/1]   BNE   *+61 ;abs = 044c
 2137:  			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  0411 e6e031       [3]     LDAB  49,X
  0414 87           [1]     CLRA  
  0415 b781         [1]     EXG   A,B
  0417 c7           [1]     CLRB  
  0418 cd0000       [2]     LDY   #0
  041b 3b           [2]     PSHD  
  041c e6e030       [3]     LDAB  48,X
  041f 87           [1]     CLRA  
  0420 160000       [4]     JSR   chk_mounted:0x0547
  0423 ea81         [3]     ORAB  1,SP
  0425 aa80         [3]     ORAA  0,SP
  0427 ee84         [3]     LDX   4,SP
  0429 6c80         [2]     STD   0,SP
  042b e6e02f       [3]     LDAB  47,X
  042e b710         [1]     TFR   B,A
  0430 c7           [1]     CLRB  
  0431 35           [2]     PSHY  
  0432 ea81         [3]     ORAB  1,SP
  0434 aab1         [3]     ORAA  2,SP+
  0436 3b           [2]     PSHD  
  0437 e6e02e       [3]     LDAB  46,X
  043a 160000       [4]     JSR   chk_mounted:0x04fc
  043d cd5252       [2]     LDY   #21074
  0440 35           [2]     PSHY  
  0441 cd4161       [2]     LDY   #16737
  0444 35           [2]     PSHY  
  0445 ee86         [3]     LDX   6,SP
  0447 160000       [4]     JSR   _LCMP
  044a 1b84         [2]     LEAS  4,SP
  044c 2632         [3/1]   BNE   *+52 ;abs = 0480
 2138:  			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  044e ee82         [3]     LDX   2,SP
  0450 19e20212     [2]     LEAY  530,X
  0454 160000       [4]     JSR   chk_mounted:0x0540
  0457 3b           [2]     PSHD  
  0458 160000       [4]     JSR   chk_mounted:0x0539
  045b 3b           [2]     PSHD  
  045c 160000       [4]     JSR   chk_mounted:0x051a
  045f 3b           [2]     PSHD  
  0460 ec84         [3]     LDD   4,SP
  0462 160000       [4]     JSR   chk_mounted:0x0534
  0465 6c82         [2]     STD   2,SP
  0467 160000       [4]     JSR   chk_mounted:0x0500
  046a e6ea0212     [4]     LDAB  530,Y
  046e 160000       [4]     JSR   chk_mounted:0x04fc
  0471 ce7272       [2]     LDX   #29298
  0474 34           [2]     PSHX  
  0475 ce6141       [2]     LDX   #24897
  0478 34           [2]     PSHX  
  0479 ee86         [3]     LDX   6,SP
  047b 160000       [4]     JSR   _LCMP
  047e 1b86         [2]     LEAS  6,SP
  0480 265b         [3/1]   BNE   *+93 ;abs = 04dd
 2139:  				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  0482 ee82         [3]     LDX   2,SP
  0484 19e2021a     [2]     LEAY  538,X
  0488 160000       [4]     JSR   chk_mounted:0x0540
  048b 3b           [2]     PSHD  
  048c 160000       [4]     JSR   chk_mounted:0x0539
  048f 3b           [2]     PSHD  
  0490 160000       [4]     JSR   chk_mounted:0x051a
  0493 3b           [2]     PSHD  
  0494 ec84         [3]     LDD   4,SP
  0496 160000       [4]     JSR   chk_mounted:0x0534
  0499 b745         [1]     TFR   D,X
  049b 0763         [4]     BSR   *+101 ;abs = 0500
  049d e6ea021a     [4]     LDAB  538,Y
  04a1 0759         [4]     BSR   *+91 ;abs = 04fc
  04a3 6c4c         [2]     STD   12,Y
  04a5 6e4a         [2]     STX   10,Y
 2140:  				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  04a7 1aea0216     [2]     LEAX  534,Y
  04ab e603         [3]     LDAB  3,X
  04ad 87           [1]     CLRA  
  04ae 6e80         [2]     STX   0,SP
  04b0 b781         [1]     EXG   A,B
  04b2 c7           [1]     CLRB  
  04b3 6c82         [2]     STD   2,SP
  04b5 0776         [4]     BSR   *+120 ;abs = 052d
  04b7 6c84         [2]     STD   4,SP
  04b9 075f         [4]     BSR   *+97 ;abs = 051a
  04bb 3b           [2]     PSHD  
  04bc ec84         [3]     LDD   4,SP
  04be ea87         [3]     ORAB  7,SP
  04c0 aa86         [3]     ORAA  6,SP
  04c2 ee82         [3]     LDX   2,SP
  04c4 6c86         [2]     STD   6,SP
  04c6 0759         [4]     BSR   *+91 ;abs = 0521
  04c8 ea81         [3]     ORAB  1,SP
  04ca aa80         [3]     ORAA  0,SP
  04cc 6c80         [2]     STD   0,SP
  04ce e6ea0216     [4]     LDAB  534,Y
  04d2 0728         [4]     BSR   *+42 ;abs = 04fc
  04d4 6ce810       [3]     STD   16,Y
  04d7 ec86         [3]     LDD   6,SP
  04d9 6c4e         [2]     STD   14,Y
  04db 1b88         [2]     LEAS  8,SP
 2141:  		}
 2142:  	}
 2143:  #endif
 2144:  	fs->fs_type = fmt;		/* FAT sub-type */
  04dd ee82         [3]     LDX   2,SP
  04df e68c         [3]     LDAB  12,SP
  04e1 6b00         [2]     STAB  0,X
 2145:  	fs->id = ++Fsid;		/* File system mount ID */
  04e3 fd0000       [3]     LDY   Fsid
  04e6 02           [1]     INY   
  04e7 7d0000       [3]     STY   Fsid
  04ea 6d06         [2]     STY   6,X
 2146:  	fs->winsect = 0;		/* Invalidate sector cache */
  04ec c7           [1]     CLRB  
  04ed 87           [1]     CLRA  
  04ee 6ce02a       [3]     STD   42,X
  04f1 6ce02c       [3]     STD   44,X
 2147:  	fs->wflag = 0;
  04f4 6b04         [2]     STAB  4,X
 2148:  #if _FS_RPATH
 2149:  	fs->cdir = 0;			/* Current directory (root dir) */
 2150:  #endif
 2151:  #if _FS_SHARE				/* Clear file lock semaphores */
 2152:  	clear_lock(fs);
 2153:  #endif
 2154:  
 2155:  	return FR_OK;
  04f6 c7           [1]     CLRB  
  04f7 87           [1]     CLRA  
 2156:  }
  04f8 1bf026       [2]     LEAS  38,SP
  04fb 3d           [5]     RTS   
  04fc 87           [1]     CLRA  
  04fd 0735         [4]     BSR   *+55 ;abs = 0534
  04ff 3d           [5]     RTS   
  0500 0725         [4]     BSR   *+39 ;abs = 0527
  0502 0730         [4]     BSR   *+50 ;abs = 0534
  0504 ed8a         [3]     LDY   10,SP
  0506 6c82         [2]     STD   2,SP
  0508 3d           [5]     RTS   
  0509 ec86         [3]     LDD   6,SP
  050b ea85         [3]     ORAB  5,SP
  050d aa84         [3]     ORAA  4,SP
  050f ee88         [3]     LDX   8,SP
  0511 6c84         [2]     STD   4,SP
  0513 070c         [4]     BSR   *+14 ;abs = 0521
  0515 071d         [4]     BSR   *+31 ;abs = 0534
  0517 6c82         [2]     STD   2,SP
  0519 3d           [5]     RTS   
  051a b754         [1]     TFR   X,D
  051c ca00         [1]     ORAB  #0
  051e 8a00         [1]     ORAA  #0
  0520 3d           [5]     RTS   
  0521 e601         [3]     LDAB  1,X
  0523 b710         [1]     TFR   B,A
  0525 c7           [1]     CLRB  
  0526 3d           [5]     RTS   
  0527 e641         [3]     LDAB  1,Y
  0529 b710         [1]     TFR   B,A
  052b c7           [1]     CLRB  
  052c 3d           [5]     RTS   
  052d e602         [3]     LDAB  2,X
  052f 87           [1]     CLRA  
  0530 ce0000       [2]     LDX   #0
  0533 3d           [5]     RTS   
  0534 ea85         [3]     ORAB  5,SP
  0536 aa84         [3]     ORAA  4,SP
  0538 3d           [5]     RTS   
  0539 e642         [3]     LDAB  2,Y
  053b 87           [1]     CLRA  
  053c ce0000       [2]     LDX   #0
  053f 3d           [5]     RTS   
  0540 e643         [3]     LDAB  3,Y
  0542 87           [1]     CLRA  
  0543 b781         [1]     EXG   A,B
  0545 c7           [1]     CLRB  
  0546 3d           [5]     RTS   
  0547 b7c6         [1]     EXG   D,Y
  0549 ca00         [1]     ORAB  #0
  054b 8a00         [1]     ORAA  #0
  054d b7c6         [1]     EXG   D,Y
  054f 3d           [5]     RTS   
 2157:  
 2158:  
 2159:  
 2160:  
 2161:  /*-----------------------------------------------------------------------*/
 2162:  /* Check if the file/dir object is valid or not                          */
 2163:  /*-----------------------------------------------------------------------*/
 2164:  
 2165:  static
 2166:  FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
 2167:  	FATFS *fs,		/* Pointer to the file system object */
 2168:  	WORD id			/* Member id of the target object to be checked */
 2169:  )
 2170:  {
*** EVALUATION ***

Function: validate
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 3b           [2]     PSHD  
 2171:  	if (!fs || !fs->fs_type || fs->id != id)
  0001 ee84         [3]     LDX   4,SP
  0003 270a         [3/1]   BEQ   *+12 ;abs = 000f
  0005 e600         [3]     LDAB  0,X
  0007 2706         [3/1]   BEQ   *+8 ;abs = 000f
  0009 ec06         [3]     LDD   6,X
  000b ac80         [3]     CPD   0,SP
  000d 2704         [3/1]   BEQ   *+6 ;abs = 0013
 2172:  		return FR_INVALID_OBJECT;
  000f c609         [1]     LDAB  #9
  0011 200d         [3]     BRA   *+15 ;abs = 0020
 2173:  
 2174:  	ENTER_FF(fs);		/* Lock file system */
 2175:  
 2176:  	if (disk_status(fs->drv) & STA_NOINIT)
  0013 e601         [3]     LDAB  1,X
  0015 160000       [4]     JSR   eDisk_Status
  0018 c401         [1]     ANDB  #1
  001a 2703         [3/1]   BEQ   *+5 ;abs = 001f
 2177:  		return FR_NOT_READY;
  001c c603         [1]     LDAB  #3
  001e 21           [1]     SKIP1 
 2178:  
 2179:  	return FR_OK;
  001f c7           [1]     CLRB  
  0020 87           [1]     CLRA  
 2180:  }
  0021 30           [3]     PULX  
  0022 3d           [5]     RTS   
 2181:  
 2182:  
 2183:  
 2184:  
 2185:  /*--------------------------------------------------------------------------
 2186:  
 2187:     Public Functions
 2188:  
 2189:  --------------------------------------------------------------------------*/
 2190:  
 2191:  
 2192:  
 2193:  /*-----------------------------------------------------------------------*/
 2194:  /* Mount/Unmount a Logical Drive                                         */
 2195:  /*-----------------------------------------------------------------------*/
 2196:  
 2197:  FRESULT f_mount (
 2198:  	BYTE vol,		/* Logical drive number to be mounted/unmounted */
 2199:  	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
 2200:  )
 2201:  {
*** EVALUATION ***

Function: f_mount
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 3b           [2]     PSHD  
 2202:  	FATFS *rfs;
 2203:  
 2204:  
 2205:  	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
  0001 e684         [3]     LDAB  4,SP
  0003 2704         [3/1]   BEQ   *+6 ;abs = 0009
 2206:  		return FR_INVALID_DRIVE;
  0005 c60b         [1]     LDAB  #11
  0007 201d         [3]     BRA   *+31 ;abs = 0026
 2207:  	rfs = FatFs[vol];				/* Get current fs object */
  0009 87           [1]     CLRA  
  000a 59           [1]     LSLD  
  000b b745         [1]     TFR   D,X
  000d ede20000     [4]     LDY   FatFs,X
 2208:  
 2209:  	if (rfs) {
  0011 2702         [3/1]   BEQ   *+4 ;abs = 0015
 2210:  #if _FS_SHARE
 2211:  		clear_lock(rfs);
 2212:  #endif
 2213:  #if _FS_REENTRANT					/* Discard sync object of the current volume */
 2214:  		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
 2215:  #endif
 2216:  		rfs->fs_type = 0;			/* Clear old fs object */
  0013 6940         [2]     CLR   0,Y
 2217:  	}
 2218:  
 2219:  	if (fs) {
  0015 ee80         [3]     LDX   0,SP
  0017 2702         [3/1]   BEQ   *+4 ;abs = 001b
 2220:  		fs->fs_type = 0;			/* Clear new fs object */
  0019 6900         [2]     CLR   0,X
 2221:  #if _FS_REENTRANT					/* Create sync object for the new volume */
 2222:  		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
 2223:  #endif
 2224:  	}
 2225:  	FatFs[vol] = fs;				/* Register new fs object */
  001b e684         [3]     LDAB  4,SP
  001d 87           [1]     CLRA  
  001e 59           [1]     LSLD  
  001f b746         [1]     TFR   D,Y
  0021 6eea0000     [3]     STX   FatFs,Y
 2226:  
 2227:  	return FR_OK;
  0025 c7           [1]     CLRB  
  0026 87           [1]     CLRA  
 2228:  }
  0027 30           [3]     PULX  
  0028 3d           [5]     RTS   
 2229:  
 2230:  
 2231:  
 2232:  
 2233:  /*-----------------------------------------------------------------------*/
 2234:  /* Open or Create a File                                                 */
 2235:  /*-----------------------------------------------------------------------*/
 2236:  
 2237:  FRESULT f_open (
 2238:  	FIL *fp,			/* Pointer to the blank file object */
 2239:  	const TCHAR *path,	/* Pointer to the file name */
 2240:  	BYTE mode			/* Access mode and file open mode flags */
 2241:  )
 2242:  {
*** EVALUATION ***

Function: f_open
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1d2       [2]     LEAS  -46,SP
  0003 37           [2]     PSHB  
 2243:  	FRESULT res;
 2244:  	DIR dj;
 2245:  	BYTE *dir;
 2246:  	DEF_NAMEBUF;
 2247:  
 2248:  
 2249:  	fp->fs = 0;			/* Clear file object */
  0004 eef033       [3]     LDX   51,SP
  0007 c7           [1]     CLRB  
  0008 87           [1]     CLRA  
  0009 6c00         [2]     STD   0,X
 2250:  
 2251:  #if !_FS_READONLY
 2252:  	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  000b 0d80e0       [4]     BCLR  0,SP,#224
 2253:  	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  000e 1af031       [2]     LEAX  49,SP
  0011 34           [2]     PSHX  
  0012 1a8f         [2]     LEAX  15,SP
  0014 34           [2]     PSHX  
  0015 e684         [3]     LDAB  4,SP
  0017 c4fe         [1]     ANDB  #254
  0019 160000       [4]     JSR   chk_mounted
  001c 1b84         [2]     LEAS  4,SP
  001e 6c81         [2]     STD   1,SP
 2254:  #else
 2255:  	mode &= FA_READ;
 2256:  	res = chk_mounted(&path, &dj.fs, 0);
 2257:  #endif
 2258:  	INIT_BUF(dj);
  0020 1af023       [2]     LEAX  35,SP
  0023 6ef021       [3]     STX   33,SP
 2259:  	if (res == FR_OK)
  0026 04640d       [3]     TBNE  D,*+16 ;abs = 0036
 2260:  		res = follow_path(&dj, path);	/* Follow the file path */
  0029 1a8d         [2]     LEAX  13,SP
  002b 34           [2]     PSHX  
  002c ecf033       [3]     LDD   51,SP
  002f 160000       [4]     JSR   follow_path
  0032 1b82         [2]     LEAS  2,SP
  0034 6c81         [2]     STD   1,SP
 2261:  	dir = dj.dir;
  0036 ecf01f       [3]     LDD   31,SP
  0039 6c8b         [2]     STD   11,SP
 2262:  
 2263:  #if !_FS_READONLY	/* R/W configuration */
 2264:  	if (res == FR_OK) {
  003b ee81         [3]     LDX   1,SP
  003d 2608         [3/1]   BNE   *+10 ;abs = 0047
 2265:  		if (!dir)	/* Current dir itself */
  003f 046405       [3]     TBNE  D,*+8 ;abs = 0047
 2266:  			res = FR_INVALID_NAME;
  0042 c606         [1]     LDAB  #6
  0044 87           [1]     CLRA  
  0045 6c81         [2]     STD   1,SP
 2267:  #if _FS_SHARE
 2268:  		else
 2269:  			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 2270:  #endif
 2271:  	}
 2272:  	/* Create or Open a file */
 2273:  	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  0047 0f801c02     [4]     BRCLR 0,SP,#28,*+6 ;abs = 004d
  004b 2003         [3]     BRA   *+5 ;abs = 0050
  004d 060000       [3]     JMP   f_open:0x0138
 2274:  		DWORD dw, cl;
 2275:  
 2276:  		if (res != FR_OK) {					/* No file, create new */
  0050 ec81         [3]     LDD   1,SP
  0052 2718         [3/1]   BEQ   *+26 ;abs = 006c
 2277:  			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  0054 8c0004       [2]     CPD   #4
  0057 2609         [3/1]   BNE   *+11 ;abs = 0062
 2278:  #if _FS_SHARE
 2279:  				res = enq_lock(dj.fs) ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 2280:  #else
 2281:  				res = dir_register(&dj);
  0059 1a8d         [2]     LEAX  13,SP
  005b b754         [1]     TFR   X,D
  005d 160000       [4]     JSR   dir_register
  0060 6c81         [2]     STD   1,SP
 2282:  #endif
 2283:  			mode |= FA_CREATE_ALWAYS;		/* File is created */
  0062 0c8008       [4]     BSET  0,SP,#8
 2284:  			dir = dj.dir;					/* New entry */
  0065 ecf01f       [3]     LDD   31,SP
  0068 6c8b         [2]     STD   11,SP
 2285:  		}
  006a 2014         [3]     BRA   *+22 ;abs = 0080
 2286:  		else {								/* Any object is already existing */
 2287:  			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  006c ee8b         [3]     LDX   11,SP
  006e 0f0b1105     [4]     BRCLR 11,X,#17,*+9 ;abs = 0077
 2288:  				res = FR_DENIED;
  0072 c607         [1]     LDAB  #7
 2289:  			} else {
  0074 060000       [3]     JMP   f_open:0x0144
 2290:  				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  0077 0f800405     [4]     BRCLR 0,SP,#4,*+9 ;abs = 0080
 2291:  					res = FR_EXIST;
  007b c608         [1]     LDAB  #8
  007d 87           [1]     CLRA  
  007e 6c81         [2]     STD   1,SP
 2292:  			}
 2293:  		}
 2294:  		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  0080 ec81         [3]     LDD   1,SP
  0082 182600d1     [4/3]   LBNE  *+213 ;abs = 0157
  0086 0e800803     [4]     BRSET 0,SP,#8,*+7 ;abs = 008d
  008a 060000       [3]     JMP   f_open:0x0157
 2295:  			dw = get_fattime();					/* Created time */
  008d 160000       [4]     JSR   get_fattime
  0090 6c85         [2]     STD   5,SP
  0092 6e83         [2]     STX   3,SP
 2296:  			ST_DWORD(dir+DIR_CrtTime, dw);
  0094 ee8b         [3]     LDX   11,SP
  0096 e686         [3]     LDAB  6,SP
  0098 6b0e         [2]     STAB  14,X
  009a 190e         [2]     LEAY  14,X
  009c e685         [3]     LDAB  5,SP
  009e 6b41         [2]     STAB  1,Y
  00a0 e684         [3]     LDAB  4,SP
  00a2 6b42         [2]     STAB  2,Y
  00a4 e683         [3]     LDAB  3,SP
  00a6 6b43         [2]     STAB  3,Y
 2297:  			dir[DIR_Attr] = 0;					/* Reset attribute */
  00a8 690b         [2]     CLR   11,X
 2298:  			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  00aa 69e01c       [3]     CLR   28,X
  00ad 19e01c       [2]     LEAY  28,X
  00b0 c7           [1]     CLRB  
  00b1 87           [1]     CLRA  
  00b2 6c41         [2]     STD   1,Y
  00b4 6b43         [2]     STAB  3,Y
 2299:  			cl = LD_CLUST(dir);					/* Get start cluster */
  00b6 19e014       [2]     LEAY  20,X
  00b9 e641         [3]     LDAB  1,Y
  00bb b710         [1]     TFR   B,A
  00bd c7           [1]     CLRB  
  00be 3b           [2]     PSHD  
  00bf e6e014       [3]     LDAB  20,X
  00c2 160000       [4]     JSR   f_open:0x0211
  00c5 ee8d         [3]     LDX   13,SP
  00c7 19e01a       [2]     LEAY  26,X
  00ca 6c80         [2]     STD   0,SP
  00cc e641         [3]     LDAB  1,Y
  00ce b710         [1]     TFR   B,A
  00d0 c7           [1]     CLRB  
  00d1 3b           [2]     PSHD  
  00d2 e6e01a       [3]     LDAB  26,X
  00d5 160000       [4]     JSR   f_open:0x0211
  00d8 ca00         [1]     ORAB  #0
  00da 8a00         [1]     ORAA  #0
  00dc 6c8d         [2]     STD   13,SP
  00de ec82         [3]     LDD   2,SP
  00e0 6c8b         [2]     STD   11,SP
 2300:  			ST_CLUST(dir, 0);					/* cluster = 0 */
  00e2 69e01a       [3]     CLR   26,X
  00e5 19e01a       [2]     LEAY  26,X
  00e8 6941         [2]     CLR   1,Y
  00ea 69e014       [3]     CLR   20,X
  00ed 1ae014       [2]     LEAX  20,X
  00f0 6901         [2]     CLR   1,X
 2301:  			dj.fs->wflag = 1;
  00f2 eef011       [3]     LDX   17,SP
  00f5 c601         [1]     LDAB  #1
  00f7 6b04         [2]     STAB  4,X
 2302:  			if (cl) {							/* Remove the cluster chain if exist */
  00f9 ec8d         [3]     LDD   13,SP
  00fb 1b84         [2]     LEAS  4,SP
  00fd 2604         [3/1]   BNE   *+6 ;abs = 0103
  00ff ec87         [3]     LDD   7,SP
  0101 2754         [3/1]   BEQ   *+86 ;abs = 0157
 2303:  				dw = dj.fs->winsect;
  0103 ee8d         [3]     LDX   13,SP
  0105 ece02a       [3]     LDD   42,X
  0108 6c83         [2]     STD   3,SP
  010a ece02c       [3]     LDD   44,X
  010d 6c85         [2]     STD   5,SP
 2304:  				res = remove_chain(dj.fs, cl);
  010f 34           [2]     PSHX  
  0110 ec8b         [3]     LDD   11,SP
  0112 ee89         [3]     LDX   9,SP
  0114 160000       [4]     JSR   remove_chain
  0117 1b82         [2]     LEAS  2,SP
  0119 6c81         [2]     STD   1,SP
 2305:  				if (res == FR_OK) {
  011b 263a         [3/1]   BNE   *+60 ;abs = 0157
 2306:  					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  011d ec89         [3]     LDD   9,SP
  011f ee87         [3]     LDX   7,SP
  0121 160000       [4]     JSR   _LDEC
  0124 ed8d         [3]     LDY   13,SP
  0126 6c4c         [2]     STD   12,Y
  0128 6e4a         [2]     STX   10,Y
 2307:  					res = move_window(dj.fs, dw);
  012a ec8d         [3]     LDD   13,SP
  012c 3b           [2]     PSHD  
  012d ec87         [3]     LDD   7,SP
  012f ee85         [3]     LDX   5,SP
  0131 160000       [4]     JSR   move_window
  0134 1b82         [2]     LEAS  2,SP
  0136 201d         [3]     BRA   *+31 ;abs = 0155
 2308:  				}
 2309:  			}
 2310:  		}
 2311:  	}
 2312:  	else {	/* Open an existing file */
 2313:  		if (res == FR_OK) {						/* Follow succeeded */
  0138 ec81         [3]     LDD   1,SP
  013a 261b         [3/1]   BNE   *+29 ;abs = 0157
 2314:  			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  013c ee8b         [3]     LDX   11,SP
  013e 0f0b1008     [4]     BRCLR 11,X,#16,*+12 ;abs = 014a
 2315:  				res = FR_NO_FILE;
  0142 c604         [1]     LDAB  #4
  0144 87           [1]     CLRA  
  0145 6c81         [2]     STD   1,SP
 2316:  			} else {
  0147 060000       [3]     JMP   f_open:0x020b
 2317:  				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  014a 0f800209     [4]     BRCLR 0,SP,#2,*+13 ;abs = 0157
  014e 0f0b0105     [4]     BRCLR 11,X,#1,*+9 ;abs = 0157
 2318:  					res = FR_DENIED;
  0152 c607         [1]     LDAB  #7
  0154 87           [1]     CLRA  
  0155 6c81         [2]     STD   1,SP
 2319:  			}
 2320:  		}
 2321:  	}
 2322:  	if (res == FR_OK) {
  0157 ec81         [3]     LDD   1,SP
  0159 261f         [3/1]   BNE   *+33 ;abs = 017a
 2323:  		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  015b 0f800803     [4]     BRCLR 0,SP,#8,*+7 ;abs = 0162
 2324:  			mode |= FA__WRITTEN;
  015f 0c8020       [4]     BSET  0,SP,#32
 2325:  		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  0162 ee8d         [3]     LDX   13,SP
  0164 ece02a       [3]     LDD   42,X
  0167 b746         [1]     TFR   D,Y
  0169 ece02c       [3]     LDD   44,X
  016c eef033       [3]     LDX   51,SP
  016f 6ce01c       [3]     STD   28,X
  0172 6de01a       [3]     STY   26,X
 2326:  		fp->dir_ptr = dir;
  0175 ec8b         [3]     LDD   11,SP
  0177 6ce01e       [3]     STD   30,X
 2327:  #if _FS_SHARE
 2328:  		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 2329:  		if (!fp->lockid) res = FR_INT_ERR;
 2330:  #endif
 2331:  	}
 2332:  
 2333:  #else				/* R/O configuration */
 2334:  	if (res == FR_OK) {					/* Follow succeeded */
 2335:  		if (!dir) {						/* Current dir itself */
 2336:  			res = FR_INVALID_NAME;
 2337:  		} else {
 2338:  			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
 2339:  				res = FR_NO_FILE;
 2340:  		}
 2341:  	}
 2342:  #endif
 2343:  	FREE_BUF();
 2344:  
 2345:  	if (res == FR_OK) {
  017a ec81         [3]     LDD   1,SP
  017c 26c9         [3/1]   BNE   *-53 ;abs = 0147
 2346:  		fp->flag = mode;					/* File access mode */
  017e eef033       [3]     LDX   51,SP
  0181 e680         [3]     LDAB  0,SP
  0183 6b04         [2]     STAB  4,X
 2347:  		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  0185 ed8b         [3]     LDY   11,SP
  0187 1ae814       [2]     LEAX  20,Y
  018a e601         [3]     LDAB  1,X
  018c b710         [1]     TFR   B,A
  018e c7           [1]     CLRB  
  018f 3b           [2]     PSHD  
  0190 e6e814       [3]     LDAB  20,Y
  0193 077c         [4]     BSR   *+126 ;abs = 0211
  0195 1ae81a       [2]     LEAX  26,Y
  0198 6c80         [2]     STD   0,SP
  019a e601         [3]     LDAB  1,X
  019c b710         [1]     TFR   B,A
  019e c7           [1]     CLRB  
  019f 3b           [2]     PSHD  
  01a0 e6e81a       [3]     LDAB  26,Y
  01a3 076c         [4]     BSR   *+110 ;abs = 0211
  01a5 ca00         [1]     ORAB  #0
  01a7 8a00         [1]     ORAA  #0
  01a9 eef037       [3]     LDX   55,SP
  01ac 6ce010       [3]     STD   16,X
  01af ec82         [3]     LDD   2,SP
  01b1 6c0e         [2]     STD   14,X
 2348:  		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  01b3 1ae81c       [2]     LEAX  28,Y
  01b6 e603         [3]     LDAB  3,X
  01b8 87           [1]     CLRA  
  01b9 6e82         [2]     STX   2,SP
  01bb b781         [1]     EXG   A,B
  01bd c7           [1]     CLRB  
  01be 6c80         [2]     STD   0,SP
  01c0 e602         [3]     LDAB  2,X
  01c2 87           [1]     CLRA  
  01c3 ce0000       [2]     LDX   #0
  01c6 3b           [2]     PSHD  
  01c7 b754         [1]     TFR   X,D
  01c9 ca00         [1]     ORAB  #0
  01cb 8a00         [1]     ORAA  #0
  01cd 3b           [2]     PSHD  
  01ce ec84         [3]     LDD   4,SP
  01d0 ea83         [3]     ORAB  3,SP
  01d2 aa82         [3]     ORAA  2,SP
  01d4 ee86         [3]     LDX   6,SP
  01d6 6c82         [2]     STD   2,SP
  01d8 e601         [3]     LDAB  1,X
  01da b710         [1]     TFR   B,A
  01dc c7           [1]     CLRB  
  01dd ea81         [3]     ORAB  1,SP
  01df aa80         [3]     ORAA  0,SP
  01e1 6c80         [2]     STD   0,SP
  01e3 e6e81c       [3]     LDAB  28,Y
  01e6 0729         [4]     BSR   *+43 ;abs = 0211
  01e8 eef03b       [3]     LDX   59,SP
  01eb 6c0c         [2]     STD   12,X
  01ed ec82         [3]     LDD   2,SP
  01ef 6c0a         [2]     STD   10,X
 2349:  		fp->fptr = 0;						/* File pointer */
  01f1 c7           [1]     CLRB  
  01f2 87           [1]     CLRA  
  01f3 6c06         [2]     STD   6,X
  01f5 6c08         [2]     STD   8,X
 2350:  		fp->dsect = 0;
  01f7 6ce016       [3]     STD   22,X
  01fa 6ce018       [3]     STD   24,X
 2351:  #if _USE_FASTSEEK
 2352:  		fp->cltbl = 0;						/* Normal seek mode */
 2353:  #endif
 2354:  		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  01fd edf015       [3]     LDY   21,SP
  0200 6d00         [2]     STY   0,X
  0202 edf015       [3]     LDY   21,SP
  0205 ec46         [3]     LDD   6,Y
  0207 6c02         [2]     STD   2,X
  0209 1b88         [2]     LEAS  8,SP
 2355:  	}
 2356:  
 2357:  	LEAVE_FF(dj.fs, res);
  020b ec81         [3]     LDD   1,SP
 2358:  }
  020d 1bf02f       [2]     LEAS  47,SP
  0210 3d           [5]     RTS   
  0211 87           [1]     CLRA  
  0212 ea83         [3]     ORAB  3,SP
  0214 aa82         [3]     ORAA  2,SP
  0216 3d           [5]     RTS   
 2359:  
 2360:  
 2361:  
 2362:  
 2363:  /*-----------------------------------------------------------------------*/
 2364:  /* Read File                                                             */
 2365:  /*-----------------------------------------------------------------------*/
 2366:  
 2367:  FRESULT f_read (
 2368:  	FIL *fp, 		/* Pointer to the file object */
 2369:  	void *buff,		/* Pointer to data buffer */
 2370:  	UINT btr,		/* Number of bytes to read */
 2371:  	UINT *br		/* Pointer to number of bytes read */
 2372:  )
 2373:  {
*** EVALUATION ***

Function: f_read
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
  0002 1bf1e9       [2]     LEAS  -23,SP
 2374:  	FRESULT res;
 2375:  	DWORD clst, sect, remain;
 2376:  	UINT rcnt, cc;
 2377:  	BYTE csect, *rbuff = buff;
  0005 ecf01f       [3]     LDD   31,SP
  0008 6c8b         [2]     STD   11,SP
 2378:  
 2379:  
 2380:  	*br = 0;	/* Initialize byte counter */
  000a eef017       [3]     LDX   23,SP
  000d c7           [1]     CLRB  
  000e 87           [1]     CLRA  
  000f 6c00         [2]     STD   0,X
 2381:  
 2382:  	res = validate(fp->fs, fp->id);				/* Check validity */
  0011 eef021       [3]     LDX   33,SP
  0014 ed00         [3]     LDY   0,X
  0016 35           [2]     PSHY  
  0017 ec02         [3]     LDD   2,X
  0019 160000       [4]     JSR   validate
  001c 1b82         [2]     LEAS  2,SP
  001e 6cf019       [3]     STD   25,SP
 2383:  	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  0021 2702         [3/1]   BEQ   *+4 ;abs = 0025
  0023 2011         [3]     BRA   *+19 ;abs = 0036
 2384:  	if (fp->flag & FA__ERROR)					/* Aborted file? */
  0025 eef021       [3]     LDX   33,SP
  0028 0f048003     [4]     BRCLR 4,X,#128,*+7 ;abs = 002f
  002c 060000       [3]     JMP   f_read:0x00f7
 2385:  		LEAVE_FF(fp->fs, FR_INT_ERR);
 2386:  	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  002f 0e040106     [4]     BRSET 4,X,#1,*+10 ;abs = 0039
 2387:  		LEAVE_FF(fp->fs, FR_DENIED);
  0033 c607         [1]     LDAB  #7
  0035 87           [1]     CLRA  
  0036 060000       [3]     JMP   f_read:0x026f
 2388:  	remain = fp->fsize - fp->fptr;
  0039 ec0c         [3]     LDD   12,X
  003b a308         [3]     SUBD  8,X
  003d 6cf013       [3]     STD   19,SP
  0040 ec0a         [3]     LDD   10,X
  0042 e207         [3]     SBCB  7,X
  0044 a206         [3]     SBCA  6,X
  0046 6cf011       [3]     STD   17,SP
 2389:  	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
  0049 1826021b     [4/3]   LBNE  *+543 ;abs = 0268
  004d ecf01d       [3]     LDD   29,SP
  0050 acf013       [3]     CPD   19,SP
  0053 18230211     [4/3]   LBLS  *+533 ;abs = 0268
  0057 ecf013       [3]     LDD   19,SP
  005a 060000       [3]     JMP   f_read:0x0265
 2390:  
 2391:  	for ( ;  btr;								/* Repeat until all data read */
 2392:  		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 2393:  		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  005d eef021       [3]     LDX   33,SP
  0060 ec08         [3]     LDD   8,X
  0062 6c80         [2]     STD   0,SP
  0064 8401         [1]     ANDA  #1
  0066 044403       [3]     TBEQ  D,*+6 ;abs = 006c
  0069 060000       [3]     JMP   f_read:0x0211
 2394:  			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  006c ed00         [3]     LDY   0,X
  006e e642         [3]     LDAB  2,Y
  0070 53           [1]     DECB  
  0071 ee06         [3]     LDX   6,X
  0073 ed80         [3]     LDY   0,SP
  0075 37           [2]     PSHB  
  0076 c609         [1]     LDAB  #9
  0078 6e83         [2]     STX   3,SP
  007a 160000       [4]     JSR   _LSHRU
  007d e480         [3]     ANDB  0,SP
  007f 6b85         [2]     STAB  5,SP
 2395:  			if (!csect) {						/* On the cluster boundary? */
  0081 1b81         [2]     LEAS  1,SP
  0083 2652         [3/1]   BNE   *+84 ;abs = 00d7
 2396:  				if (fp->fptr == 0) {			/* On the top of the file? */
  0085 ec80         [3]     LDD   0,SP
  0087 2612         [3/1]   BNE   *+20 ;abs = 009b
  0089 ec82         [3]     LDD   2,SP
  008b 260e         [3/1]   BNE   *+16 ;abs = 009b
 2397:  					clst = fp->sclust;			/* Follow from the origin */
  008d eef021       [3]     LDX   33,SP
  0090 ec0e         [3]     LDD   14,X
  0092 6c8d         [2]     STD   13,SP
  0094 ece010       [3]     LDD   16,X
  0097 6c8f         [2]     STD   15,SP
 2398:  				} else {						/* Middle or end of the file */
  0099 2015         [3]     BRA   *+23 ;abs = 00b0
 2399:  #if _USE_FASTSEEK
 2400:  					if (fp->cltbl)
 2401:  						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 2402:  					else
 2403:  #endif
 2404:  						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  009b eef021       [3]     LDX   33,SP
  009e ec00         [3]     LDD   0,X
  00a0 3b           [2]     PSHD  
  00a1 ece014       [3]     LDD   20,X
  00a4 eee012       [3]     LDX   18,X
  00a7 160000       [4]     JSR   get_fat
  00aa 1b82         [2]     LEAS  2,SP
  00ac 6c8f         [2]     STD   15,SP
  00ae 6e8d         [2]     STX   13,SP
 2405:  				}
 2406:  				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  00b0 ec8d         [3]     LDD   13,SP
  00b2 2609         [3/1]   BNE   *+11 ;abs = 00bd
  00b4 ec8f         [3]     LDD   15,SP
  00b6 8c0002       [2]     CPD   #2
  00b9 2402         [3/1]   BCC   *+4 ;abs = 00bd
  00bb 2034         [3]     BRA   *+54 ;abs = 00f1
 2407:  				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  00bd ec8f         [3]     LDD   15,SP
  00bf 04a408       [3]     IBNE  D,*+11 ;abs = 00ca
  00c2 ec8d         [3]     LDD   13,SP
  00c4 04a403       [3]     IBNE  D,*+6 ;abs = 00ca
  00c7 060000       [3]     JMP   f_read:0x01f9
 2408:  				fp->clust = clst;				/* Update current cluster */
  00ca eef021       [3]     LDX   33,SP
  00cd ec8d         [3]     LDD   13,SP
  00cf 6ce012       [3]     STD   18,X
  00d2 ec8f         [3]     LDD   15,SP
  00d4 6ce014       [3]     STD   20,X
 2409:  			}
 2410:  			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  00d7 eef021       [3]     LDX   33,SP
  00da ec00         [3]     LDD   0,X
  00dc 3b           [2]     PSHD  
  00dd ece014       [3]     LDD   20,X
  00e0 eee012       [3]     LDX   18,X
  00e3 160000       [4]     JSR   clust2sect
  00e6 1b82         [2]     LEAS  2,SP
  00e8 6c87         [2]     STD   7,SP
  00ea 6e85         [2]     STX   5,SP
 2411:  			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  00ec 04640e       [3]     TBNE  D,*+17 ;abs = 00fd
  00ef 260c         [3/1]   BNE   *+14 ;abs = 00fd
  00f1 eef021       [3]     LDX   33,SP
  00f4 0c0480       [4]     BSET  4,X,#128
  00f7 c602         [1]     LDAB  #2
  00f9 87           [1]     CLRA  
  00fa 060000       [3]     JMP   f_read:0x026f
 2412:  			sect += csect;
  00fd e684         [3]     LDAB  4,SP
  00ff 87           [1]     CLRA  
  0100 b745         [1]     TFR   D,X
  0102 e387         [3]     ADDD  7,SP
  0104 6c87         [2]     STD   7,SP
  0106 cc0000       [2]     LDD   #0
  0109 e986         [3]     ADCB  6,SP
  010b a985         [3]     ADCA  5,SP
  010d 6c85         [2]     STD   5,SP
 2413:  			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
  010f ecf01d       [3]     LDD   29,SP
  0112 b701         [1]     TFR   A,B
  0114 87           [1]     CLRA  
  0115 49           [1]     LSRD  
  0116 6cf015       [3]     STD   21,SP
 2414:  			if (cc) {							/* Read maximum contiguous sectors directly */
  0119 18270088     [4/3]   LBEQ  *+140 ;abs = 01a5
 2415:  				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  011d b754         [1]     TFR   X,D
  011f e3f015       [3]     ADDD  21,SP
  0122 edf021       [3]     LDY   33,SP
  0125 6e80         [2]     STX   0,SP
  0127 ee40         [3]     LDX   0,Y
  0129 b746         [1]     TFR   D,Y
  012b e602         [3]     LDAB  2,X
  012d 87           [1]     CLRA  
  012e 3b           [2]     PSHD  
  012f adb1         [3]     CPY   2,SP+
  0131 2305         [3/1]   BLS   *+7 ;abs = 0138
 2416:  					cc = fp->fs->csize - csect;
  0133 a380         [3]     SUBD  0,SP
  0135 6cf015       [3]     STD   21,SP
 2417:  				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  0138 eef021       [3]     LDX   33,SP
  013b ed00         [3]     LDY   0,X
  013d e641         [3]     LDAB  1,Y
  013f 37           [2]     PSHB  
  0140 ec8c         [3]     LDD   12,SP
  0142 3b           [2]     PSHD  
  0143 ec8a         [3]     LDD   10,SP
  0145 3b           [2]     PSHD  
  0146 ec8a         [3]     LDD   10,SP
  0148 3b           [2]     PSHD  
  0149 e6f01d       [3]     LDAB  29,SP
  014c 160000       [4]     JSR   eDisk_Read
  014f 1b87         [2]     LEAS  7,SP
  0151 044402       [3]     TBEQ  D,*+5 ;abs = 0156
 2418:  					ABORT(fp->fs, FR_DISK_ERR);
  0154 207f         [3]     BRA   *+129 ;abs = 01d5
 2419:  #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
 2420:  #if _FS_TINY
 2421:  				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
 2422:  					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
 2423:  #else
 2424:  				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
  0156 eef021       [3]     LDX   33,SP
  0159 0f04403c     [4]     BRCLR 4,X,#64,*+64 ;abs = 0199
  015d ece018       [3]     LDD   24,X
  0160 a387         [3]     SUBD  7,SP
  0162 3b           [2]     PSHD  
  0163 ece016       [3]     LDD   22,X
  0166 e288         [3]     SBCB  8,SP
  0168 a287         [3]     SBCA  7,SP
  016a edf017       [3]     LDY   23,SP
  016d 35           [2]     PSHY  
  016e b746         [1]     TFR   D,Y
  0170 c7           [1]     CLRB  
  0171 87           [1]     CLRA  
  0172 3b           [2]     PSHD  
  0173 ec84         [3]     LDD   4,SP
  0175 b765         [1]     TFR   Y,X
  0177 160000       [4]     JSR   _LCMP
  017a 1b82         [2]     LEAS  2,SP
  017c 241b         [3/1]   BCC   *+29 ;abs = 0199
 2425:  					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
  017e eef021       [3]     LDX   33,SP
  0181 ece018       [3]     LDD   24,X
  0184 a387         [3]     SUBD  7,SP
  0186 b710         [1]     TFR   B,A
  0188 c7           [1]     CLRB  
  0189 59           [1]     LSLD  
  018a e38b         [3]     ADDD  11,SP
  018c 3b           [2]     PSHD  
  018d 1ae020       [2]     LEAX  32,X
  0190 34           [2]     PSHX  
  0191 8602         [1]     LDAA  #2
  0193 c7           [1]     CLRB  
  0194 160000       [4]     JSR   mem_cpy
  0197 1b84         [2]     LEAS  4,SP
 2426:  #endif
 2427:  #endif
 2428:  				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  0199 ecf015       [3]     LDD   21,SP
  019c b710         [1]     TFR   B,A
  019e c7           [1]     CLRB  
  019f 59           [1]     LSLD  
  01a0 6c89         [2]     STD   9,SP
 2429:  				continue;
  01a2 060000       [3]     JMP   f_read:0x0240
 2430:  			}
 2431:  #if !_FS_TINY
 2432:  			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  01a5 eef021       [3]     LDX   33,SP
  01a8 ece018       [3]     LDD   24,X
  01ab ac87         [3]     CPD   7,SP
  01ad 2607         [3/1]   BNE   *+9 ;abs = 01b6
  01af ece016       [3]     LDD   22,X
  01b2 ac85         [3]     CPD   5,SP
  01b4 274e         [3/1]   BEQ   *+80 ;abs = 0204
 2433:  #if !_FS_READONLY
 2434:  				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  01b6 0f044023     [4]     BRCLR 4,X,#64,*+39 ;abs = 01dd
 2435:  					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  01ba ed00         [3]     LDY   0,X
  01bc e641         [3]     LDAB  1,Y
  01be 37           [2]     PSHB  
  01bf 19e020       [2]     LEAY  32,X
  01c2 35           [2]     PSHY  
  01c3 ece018       [3]     LDD   24,X
  01c6 3b           [2]     PSHD  
  01c7 ece016       [3]     LDD   22,X
  01ca 3b           [2]     PSHD  
  01cb c601         [1]     LDAB  #1
  01cd 160000       [4]     JSR   eDisk_Write
  01d0 1b87         [2]     LEAS  7,SP
  01d2 044402       [3]     TBEQ  D,*+5 ;abs = 01d7
 2436:  						ABORT(fp->fs, FR_DISK_ERR);
  01d5 2022         [3]     BRA   *+36 ;abs = 01f9
 2437:  					fp->flag &= ~FA__DIRTY;
  01d7 eef021       [3]     LDX   33,SP
  01da 0d0440       [4]     BCLR  4,X,#64
 2438:  				}
 2439:  #endif
 2440:  				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  01dd eef021       [3]     LDX   33,SP
  01e0 ed00         [3]     LDY   0,X
  01e2 e641         [3]     LDAB  1,Y
  01e4 37           [2]     PSHB  
  01e5 1ae020       [2]     LEAX  32,X
  01e8 34           [2]     PSHX  
  01e9 ec8a         [3]     LDD   10,SP
  01eb 3b           [2]     PSHD  
  01ec ec8a         [3]     LDD   10,SP
  01ee 3b           [2]     PSHD  
  01ef c601         [1]     LDAB  #1
  01f1 160000       [4]     JSR   eDisk_Read
  01f4 1b87         [2]     LEAS  7,SP
  01f6 04440b       [3]     TBEQ  D,*+14 ;abs = 0204
 2441:  					ABORT(fp->fs, FR_DISK_ERR);
  01f9 eef021       [3]     LDX   33,SP
  01fc 0c0480       [4]     BSET  4,X,#128
  01ff c601         [1]     LDAB  #1
  0201 87           [1]     CLRA  
  0202 206b         [3]     BRA   *+109 ;abs = 026f
 2442:  			}
 2443:  #endif
 2444:  			fp->dsect = sect;
  0204 eef021       [3]     LDX   33,SP
  0207 ec85         [3]     LDD   5,SP
  0209 6ce016       [3]     STD   22,X
  020c ec87         [3]     LDD   7,SP
  020e 6ce018       [3]     STD   24,X
 2445:  		}
 2446:  		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  0211 eef021       [3]     LDX   33,SP
  0214 ec08         [3]     LDD   8,X
  0216 8401         [1]     ANDA  #1
  0218 3b           [2]     PSHD  
  0219 8602         [1]     LDAA  #2
  021b c7           [1]     CLRB  
  021c a380         [3]     SUBD  0,SP
  021e 6c8b         [2]     STD   11,SP
 2447:  		if (rcnt > btr) rcnt = btr;
  0220 acf01f       [3]     CPD   31,SP
  0223 1b82         [2]     LEAS  2,SP
  0225 2305         [3/1]   BLS   *+7 ;abs = 022c
  0227 ecf01d       [3]     LDD   29,SP
  022a 6c89         [2]     STD   9,SP
 2448:  #if _FS_TINY
 2449:  		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
 2450:  			ABORT(fp->fs, FR_DISK_ERR);
 2451:  		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 2452:  #else
 2453:  		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  022c ec8b         [3]     LDD   11,SP
  022e 3b           [2]     PSHD  
  022f ec08         [3]     LDD   8,X
  0231 8401         [1]     ANDA  #1
  0233 1ae020       [2]     LEAX  32,X
  0236 1ae6         [2]     LEAX  D,X
  0238 34           [2]     PSHX  
  0239 ec8d         [3]     LDD   13,SP
  023b 160000       [4]     JSR   mem_cpy
  023e 1b84         [2]     LEAS  4,SP
  0240 ec8b         [3]     LDD   11,SP
  0242 e389         [3]     ADDD  9,SP
  0244 6c8b         [2]     STD   11,SP
  0246 eef021       [3]     LDX   33,SP
  0249 ec89         [3]     LDD   9,SP
  024b e308         [3]     ADDD  8,X
  024d 6c08         [2]     STD   8,X
  024f ec06         [3]     LDD   6,X
  0251 c900         [1]     ADCB  #0
  0253 8900         [1]     ADCA  #0
  0255 6c06         [2]     STD   6,X
  0257 eef017       [3]     LDX   23,SP
  025a ec89         [3]     LDD   9,SP
  025c e300         [3]     ADDD  0,X
  025e 6c00         [2]     STD   0,X
  0260 ecf01d       [3]     LDD   29,SP
  0263 a389         [3]     SUBD  9,SP
  0265 6cf01d       [3]     STD   29,SP
  0268 ecf01d       [3]     LDD   29,SP
  026b 1826fdee     [4/3]   LBNE  *-526 ;abs = 005d
 2454:  #endif
 2455:  	}
 2456:  
 2457:  	LEAVE_FF(fp->fs, FR_OK);
 2458:  }
  026f 1bf01b       [2]     LEAS  27,SP
  0272 3d           [5]     RTS   
 2459:  
 2460:  
 2461:  
 2462:  
 2463:  #if !_FS_READONLY
 2464:  /*-----------------------------------------------------------------------*/
 2465:  /* Write File                                                            */
 2466:  /*-----------------------------------------------------------------------*/
 2467:  
 2468:  FRESULT f_write (
 2469:  	FIL *fp,			/* Pointer to the file object */
 2470:  	const void *buff,	/* Pointer to the data to be written */
 2471:  	UINT btw,			/* Number of bytes to write */
 2472:  	UINT *bw			/* Pointer to number of bytes written */
 2473:  )
 2474:  {
*** EVALUATION ***

Function: f_write
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
  0002 1bf1eb       [2]     LEAS  -21,SP
 2475:  	FRESULT res;
 2476:  	DWORD clst, sect;
 2477:  	UINT wcnt, cc;
 2478:  	const BYTE *wbuff = buff;
  0005 ecf01d       [3]     LDD   29,SP
  0008 6cf012       [3]     STD   18,SP
 2479:  	BYTE csect;
 2480:  
 2481:  
 2482:  	*bw = 0;	/* Initialize byte counter */
  000b eef015       [3]     LDX   21,SP
  000e c7           [1]     CLRB  
  000f 87           [1]     CLRA  
  0010 6c00         [2]     STD   0,X
 2483:  
 2484:  	res = validate(fp->fs, fp->id);			/* Check validity */
  0012 edf01f       [3]     LDY   31,SP
  0015 ee40         [3]     LDX   0,Y
  0017 34           [2]     PSHX  
  0018 ec42         [3]     LDD   2,Y
  001a 160000       [4]     JSR   validate
  001d 1b82         [2]     LEAS  2,SP
  001f 6cf017       [3]     STD   23,SP
 2485:  	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  0022 2703         [3/1]   BEQ   *+5 ;abs = 0027
  0024 060000       [3]     JMP   f_write:0x02cb
 2486:  	if (fp->flag & FA__ERROR)				/* Aborted file? */
  0027 eef01f       [3]     LDX   31,SP
  002a 0f048003     [4]     BRCLR 4,X,#128,*+7 ;abs = 0031
  002e 060000       [3]     JMP   f_write:0x0146
 2487:  		LEAVE_FF(fp->fs, FR_INT_ERR);
 2488:  	if (!(fp->flag & FA_WRITE))				/* Check access mode */
  0031 0e040205     [4]     BRSET 4,X,#2,*+9 ;abs = 003a
 2489:  		LEAVE_FF(fp->fs, FR_DENIED);
  0035 c607         [1]     LDAB  #7
  0037 060000       [3]     JMP   f_write:0x02ca
 2490:  	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
  003a ecf01b       [3]     LDD   27,SP
  003d e30c         [3]     ADDD  12,X
  003f 3b           [2]     PSHD  
  0040 ec0a         [3]     LDD   10,X
  0042 c900         [1]     ADCB  #0
  0044 8900         [1]     ADCA  #0
  0046 1a0a         [2]     LEAX  10,X
  0048 3b           [2]     PSHD  
  0049 ec82         [3]     LDD   2,SP
  004b b756         [1]     TFR   X,Y
  004d 30           [3]     PULX  
  004e 160000       [4]     JSR   _LCMP_P
  0051 1b82         [2]     LEAS  2,SP
  0053 18240251     [4/3]   LBCC  *+597 ;abs = 02a8
  0057 060000       [3]     JMP   f_write:0x02af
 2491:  
 2492:  	for ( ;  btw;							/* Repeat until all data written */
 2493:  		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 2494:  		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
  005a eef01f       [3]     LDX   31,SP
  005d ec08         [3]     LDD   8,X
  005f 6c80         [2]     STD   0,SP
  0061 8401         [1]     ANDA  #1
  0063 044403       [3]     TBEQ  D,*+6 ;abs = 0069
  0066 060000       [3]     JMP   f_write:0x0248
 2495:  			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  0069 ed00         [3]     LDY   0,X
  006b e642         [3]     LDAB  2,Y
  006d 53           [1]     DECB  
  006e ee06         [3]     LDX   6,X
  0070 6d82         [2]     STY   2,SP
  0072 ed80         [3]     LDY   0,SP
  0074 37           [2]     PSHB  
  0075 c609         [1]     LDAB  #9
  0077 6e85         [2]     STX   5,SP
  0079 160000       [4]     JSR   _LSHRU
  007c e480         [3]     ANDB  0,SP
  007e 6bf015       [3]     STAB  21,SP
 2496:  			if (!csect) {					/* On the cluster boundary? */
  0081 1b81         [2]     LEAS  1,SP
  0083 2676         [3/1]   BNE   *+120 ;abs = 00fb
 2497:  				if (fp->fptr == 0) {		/* On the top of the file? */
  0085 ec80         [3]     LDD   0,SP
  0087 262f         [3/1]   BNE   *+49 ;abs = 00b8
  0089 ec84         [3]     LDD   4,SP
  008b 262b         [3/1]   BNE   *+45 ;abs = 00b8
 2498:  					clst = fp->sclust;		/* Follow from the origin */
  008d eef01f       [3]     LDX   31,SP
  0090 ec0e         [3]     LDD   14,X
  0092 6c8c         [2]     STD   12,SP
  0094 ece010       [3]     LDD   16,X
  0097 6c8e         [2]     STD   14,SP
 2499:  					if (clst == 0)			/* When no cluster is allocated, */
  0099 2632         [3/1]   BNE   *+52 ;abs = 00cd
  009b ec8c         [3]     LDD   12,SP
  009d 262e         [3/1]   BNE   *+48 ;abs = 00cd
 2500:  						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
  009f ec82         [3]     LDD   2,SP
  00a1 3b           [2]     PSHD  
  00a2 b764         [1]     TFR   Y,D
  00a4 b765         [1]     TFR   Y,X
  00a6 160000       [4]     JSR   create_chain
  00a9 31           [3]     PULY  
  00aa 6c8e         [2]     STD   14,SP
  00ac 6e8c         [2]     STX   12,SP
  00ae edf01f       [3]     LDY   31,SP
  00b1 6e4e         [2]     STX   14,Y
  00b3 6ce810       [3]     STD   16,Y
  00b6 2015         [3]     BRA   *+23 ;abs = 00cd
 2501:  				} else {					/* Middle or end of the file */
 2502:  #if _USE_FASTSEEK
 2503:  					if (fp->cltbl)
 2504:  						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 2505:  					else
 2506:  #endif
 2507:  						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  00b8 eef01f       [3]     LDX   31,SP
  00bb ec00         [3]     LDD   0,X
  00bd 3b           [2]     PSHD  
  00be ece014       [3]     LDD   20,X
  00c1 eee012       [3]     LDX   18,X
  00c4 160000       [4]     JSR   create_chain
  00c7 1b82         [2]     LEAS  2,SP
  00c9 6c8e         [2]     STD   14,SP
  00cb 6e8c         [2]     STX   12,SP
 2508:  				}
 2509:  				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  00cd ec8e         [3]     LDD   14,SP
  00cf 2606         [3/1]   BNE   *+8 ;abs = 00d7
  00d1 ec8c         [3]     LDD   12,SP
  00d3 182701d8     [4/3]   LBEQ  *+476 ;abs = 02af
 2510:  				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  00d7 ec8e         [3]     LDD   14,SP
  00d9 042406       [3]     DBNE  D,*+9 ;abs = 00e2
  00dc ec8c         [3]     LDD   12,SP
  00de 2602         [3/1]   BNE   *+4 ;abs = 00e2
  00e0 205e         [3]     BRA   *+96 ;abs = 0140
 2511:  				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  00e2 ec8e         [3]     LDD   14,SP
  00e4 04a407       [3]     IBNE  D,*+10 ;abs = 00ee
  00e7 ec8c         [3]     LDD   12,SP
  00e9 04a402       [3]     IBNE  D,*+5 ;abs = 00ee
  00ec 202f         [3]     BRA   *+49 ;abs = 011d
 2512:  				fp->clust = clst;			/* Update current cluster */
  00ee eef01f       [3]     LDX   31,SP
  00f1 ec8c         [3]     LDD   12,SP
  00f3 6ce012       [3]     STD   18,X
  00f6 ec8e         [3]     LDD   14,SP
  00f8 6ce014       [3]     STD   20,X
 2513:  			}
 2514:  #if _FS_TINY
 2515:  			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
 2516:  				ABORT(fp->fs, FR_DISK_ERR);
 2517:  #else
 2518:  			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
  00fb eef01f       [3]     LDX   31,SP
  00fe 0f044024     [4]     BRCLR 4,X,#64,*+40 ;abs = 0126
 2519:  				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  0102 ed00         [3]     LDY   0,X
  0104 e641         [3]     LDAB  1,Y
  0106 37           [2]     PSHB  
  0107 19e020       [2]     LEAY  32,X
  010a 35           [2]     PSHY  
  010b ece018       [3]     LDD   24,X
  010e 3b           [2]     PSHD  
  010f ece016       [3]     LDD   22,X
  0112 3b           [2]     PSHD  
  0113 c601         [1]     LDAB  #1
  0115 160000       [4]     JSR   eDisk_Write
  0118 1b87         [2]     LEAS  7,SP
  011a 044403       [3]     TBEQ  D,*+6 ;abs = 0120
 2520:  					ABORT(fp->fs, FR_DISK_ERR);
  011d 060000       [3]     JMP   f_write:0x0230
 2521:  				fp->flag &= ~FA__DIRTY;
  0120 eef01f       [3]     LDX   31,SP
  0123 0d0440       [4]     BCLR  4,X,#64
 2522:  			}
 2523:  #endif
 2524:  			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
  0126 eef01f       [3]     LDX   31,SP
  0129 ec00         [3]     LDD   0,X
  012b 3b           [2]     PSHD  
  012c ece014       [3]     LDD   20,X
  012f eee012       [3]     LDX   18,X
  0132 160000       [4]     JSR   clust2sect
  0135 1b82         [2]     LEAS  2,SP
  0137 6c8a         [2]     STD   10,SP
  0139 6e88         [2]     STX   8,SP
 2525:  			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  013b 04640d       [3]     TBNE  D,*+16 ;abs = 014b
  013e 260b         [3/1]   BNE   *+13 ;abs = 014b
  0140 eef01f       [3]     LDX   31,SP
  0143 0c0480       [4]     BSET  4,X,#128
  0146 c602         [1]     LDAB  #2
  0148 060000       [3]     JMP   f_write:0x02ca
 2526:  			sect += csect;
  014b e6f014       [3]     LDAB  20,SP
  014e 87           [1]     CLRA  
  014f b745         [1]     TFR   D,X
  0151 e38a         [3]     ADDD  10,SP
  0153 6c8a         [2]     STD   10,SP
  0155 cc0000       [2]     LDD   #0
  0158 e989         [3]     ADCB  9,SP
  015a a988         [3]     ADCA  8,SP
  015c 6c88         [2]     STD   8,SP
 2527:  			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
  015e ecf01b       [3]     LDD   27,SP
  0161 b701         [1]     TFR   A,B
  0163 87           [1]     CLRA  
  0164 49           [1]     LSRD  
  0165 6cf010       [3]     STD   16,SP
 2528:  			if (cc) {						/* Write maximum contiguous sectors directly */
  0168 1827008d     [4/3]   LBEQ  *+145 ;abs = 01f9
 2529:  				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  016c b754         [1]     TFR   X,D
  016e e3f010       [3]     ADDD  16,SP
  0171 edf01f       [3]     LDY   31,SP
  0174 6e80         [2]     STX   0,SP
  0176 ee40         [3]     LDX   0,Y
  0178 b746         [1]     TFR   D,Y
  017a e602         [3]     LDAB  2,X
  017c 87           [1]     CLRA  
  017d 3b           [2]     PSHD  
  017e adb1         [3]     CPY   2,SP+
  0180 2305         [3/1]   BLS   *+7 ;abs = 0187
 2530:  					cc = fp->fs->csize - csect;
  0182 a380         [3]     SUBD  0,SP
  0184 6cf010       [3]     STD   16,SP
 2531:  				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
  0187 eef01f       [3]     LDX   31,SP
  018a ed00         [3]     LDY   0,X
  018c e641         [3]     LDAB  1,Y
  018e 37           [2]     PSHB  
  018f ecf013       [3]     LDD   19,SP
  0192 3b           [2]     PSHD  
  0193 ec8d         [3]     LDD   13,SP
  0195 3b           [2]     PSHD  
  0196 ec8d         [3]     LDD   13,SP
  0198 3b           [2]     PSHD  
  0199 e6f018       [3]     LDAB  24,SP
  019c 160000       [4]     JSR   eDisk_Write
  019f 1b87         [2]     LEAS  7,SP
  01a1 044403       [3]     TBEQ  D,*+6 ;abs = 01a7
 2532:  					ABORT(fp->fs, FR_DISK_ERR);
  01a4 060000       [3]     JMP   f_write:0x0230
 2533:  #if _FS_TINY
 2534:  				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
 2535:  					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
 2536:  					fp->fs->wflag = 0;
 2537:  				}
 2538:  #else
 2539:  				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
  01a7 eef01f       [3]     LDX   31,SP
  01aa ece018       [3]     LDD   24,X
  01ad a38a         [3]     SUBD  10,SP
  01af 3b           [2]     PSHD  
  01b0 ece016       [3]     LDD   22,X
  01b3 e28b         [3]     SBCB  11,SP
  01b5 a28a         [3]     SBCA  10,SP
  01b7 edf012       [3]     LDY   18,SP
  01ba 35           [2]     PSHY  
  01bb b746         [1]     TFR   D,Y
  01bd c7           [1]     CLRB  
  01be 87           [1]     CLRA  
  01bf 3b           [2]     PSHD  
  01c0 ec84         [3]     LDD   4,SP
  01c2 b765         [1]     TFR   Y,X
  01c4 160000       [4]     JSR   _LCMP
  01c7 1b82         [2]     LEAS  2,SP
  01c9 2422         [3/1]   BCC   *+36 ;abs = 01ed
 2540:  					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
  01cb eef01f       [3]     LDX   31,SP
  01ce 19e020       [2]     LEAY  32,X
  01d1 35           [2]     PSHY  
  01d2 ece018       [3]     LDD   24,X
  01d5 a38c         [3]     SUBD  12,SP
  01d7 b710         [1]     TFR   B,A
  01d9 c7           [1]     CLRB  
  01da 59           [1]     LSLD  
  01db e3f014       [3]     ADDD  20,SP
  01de 3b           [2]     PSHD  
  01df 8602         [1]     LDAA  #2
  01e1 c7           [1]     CLRB  
  01e2 160000       [4]     JSR   mem_cpy
  01e5 1b84         [2]     LEAS  4,SP
 2541:  					fp->flag &= ~FA__DIRTY;
  01e7 eef01f       [3]     LDX   31,SP
  01ea 0d0440       [4]     BCLR  4,X,#64
 2542:  				}
 2543:  #endif
 2544:  				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
  01ed ecf010       [3]     LDD   16,SP
  01f0 b710         [1]     TFR   B,A
  01f2 c7           [1]     CLRB  
  01f3 59           [1]     LSLD  
  01f4 6c86         [2]     STD   6,SP
 2545:  				continue;
  01f6 060000       [3]     JMP   f_write:0x027e
 2546:  			}
 2547:  #if _FS_TINY
 2548:  			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
 2549:  				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
 2550:  				fp->fs->winsect = sect;
 2551:  			}
 2552:  #else
 2553:  			if (fp->dsect != sect) {		/* Fill sector cache with file data */
  01f9 eef01f       [3]     LDX   31,SP
  01fc ece018       [3]     LDD   24,X
  01ff ac8a         [3]     CPD   10,SP
  0201 2607         [3/1]   BNE   *+9 ;abs = 020a
  0203 ece016       [3]     LDD   22,X
  0206 ac88         [3]     CPD   8,SP
  0208 2731         [3/1]   BEQ   *+51 ;abs = 023b
 2554:  				if (fp->fptr < fp->fsize &&
  020a ee06         [3]     LDX   6,X
  020c edf01f       [3]     LDY   31,SP
  020f 160000       [4]     JSR   f_write:0x02cf
  0212 2427         [3/1]   BCC   *+41 ;abs = 023b
 2555:  					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
  0214 eef01f       [3]     LDX   31,SP
  0217 ed00         [3]     LDY   0,X
  0219 e641         [3]     LDAB  1,Y
  021b 37           [2]     PSHB  
  021c 1ae020       [2]     LEAX  32,X
  021f 34           [2]     PSHX  
  0220 ec8d         [3]     LDD   13,SP
  0222 3b           [2]     PSHD  
  0223 ec8d         [3]     LDD   13,SP
  0225 3b           [2]     PSHD  
  0226 c601         [1]     LDAB  #1
  0228 160000       [4]     JSR   eDisk_Read
  022b 1b87         [2]     LEAS  7,SP
  022d 04440b       [3]     TBEQ  D,*+14 ;abs = 023b
 2556:  						ABORT(fp->fs, FR_DISK_ERR);
  0230 eef01f       [3]     LDX   31,SP
  0233 0c0480       [4]     BSET  4,X,#128
  0236 c601         [1]     LDAB  #1
  0238 060000       [3]     JMP   f_write:0x02ca
 2557:  			}
 2558:  #endif
 2559:  			fp->dsect = sect;
  023b eef01f       [3]     LDX   31,SP
  023e ec88         [3]     LDD   8,SP
  0240 6ce016       [3]     STD   22,X
  0243 ec8a         [3]     LDD   10,SP
  0245 6ce018       [3]     STD   24,X
 2560:  		}
 2561:  		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
  0248 eef01f       [3]     LDX   31,SP
  024b ec08         [3]     LDD   8,X
  024d 8401         [1]     ANDA  #1
  024f 3b           [2]     PSHD  
  0250 8602         [1]     LDAA  #2
  0252 c7           [1]     CLRB  
  0253 a380         [3]     SUBD  0,SP
  0255 6c88         [2]     STD   8,SP
 2562:  		if (wcnt > btw) wcnt = btw;
  0257 acf01d       [3]     CPD   29,SP
  025a 1b82         [2]     LEAS  2,SP
  025c 2305         [3/1]   BLS   *+7 ;abs = 0263
  025e ecf01b       [3]     LDD   27,SP
  0261 6c86         [2]     STD   6,SP
 2563:  #if _FS_TINY
 2564:  		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
 2565:  			ABORT(fp->fs, FR_DISK_ERR);
 2566:  		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 2567:  		fp->fs->wflag = 1;
 2568:  #else
 2569:  		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
  0263 ec08         [3]     LDD   8,X
  0265 8401         [1]     ANDA  #1
  0267 1ae020       [2]     LEAX  32,X
  026a 1ae6         [2]     LEAX  D,X
  026c 34           [2]     PSHX  
  026d ecf014       [3]     LDD   20,SP
  0270 3b           [2]     PSHD  
  0271 ec8a         [3]     LDD   10,SP
  0273 160000       [4]     JSR   mem_cpy
  0276 1b84         [2]     LEAS  4,SP
 2570:  		fp->flag |= FA__DIRTY;
  0278 eef01f       [3]     LDX   31,SP
  027b 0c0440       [4]     BSET  4,X,#64
  027e ecf012       [3]     LDD   18,SP
  0281 e386         [3]     ADDD  6,SP
  0283 6cf012       [3]     STD   18,SP
  0286 eef01f       [3]     LDX   31,SP
  0289 ec86         [3]     LDD   6,SP
  028b e308         [3]     ADDD  8,X
  028d 6c08         [2]     STD   8,X
  028f ec06         [3]     LDD   6,X
  0291 c900         [1]     ADCB  #0
  0293 8900         [1]     ADCA  #0
  0295 6c06         [2]     STD   6,X
  0297 eef015       [3]     LDX   21,SP
  029a ec86         [3]     LDD   6,SP
  029c e300         [3]     ADDD  0,X
  029e 6c00         [2]     STD   0,X
  02a0 ecf01b       [3]     LDD   27,SP
  02a3 a386         [3]     SUBD  6,SP
  02a5 6cf01b       [3]     STD   27,SP
  02a8 ecf01b       [3]     LDD   27,SP
  02ab 1826fdab     [4/3]   LBNE  *-593 ;abs = 005a
 2571:  #endif
 2572:  	}
 2573:  
 2574:  	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
  02af edf01f       [3]     LDY   31,SP
  02b2 ee46         [3]     LDX   6,Y
  02b4 0719         [4]     BSR   *+27 ;abs = 02cf
  02b6 230b         [3/1]   BLS   *+13 ;abs = 02c3
  02b8 eef01f       [3]     LDX   31,SP
  02bb ec06         [3]     LDD   6,X
  02bd 6c0a         [2]     STD   10,X
  02bf ec08         [3]     LDD   8,X
  02c1 6c0c         [2]     STD   12,X
 2575:  	fp->flag |= FA__WRITTEN;						/* Set file change flag */
  02c3 eef01f       [3]     LDX   31,SP
  02c6 0c0420       [4]     BSET  4,X,#32
 2576:  
 2577:  	LEAVE_FF(fp->fs, FR_OK);
  02c9 c7           [1]     CLRB  
  02ca 87           [1]     CLRA  
 2578:  }
  02cb 1bf019       [2]     LEAS  25,SP
  02ce 3d           [5]     RTS   
  02cf ec48         [3]     LDD   8,Y
  02d1 34           [2]     PSHX  
  02d2 1a4a         [2]     LEAX  10,Y
  02d4 34           [2]     PSHX  
  02d5 ee82         [3]     LDX   2,SP
  02d7 31           [3]     PULY  
  02d8 160000       [4]     JSR   _LCMP_P
  02db 1b82         [2]     LEAS  2,SP
  02dd 3d           [5]     RTS   
 2579:  
 2580:  
 2581:  
 2582:  
 2583:  /*-----------------------------------------------------------------------*/
 2584:  /* Synchronize the File Object                                           */
 2585:  /*-----------------------------------------------------------------------*/
 2586:  
 2587:  FRESULT f_sync (
 2588:  	FIL *fp		/* Pointer to the file object */
 2589:  )
 2590:  {
*** EVALUATION ***

Function: f_sync
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca8         [2]     STD   8,-SP
 2591:  	FRESULT res;
 2592:  	DWORD tim;
 2593:  	BYTE *dir;
 2594:  
 2595:  
 2596:  	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  0002 b745         [1]     TFR   D,X
  0004 ed00         [3]     LDY   0,X
  0006 35           [2]     PSHY  
  0007 ec02         [3]     LDD   2,X
  0009 160000       [4]     JSR   validate
  000c 1b82         [2]     LEAS  2,SP
  000e 6c86         [2]     STD   6,SP
 2597:  	if (res == FR_OK) {
  0010 2643         [3/1]   BNE   *+69 ;abs = 0055
 2598:  		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  0012 ee80         [3]     LDX   0,SP
  0014 0e042003     [4]     BRSET 4,X,#32,*+7 ;abs = 001b
  0018 060000       [3]     JMP   f_sync:0x00de
 2599:  #if !_FS_TINY	/* Write-back dirty buffer */
 2600:  			if (fp->flag & FA__DIRTY) {
  001b 0f044026     [4]     BRCLR 4,X,#64,*+42 ;abs = 0045
 2601:  				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  001f ed00         [3]     LDY   0,X
  0021 e641         [3]     LDAB  1,Y
  0023 37           [2]     PSHB  
  0024 19e020       [2]     LEAY  32,X
  0027 35           [2]     PSHY  
  0028 ece018       [3]     LDD   24,X
  002b 3b           [2]     PSHD  
  002c ece016       [3]     LDD   22,X
  002f 3b           [2]     PSHD  
  0030 c601         [1]     LDAB  #1
  0032 160000       [4]     JSR   eDisk_Write
  0035 1b87         [2]     LEAS  7,SP
  0037 044406       [3]     TBEQ  D,*+9 ;abs = 0040
 2602:  					LEAVE_FF(fp->fs, FR_DISK_ERR);
  003a c601         [1]     LDAB  #1
  003c 87           [1]     CLRA  
  003d 060000       [3]     JMP   f_sync:0x00e0
 2603:  				fp->flag &= ~FA__DIRTY;
  0040 ee80         [3]     LDX   0,SP
  0042 0d0440       [4]     BCLR  4,X,#64
 2604:  			}
 2605:  #endif
 2606:  			/* Update the directory entry */
 2607:  			res = move_window(fp->fs, fp->dir_sect);
  0045 ec00         [3]     LDD   0,X
  0047 3b           [2]     PSHD  
  0048 ece01c       [3]     LDD   28,X
  004b eee01a       [3]     LDX   26,X
  004e 160000       [4]     JSR   move_window
  0051 1b82         [2]     LEAS  2,SP
  0053 6c86         [2]     STD   6,SP
 2608:  			if (res == FR_OK) {
  0055 18260085     [4/3]   LBNE  *+137 ;abs = 00de
 2609:  				dir = fp->dir_ptr;
  0059 ee80         [3]     LDX   0,SP
  005b ede01e       [3]     LDY   30,X
 2610:  				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  005e 0c4b20       [4]     BSET  11,Y,#32
 2611:  				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  0061 ee80         [3]     LDX   0,SP
  0063 e60d         [3]     LDAB  13,X
  0065 6be81c       [3]     STAB  28,Y
  0068 1ae81c       [2]     LEAX  28,Y
  006b 34           [2]     PSHX  
  006c ee82         [3]     LDX   2,SP
  006e e60c         [3]     LDAB  12,X
  0070 ee80         [3]     LDX   0,SP
  0072 6b01         [2]     STAB  1,X
  0074 ee82         [3]     LDX   2,SP
  0076 1a0a         [2]     LEAX  10,X
  0078 e601         [3]     LDAB  1,X
  007a ee80         [3]     LDX   0,SP
  007c 6b02         [2]     STAB  2,X
  007e ee82         [3]     LDX   2,SP
  0080 e60a         [3]     LDAB  10,X
  0082 30           [3]     PULX  
  0083 6b03         [2]     STAB  3,X
 2612:  				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  0085 ee80         [3]     LDX   0,SP
  0087 e6e011       [3]     LDAB  17,X
  008a 6be81a       [3]     STAB  26,Y
  008d 1ae81a       [2]     LEAX  26,Y
  0090 34           [2]     PSHX  
  0091 ee82         [3]     LDX   2,SP
  0093 e6e010       [3]     LDAB  16,X
  0096 30           [3]     PULX  
  0097 6b01         [2]     STAB  1,X
  0099 ee80         [3]     LDX   0,SP
  009b 1a0e         [2]     LEAX  14,X
  009d e601         [3]     LDAB  1,X
  009f 6be814       [3]     STAB  20,Y
  00a2 1ae814       [2]     LEAX  20,Y
  00a5 34           [2]     PSHX  
  00a6 ee82         [3]     LDX   2,SP
  00a8 e60e         [3]     LDAB  14,X
  00aa 30           [3]     PULX  
  00ab 6b01         [2]     STAB  1,X
 2613:  				tim = get_fattime();						/* Update updated time */
  00ad 35           [2]     PSHY  
  00ae 160000       [4]     JSR   get_fattime
  00b1 6c86         [2]     STD   6,SP
  00b3 6e84         [2]     STX   4,SP
 2614:  				ST_DWORD(dir+DIR_WrtTime, tim);
  00b5 e687         [3]     LDAB  7,SP
  00b7 30           [3]     PULX  
  00b8 6be016       [3]     STAB  22,X
  00bb 1ae016       [2]     LEAX  22,X
  00be e684         [3]     LDAB  4,SP
  00c0 6b01         [2]     STAB  1,X
  00c2 e683         [3]     LDAB  3,SP
  00c4 6b02         [2]     STAB  2,X
  00c6 e682         [3]     LDAB  2,SP
  00c8 6b03         [2]     STAB  3,X
 2615:  				fp->flag &= ~FA__WRITTEN;
  00ca ee80         [3]     LDX   0,SP
  00cc 0d0420       [4]     BCLR  4,X,#32
 2616:  				fp->fs->wflag = 1;
  00cf ed00         [3]     LDY   0,X
  00d1 c601         [1]     LDAB  #1
  00d3 6b44         [2]     STAB  4,Y
 2617:  				res = sync(fp->fs);
  00d5 ee80         [3]     LDX   0,SP
  00d7 ec00         [3]     LDD   0,X
  00d9 160000       [4]     JSR   sync
  00dc 6c86         [2]     STD   6,SP
 2618:  			}
 2619:  		}
 2620:  	}
 2621:  
 2622:  	LEAVE_FF(fp->fs, res);
  00de ec86         [3]     LDD   6,SP
 2623:  }
  00e0 1b88         [2]     LEAS  8,SP
  00e2 3d           [5]     RTS   
 2624:  
 2625:  #endif /* !_FS_READONLY */
 2626:  
 2627:  
 2628:  
 2629:  
 2630:  /*-----------------------------------------------------------------------*/
 2631:  /* Close File                                                            */
 2632:  /*-----------------------------------------------------------------------*/
 2633:  
 2634:  FRESULT f_close (
 2635:  	FIL *fp		/* Pointer to the file object to be closed */
 2636:  )
 2637:  {
*** EVALUATION ***

Function: f_close
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6cac         [2]     STD   4,-SP
 2638:  	FRESULT res;
 2639:  
 2640:  #if _FS_READONLY
 2641:  	FATFS *fs = fp->fs;
 2642:  	res = validate(fs, fp->id);
 2643:  	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 2644:  	LEAVE_FF(fs, res);
 2645:  
 2646:  #else
 2647:  	res = f_sync(fp);		/* Flush cached data */
  0002 160000       [4]     JSR   f_sync
  0005 6c82         [2]     STD   2,SP
 2648:  #if _FS_SHARE
 2649:  	if (res == FR_OK) {		/* Decrement open counter */
 2650:  #if _FS_REENTRANT
 2651:  		res = validate(fp->fs, fp->id);
 2652:  		if (res == FR_OK) {
 2653:  			res = dec_lock(fp->lockid);	
 2654:  			unlock_fs(fp->fs, FR_OK);
 2655:  		}
 2656:  #else
 2657:  		res = dec_lock(fp->lockid);
 2658:  #endif
 2659:  	}
 2660:  #endif
 2661:  	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  0007 2606         [3/1]   BNE   *+8 ;abs = 000f
  0009 ee80         [3]     LDX   0,SP
  000b c7           [1]     CLRB  
  000c 87           [1]     CLRA  
  000d 6c00         [2]     STD   0,X
 2662:  	return res;
  000f ec82         [3]     LDD   2,SP
 2663:  #endif
 2664:  }
  0011 1b84         [2]     LEAS  4,SP
  0013 3d           [5]     RTS   
 2665:  
 2666:  
 2667:  
 2668:  
 2669:  /*-----------------------------------------------------------------------*/
 2670:  /* Current Drive/Directory Handlings                                     */
 2671:  /*-----------------------------------------------------------------------*/
 2672:  
 2673:  #if _FS_RPATH >= 1
 2674:  
 2675:  FRESULT f_chdrive (
 2676:  	BYTE drv		/* Drive number */
 2677:  )
 2678:  {
 2679:  	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 2680:  
 2681:  	CurrVol = drv;
 2682:  
 2683:  	return FR_OK;
 2684:  }
 2685:  
 2686:  
 2687:  
 2688:  FRESULT f_chdir (
 2689:  	const TCHAR *path	/* Pointer to the directory path */
 2690:  )
 2691:  {
 2692:  	FRESULT res;
 2693:  	DIR dj;
 2694:  	DEF_NAMEBUF;
 2695:  
 2696:  
 2697:  	res = chk_mounted(&path, &dj.fs, 0);
 2698:  	if (res == FR_OK) {
 2699:  		INIT_BUF(dj);
 2700:  		res = follow_path(&dj, path);		/* Follow the path */
 2701:  		FREE_BUF();
 2702:  		if (res == FR_OK) {					/* Follow completed */
 2703:  			if (!dj.dir) {
 2704:  				dj.fs->cdir = dj.sclust;	/* Start directory itself */
 2705:  			} else {
 2706:  				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
 2707:  					dj.fs->cdir = LD_CLUST(dj.dir);
 2708:  				else
 2709:  					res = FR_NO_PATH;		/* Reached but a file */
 2710:  			}
 2711:  		}
 2712:  		if (res == FR_NO_FILE) res = FR_NO_PATH;
 2713:  	}
 2714:  
 2715:  	LEAVE_FF(dj.fs, res);
 2716:  }
 2717:  
 2718:  
 2719:  #if _FS_RPATH >= 2
 2720:  FRESULT f_getcwd (
 2721:  	TCHAR *path,	/* Pointer to the directory path */
 2722:  	UINT sz_path	/* Size of path */
 2723:  )
 2724:  {
 2725:  	FRESULT res;
 2726:  	DIR dj;
 2727:  	UINT i, n;
 2728:  	DWORD ccl;
 2729:  	TCHAR *tp;
 2730:  	FILINFO fno;
 2731:  	DEF_NAMEBUF;
 2732:  
 2733:  
 2734:  	*path = 0;
 2735:  	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
 2736:  	if (res == FR_OK) {
 2737:  		INIT_BUF(dj);
 2738:  		i = sz_path;		/* Bottom of buffer (dir stack base) */
 2739:  		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
 2740:  		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
 2741:  			res = dir_sdi(&dj, 1);			/* Get parent dir */
 2742:  			if (res != FR_OK) break;
 2743:  			res = dir_read(&dj);
 2744:  			if (res != FR_OK) break;
 2745:  			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
 2746:  			res = dir_sdi(&dj, 0);
 2747:  			if (res != FR_OK) break;
 2748:  			do {							/* Find the entry links to the child dir */
 2749:  				res = dir_read(&dj);
 2750:  				if (res != FR_OK) break;
 2751:  				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
 2752:  				res = dir_next(&dj, 0);	
 2753:  			} while (res == FR_OK);
 2754:  			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
 2755:  			if (res != FR_OK) break;
 2756:  #if _USE_LFN
 2757:  			fno.lfname = path;
 2758:  			fno.lfsize = i;
 2759:  #endif
 2760:  			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
 2761:  			tp = fno.fname;
 2762:  			if (_USE_LFN && *path) tp = path;
 2763:  			for (n = 0; tp[n]; n++) ;
 2764:  			if (i < n + 3) {
 2765:  				res = FR_NOT_ENOUGH_CORE; break;
 2766:  			}
 2767:  			while (n) path[--i] = tp[--n];
 2768:  			path[--i] = '/';
 2769:  		}
 2770:  		tp = path;
 2771:  		if (res == FR_OK) {
 2772:  			*tp++ = '0' + CurrVol;			/* Put drive number */
 2773:  			*tp++ = ':';
 2774:  			if (i == sz_path) {				/* Root-dir */
 2775:  				*tp++ = '/';
 2776:  			} else {						/* Sub-dir */
 2777:  				do		/* Add stacked path str */
 2778:  					*tp++ = path[i++];
 2779:  				while (i < sz_path);
 2780:  			}
 2781:  		}
 2782:  		*tp = 0;
 2783:  		FREE_BUF();
 2784:  	}
 2785:  
 2786:  	LEAVE_FF(dj.fs, res);
 2787:  }
 2788:  #endif /* _FS_RPATH >= 2 */
 2789:  #endif /* _FS_RPATH >= 1 */
 2790:  
 2791:  
 2792:  
 2793:  #if _FS_MINIMIZE <= 2
 2794:  /*-----------------------------------------------------------------------*/
 2795:  /* Seek File R/W Pointer                                                 */
 2796:  /*-----------------------------------------------------------------------*/
 2797:  
 2798:  FRESULT f_lseek (
 2799:  	FIL *fp,		/* Pointer to the file object */
 2800:  	DWORD ofs		/* File pointer from top of file */
 2801:  )
 2802:  {
*** EVALUATION ***

Function: f_lseek
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b96         [2]     LEAS  -10,SP
  0002 3b           [2]     PSHD  
  0003 34           [2]     PSHX  
  0004 1b94         [2]     LEAS  -12,SP
 2803:  	FRESULT res;
 2804:  
 2805:  
 2806:  	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  0006 edf01c       [3]     LDY   28,SP
  0009 ec40         [3]     LDD   0,Y
  000b 3b           [2]     PSHD  
  000c ec42         [3]     LDD   2,Y
  000e 160000       [4]     JSR   validate
  0011 1b82         [2]     LEAS  2,SP
  0013 6cf018       [3]     STD   24,SP
 2807:  	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  0016 2703         [3/1]   BEQ   *+5 ;abs = 001b
  0018 060000       [3]     JMP   f_lseek:0x02d8
 2808:  	if (fp->flag & FA__ERROR)			/* Check abort flag */
  001b eef01c       [3]     LDX   28,SP
  001e 0f048003     [4]     BRCLR 4,X,#128,*+7 ;abs = 0025
  0022 060000       [3]     JMP   f_lseek:0x021a
 2809:  		LEAVE_FF(fp->fs, FR_INT_ERR);
 2810:  
 2811:  #if _USE_FASTSEEK
 2812:  	if (fp->cltbl) {	/* Fast seek */
 2813:  		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
 2814:  
 2815:  		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 2816:  			tbl = fp->cltbl;
 2817:  			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 2818:  			cl = fp->sclust;			/* Top of the chain */
 2819:  			if (cl) {
 2820:  				do {
 2821:  					/* Get a fragment */
 2822:  					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 2823:  					do {
 2824:  						pcl = cl; ncl++;
 2825:  						cl = get_fat(fp->fs, cl);
 2826:  						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
 2827:  						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 2828:  					} while (cl == pcl + 1);
 2829:  					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 2830:  						*tbl++ = ncl; *tbl++ = tcl;
 2831:  					}
 2832:  				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
 2833:  			}
 2834:  			*fp->cltbl = ulen;	/* Number of items used */
 2835:  			if (ulen <= tlen)
 2836:  				*tbl = 0;		/* Terminate table */
 2837:  			else
 2838:  				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 2839:  
 2840:  		} else {						/* Fast seek */
 2841:  			if (ofs > fp->fsize)		/* Clip offset at the file size */
 2842:  				ofs = fp->fsize;
 2843:  			fp->fptr = ofs;				/* Set file pointer */
 2844:  			if (ofs) {
 2845:  				fp->clust = clmt_clust(fp, ofs - 1);
 2846:  				dsc = clust2sect(fp->fs, fp->clust);
 2847:  				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
 2848:  				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
 2849:  				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
 2850:  #if !_FS_TINY
 2851:  #if !_FS_READONLY
 2852:  					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
 2853:  						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 2854:  							ABORT(fp->fs, FR_DISK_ERR);
 2855:  						fp->flag &= ~FA__DIRTY;
 2856:  					}
 2857:  #endif
 2858:  					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
 2859:  						ABORT(fp->fs, FR_DISK_ERR);
 2860:  #endif
 2861:  					fp->dsect = dsc;
 2862:  				}
 2863:  			}
 2864:  		}
 2865:  	} else
 2866:  #endif
 2867:  
 2868:  	/* Normal Seek */
 2869:  	{
 2870:  		DWORD clst, bcs, nsect, ifptr;
 2871:  
 2872:  		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
  0025 190a         [2]     LEAY  10,X
  0027 ec8e         [3]     LDD   14,SP
  0029 ee8c         [3]     LDX   12,SP
  002b 160000       [4]     JSR   _LCMP_P
  002e 230f         [3/1]   BLS   *+17 ;abs = 003f
 2873:  #if !_FS_READONLY
 2874:  			 && !(fp->flag & FA_WRITE)
  0030 eef01c       [3]     LDX   28,SP
  0033 0e040208     [4]     BRSET 4,X,#2,*+12 ;abs = 003f
 2875:  #endif
 2876:  			) ofs = fp->fsize;
  0037 ec0a         [3]     LDD   10,X
  0039 6c8c         [2]     STD   12,SP
  003b ec0c         [3]     LDD   12,X
  003d 6c8e         [2]     STD   14,SP
 2877:  
 2878:  		ifptr = fp->fptr;
  003f eef01c       [3]     LDX   28,SP
  0042 ec06         [3]     LDD   6,X
  0044 6cf014       [3]     STD   20,SP
  0047 ec08         [3]     LDD   8,X
  0049 6cf016       [3]     STD   22,SP
 2879:  		fp->fptr = nsect = 0;
  004c c7           [1]     CLRB  
  004d 87           [1]     CLRA  
  004e 6cf012       [3]     STD   18,SP
  0051 6cf010       [3]     STD   16,SP
  0054 6c06         [2]     STD   6,X
  0056 6c08         [2]     STD   8,X
 2880:  		if (ofs) {
  0058 ee8e         [3]     LDX   14,SP
  005a 2606         [3/1]   BNE   *+8 ;abs = 0062
  005c ee8c         [3]     LDX   12,SP
  005e 182701d7     [4/3]   LBEQ  *+475 ;abs = 0239
 2881:  			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
  0062 eef01c       [3]     LDX   28,SP
  0065 ed00         [3]     LDY   0,X
  0067 e642         [3]     LDAB  2,Y
  0069 b705         [1]     SEX   A,X
  006b b746         [1]     TFR   D,Y
  006d c609         [1]     LDAB  #9
  006f 160000       [4]     JSR   _LSHL
  0072 6c8a         [2]     STD   10,SP
  0074 6e88         [2]     STX   8,SP
 2882:  			if (ifptr > 0 &&
  0076 ecf016       [3]     LDD   22,SP
  0079 2605         [3/1]   BNE   *+7 ;abs = 0080
  007b ecf014       [3]     LDD   20,SP
  007e 2772         [3/1]   BEQ   *+116 ;abs = 00f2
 2883:  				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
  0080 ec8e         [3]     LDD   14,SP
  0082 ee8c         [3]     LDX   12,SP
  0084 160000       [4]     JSR   _LDEC
  0087 b746         [1]     TFR   D,Y
  0089 ec8a         [3]     LDD   10,SP
  008b 3b           [2]     PSHD  
  008c 6e82         [2]     STX   2,SP
  008e ee8a         [3]     LDX   10,SP
  0090 34           [2]     PSHX  
  0091 b764         [1]     TFR   Y,D
  0093 ee84         [3]     LDX   4,SP
  0095 160000       [4]     JSR   _LDIVU
  0098 3b           [2]     PSHD  
  0099 ecf018       [3]     LDD   24,SP
  009c 34           [2]     PSHX  
  009d eef018       [3]     LDX   24,SP
  00a0 160000       [4]     JSR   _LDEC
  00a3 ed8e         [3]     LDY   14,SP
  00a5 35           [2]     PSHY  
  00a6 ed8e         [3]     LDY   14,SP
  00a8 35           [2]     PSHY  
  00a9 6c88         [2]     STD   8,SP
  00ab 6e8a         [2]     STX   10,SP
  00ad 160000       [4]     JSR   _LDIVU
  00b0 3b           [2]     PSHD  
  00b1 34           [2]     PSHX  
  00b2 ec86         [3]     LDD   6,SP
  00b4 ee84         [3]     LDX   4,SP
  00b6 160000       [4]     JSR   _LCMP
  00b9 1b84         [2]     LEAS  4,SP
  00bb 2535         [3/1]   BCS   *+55 ;abs = 00f2
 2884:  				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
  00bd ec8a         [3]     LDD   10,SP
  00bf ee88         [3]     LDX   8,SP
  00c1 160000       [4]     JSR   _LDEC
  00c4 160000       [4]     JSR   _LCOM
  00c7 e481         [3]     ANDB  1,SP
  00c9 a480         [3]     ANDA  0,SP
  00cb edf01c       [3]     LDY   28,SP
  00ce 6c48         [2]     STD   8,Y
  00d0 b754         [1]     TFR   X,D
  00d2 e483         [3]     ANDB  3,SP
  00d4 a482         [3]     ANDA  2,SP
  00d6 6c46         [2]     STD   6,Y
 2885:  				ofs -= fp->fptr;
  00d8 ec8e         [3]     LDD   14,SP
  00da a348         [3]     SUBD  8,Y
  00dc 6c8e         [2]     STD   14,SP
  00de ec8c         [3]     LDD   12,SP
  00e0 e247         [3]     SBCB  7,Y
  00e2 a246         [3]     SBCA  6,Y
  00e4 6c8c         [2]     STD   12,SP
 2886:  				clst = fp->clust;
  00e6 ece812       [3]     LDD   18,Y
  00e9 6c84         [2]     STD   4,SP
  00eb ece814       [3]     LDD   20,Y
  00ee 6c86         [2]     STD   6,SP
 2887:  			} else {									/* When seek to back cluster, */
  00f0 2050         [3]     BRA   *+82 ;abs = 0142
 2888:  				clst = fp->sclust;						/* start from the first cluster */
  00f2 eef01c       [3]     LDX   28,SP
  00f5 ec0e         [3]     LDD   14,X
  00f7 6c84         [2]     STD   4,SP
  00f9 ece010       [3]     LDD   16,X
  00fc 6c86         [2]     STD   6,SP
 2889:  #if !_FS_READONLY
 2890:  				if (clst == 0) {						/* If no cluster chain, create a new chain */
  00fe 2635         [3/1]   BNE   *+55 ;abs = 0135
  0100 ec84         [3]     LDD   4,SP
  0102 2631         [3/1]   BNE   *+51 ;abs = 0135
 2891:  					clst = create_chain(fp->fs, 0);
  0104 ec00         [3]     LDD   0,X
  0106 3b           [2]     PSHD  
  0107 c7           [1]     CLRB  
  0108 87           [1]     CLRA  
  0109 b745         [1]     TFR   D,X
  010b 160000       [4]     JSR   create_chain
  010e 1b82         [2]     LEAS  2,SP
  0110 6c86         [2]     STD   6,SP
  0112 6e84         [2]     STX   4,SP
 2892:  					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  0114 042406       [3]     DBNE  D,*+9 ;abs = 011d
  0117 046503       [3]     TBNE  X,*+6 ;abs = 011d
  011a 060000       [3]     JMP   f_lseek:0x0214
 2893:  					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  011d ec86         [3]     LDD   6,SP
  011f 04a407       [3]     IBNE  D,*+10 ;abs = 0129
  0122 ec84         [3]     LDD   4,SP
  0124 04a402       [3]     IBNE  D,*+5 ;abs = 0129
  0127 2066         [3]     BRA   *+104 ;abs = 018f
 2894:  					fp->sclust = clst;
  0129 eef01c       [3]     LDX   28,SP
  012c ec84         [3]     LDD   4,SP
  012e 6c0e         [2]     STD   14,X
  0130 ec86         [3]     LDD   6,SP
  0132 6ce010       [3]     STD   16,X
 2895:  				}
 2896:  #endif
 2897:  				fp->clust = clst;
  0135 eef01c       [3]     LDX   28,SP
  0138 ec84         [3]     LDD   4,SP
  013a 6ce012       [3]     STD   18,X
  013d ec86         [3]     LDD   6,SP
  013f 6ce014       [3]     STD   20,X
 2898:  			}
 2899:  			if (clst != 0) {
  0142 ec86         [3]     LDD   6,SP
  0144 2606         [3/1]   BNE   *+8 ;abs = 014c
  0146 ec84         [3]     LDD   4,SP
  0148 182700ed     [4/3]   LBEQ  *+241 ;abs = 0239
 2900:  				while (ofs > bcs) {						/* Cluster following loop */
  014c 060000       [3]     JMP   f_lseek:0x01d5
 2901:  #if !_FS_READONLY
 2902:  					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
  014f eef01c       [3]     LDX   28,SP
  0152 0f04021f     [4]     BRCLR 4,X,#2,*+35 ;abs = 0175
 2903:  						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
  0156 ec00         [3]     LDD   0,X
  0158 3b           [2]     PSHD  
  0159 ec88         [3]     LDD   8,SP
  015b ee86         [3]     LDX   6,SP
  015d 160000       [4]     JSR   create_chain
  0160 1b82         [2]     LEAS  2,SP
  0162 6c86         [2]     STD   6,SP
  0164 6e84         [2]     STX   4,SP
 2904:  						if (clst == 0) {				/* When disk gets full, clip file size */
  0166 04641c       [3]     TBNE  D,*+31 ;abs = 0185
  0169 261a         [3/1]   BNE   *+28 ;abs = 0185
 2905:  							ofs = bcs; break;
  016b ec8a         [3]     LDD   10,SP
  016d 6c8e         [2]     STD   14,SP
  016f ec88         [3]     LDD   8,SP
  0171 6c8c         [2]     STD   12,SP
  0173 2070         [3]     BRA   *+114 ;abs = 01e5
 2906:  						}
 2907:  					} else
 2908:  #endif
 2909:  						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
  0175 ec00         [3]     LDD   0,X
  0177 3b           [2]     PSHD  
  0178 ec88         [3]     LDD   8,SP
  017a ee86         [3]     LDX   6,SP
  017c 160000       [4]     JSR   get_fat
  017f 1b82         [2]     LEAS  2,SP
  0181 6c86         [2]     STD   6,SP
  0183 6e84         [2]     STX   4,SP
 2910:  					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  0185 ec86         [3]     LDD   6,SP
  0187 04a408       [3]     IBNE  D,*+11 ;abs = 0192
  018a ec84         [3]     LDD   4,SP
  018c 04a403       [3]     IBNE  D,*+6 ;abs = 0192
  018f 060000       [3]     JMP   f_lseek:0x0298
 2911:  					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
  0192 ec84         [3]     LDD   4,SP
  0194 2607         [3/1]   BNE   *+9 ;abs = 019d
  0196 ee86         [3]     LDX   6,SP
  0198 8e0001       [2]     CPX   #1
  019b 2377         [3/1]   BLS   *+121 ;abs = 0214
  019d eef01c       [3]     LDX   28,SP
  01a0 ed00         [3]     LDY   0,X
  01a2 19e816       [2]     LEAY  22,Y
  01a5 ec86         [3]     LDD   6,SP
  01a7 ee84         [3]     LDX   4,SP
  01a9 160000       [4]     JSR   _LCMP_P
  01ac 2502         [3/1]   BCS   *+4 ;abs = 01b0
  01ae 2064         [3]     BRA   *+102 ;abs = 0214
 2912:  					fp->clust = clst;
  01b0 edf01c       [3]     LDY   28,SP
  01b3 6ee812       [3]     STX   18,Y
  01b6 6ce814       [3]     STD   20,Y
 2913:  					fp->fptr += bcs;
  01b9 ec48         [3]     LDD   8,Y
  01bb e38a         [3]     ADDD  10,SP
  01bd 6c48         [2]     STD   8,Y
  01bf ec88         [3]     LDD   8,SP
  01c1 e947         [3]     ADCB  7,Y
  01c3 a946         [3]     ADCA  6,Y
  01c5 6c46         [2]     STD   6,Y
 2914:  					ofs -= bcs;
  01c7 ec8e         [3]     LDD   14,SP
  01c9 a38a         [3]     SUBD  10,SP
  01cb 6c8e         [2]     STD   14,SP
  01cd ec8c         [3]     LDD   12,SP
  01cf e289         [3]     SBCB  9,SP
  01d1 a288         [3]     SBCA  8,SP
  01d3 6c8c         [2]     STD   12,SP
  01d5 ec8c         [3]     LDD   12,SP
  01d7 ac88         [3]     CPD   8,SP
  01d9 2206         [3/1]   BHI   *+8 ;abs = 01e1
  01db 2608         [3/1]   BNE   *+10 ;abs = 01e5
  01dd ec8e         [3]     LDD   14,SP
  01df ac8a         [3]     CPD   10,SP
  01e1 1822ff6a     [4/3]   LBHI  *-146 ;abs = 014f
 2915:  				}
 2916:  				fp->fptr += ofs;
  01e5 eef01c       [3]     LDX   28,SP
  01e8 ec08         [3]     LDD   8,X
  01ea e38e         [3]     ADDD  14,SP
  01ec 6c08         [2]     STD   8,X
  01ee ec8c         [3]     LDD   12,SP
  01f0 e907         [3]     ADCB  7,X
  01f2 a906         [3]     ADCA  6,X
  01f4 6c06         [2]     STD   6,X
 2917:  				if (ofs % SS(fp->fs)) {
  01f6 ec8e         [3]     LDD   14,SP
  01f8 8401         [1]     ANDA  #1
  01fa 04443c       [3]     TBEQ  D,*+63 ;abs = 0239
 2918:  					nsect = clust2sect(fp->fs, clst);	/* Current sector */
  01fd ec00         [3]     LDD   0,X
  01ff 3b           [2]     PSHD  
  0200 ec88         [3]     LDD   8,SP
  0202 ee86         [3]     LDX   6,SP
  0204 160000       [4]     JSR   clust2sect
  0207 1b82         [2]     LEAS  2,SP
  0209 6cf012       [3]     STD   18,SP
  020c 6ef010       [3]     STX   16,SP
 2919:  					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
  020f 04640d       [3]     TBNE  D,*+16 ;abs = 021f
  0212 260b         [3/1]   BNE   *+13 ;abs = 021f
  0214 eef01c       [3]     LDX   28,SP
  0217 0c0480       [4]     BSET  4,X,#128
  021a c602         [1]     LDAB  #2
  021c 060000       [3]     JMP   f_lseek:0x02a0
 2920:  					nsect += ofs / SS(fp->fs);
  021f ed8e         [3]     LDY   14,SP
  0221 ee8c         [3]     LDX   12,SP
  0223 c609         [1]     LDAB  #9
  0225 160000       [4]     JSR   _LSHRU
  0228 e3f012       [3]     ADDD  18,SP
  022b 6cf012       [3]     STD   18,SP
  022e b754         [1]     TFR   X,D
  0230 e9f011       [3]     ADCB  17,SP
  0233 a9f010       [3]     ADCA  16,SP
  0236 6cf010       [3]     STD   16,SP
 2921:  				}
 2922:  			}
 2923:  		}
 2924:  		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
  0239 eef01c       [3]     LDX   28,SP
  023c ec08         [3]     LDD   8,X
  023e 8401         [1]     ANDA  #1
  0240 04446f       [3]     TBEQ  D,*+114 ;abs = 02b2
  0243 ecf012       [3]     LDD   18,SP
  0246 ace018       [3]     CPD   24,X
  0249 2608         [3/1]   BNE   *+10 ;abs = 0253
  024b ecf010       [3]     LDD   16,SP
  024e ace016       [3]     CPD   22,X
  0251 275f         [3/1]   BEQ   *+97 ;abs = 02b2
 2925:  #if !_FS_TINY
 2926:  #if !_FS_READONLY
 2927:  			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
  0253 0f044023     [4]     BRCLR 4,X,#64,*+39 ;abs = 027a
 2928:  				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  0257 ed00         [3]     LDY   0,X
  0259 e641         [3]     LDAB  1,Y
  025b 37           [2]     PSHB  
  025c 19e020       [2]     LEAY  32,X
  025f 35           [2]     PSHY  
  0260 ece018       [3]     LDD   24,X
  0263 3b           [2]     PSHD  
  0264 ece016       [3]     LDD   22,X
  0267 3b           [2]     PSHD  
  0268 c601         [1]     LDAB  #1
  026a 160000       [4]     JSR   eDisk_Write
  026d 1b87         [2]     LEAS  7,SP
  026f 044402       [3]     TBEQ  D,*+5 ;abs = 0274
 2929:  					ABORT(fp->fs, FR_DISK_ERR);
  0272 2024         [3]     BRA   *+38 ;abs = 0298
 2930:  				fp->flag &= ~FA__DIRTY;
  0274 eef01c       [3]     LDX   28,SP
  0277 0d0440       [4]     BCLR  4,X,#64
 2931:  			}
 2932:  #endif
 2933:  			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
  027a eef01c       [3]     LDX   28,SP
  027d ed00         [3]     LDY   0,X
  027f e641         [3]     LDAB  1,Y
  0281 37           [2]     PSHB  
  0282 1ae020       [2]     LEAX  32,X
  0285 34           [2]     PSHX  
  0286 ecf015       [3]     LDD   21,SP
  0289 3b           [2]     PSHD  
  028a ecf015       [3]     LDD   21,SP
  028d 3b           [2]     PSHD  
  028e c601         [1]     LDAB  #1
  0290 160000       [4]     JSR   eDisk_Read
  0293 1b87         [2]     LEAS  7,SP
  0295 04440b       [3]     TBEQ  D,*+14 ;abs = 02a3
 2934:  				ABORT(fp->fs, FR_DISK_ERR);
  0298 eef01c       [3]     LDX   28,SP
  029b 0c0480       [4]     BSET  4,X,#128
  029e c601         [1]     LDAB  #1
  02a0 87           [1]     CLRA  
  02a1 2035         [3]     BRA   *+55 ;abs = 02d8
 2935:  #endif
 2936:  			fp->dsect = nsect;
  02a3 eef01c       [3]     LDX   28,SP
  02a6 ecf010       [3]     LDD   16,SP
  02a9 6ce016       [3]     STD   22,X
  02ac ecf012       [3]     LDD   18,SP
  02af 6ce018       [3]     STD   24,X
 2937:  		}
 2938:  #if !_FS_READONLY
 2939:  		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
  02b2 edf01c       [3]     LDY   28,SP
  02b5 ee46         [3]     LDX   6,Y
  02b7 ec48         [3]     LDD   8,Y
  02b9 34           [2]     PSHX  
  02ba 1a4a         [2]     LEAX  10,Y
  02bc 34           [2]     PSHX  
  02bd ee82         [3]     LDX   2,SP
  02bf 31           [3]     PULY  
  02c0 160000       [4]     JSR   _LCMP_P
  02c3 1b82         [2]     LEAS  2,SP
  02c5 230e         [3/1]   BLS   *+16 ;abs = 02d5
 2940:  			fp->fsize = fp->fptr;
  02c7 eef01c       [3]     LDX   28,SP
  02ca ec06         [3]     LDD   6,X
  02cc 6c0a         [2]     STD   10,X
  02ce ec08         [3]     LDD   8,X
  02d0 6c0c         [2]     STD   12,X
 2941:  			fp->flag |= FA__WRITTEN;
  02d2 0c0420       [4]     BSET  4,X,#32
 2942:  		}
 2943:  #endif
 2944:  	}
 2945:  
 2946:  	LEAVE_FF(fp->fs, res);
  02d5 ecf018       [3]     LDD   24,SP
 2947:  }
  02d8 1bf01a       [2]     LEAS  26,SP
  02db 3d           [5]     RTS   
 2948:  
 2949:  
 2950:  
 2951:  #if _FS_MINIMIZE <= 1
 2952:  /*-----------------------------------------------------------------------*/
 2953:  /* Create a Directroy Object                                             */
 2954:  /*-----------------------------------------------------------------------*/
 2955:  
 2956:  FRESULT f_opendir (
 2957:  	DIR *dj,			/* Pointer to directory object to create */
 2958:  	const TCHAR *path	/* Pointer to the directory path */
 2959:  )
 2960:  {
*** EVALUATION ***

Function: f_opendir
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b92         [2]     LEAS  -14,SP
  0002 3b           [2]     PSHD  
 2961:  	FRESULT res;
 2962:  	DEF_NAMEBUF;
 2963:  
 2964:  
 2965:  	res = chk_mounted(&path, &dj->fs, 0);
  0003 1a80         [2]     LEAX  0,SP
  0005 34           [2]     PSHX  
  0006 ecf014       [3]     LDD   20,SP
  0009 3b           [2]     PSHD  
  000a c7           [1]     CLRB  
  000b 160000       [4]     JSR   chk_mounted
  000e 1b84         [2]     LEAS  4,SP
  0010 6c82         [2]     STD   2,SP
 2966:  	if (res == FR_OK) {
  0012 2673         [3/1]   BNE   *+117 ;abs = 0087
 2967:  		INIT_BUF(*dj);
  0014 1a84         [2]     LEAX  4,SP
  0016 edf012       [3]     LDY   18,SP
  0019 6ee814       [3]     STX   20,Y
 2968:  		res = follow_path(dj, path);			/* Follow the path to the directory */
  001c 35           [2]     PSHY  
  001d ec82         [3]     LDD   2,SP
  001f 160000       [4]     JSR   follow_path
  0022 1b82         [2]     LEAS  2,SP
  0024 6c82         [2]     STD   2,SP
 2969:  		FREE_BUF();
 2970:  		if (res == FR_OK) {						/* Follow completed */
  0026 265a         [3/1]   BNE   *+92 ;abs = 0082
 2971:  			if (dj->dir) {						/* It is not the root dir */
  0028 eef012       [3]     LDX   18,SP
  002b ede012       [3]     LDY   18,X
  002e 273e         [3/1]   BEQ   *+64 ;abs = 006e
 2972:  				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
  0030 0f4b1035     [4]     BRCLR 11,Y,#16,*+57 ;abs = 0069
 2973:  					dj->sclust = LD_CLUST(dj->dir);
  0034 1ae814       [2]     LEAX  20,Y
  0037 e601         [3]     LDAB  1,X
  0039 b710         [1]     TFR   B,A
  003b c7           [1]     CLRB  
  003c 3b           [2]     PSHD  
  003d e6e814       [3]     LDAB  20,Y
  0040 87           [1]     CLRA  
  0041 ea81         [3]     ORAB  1,SP
  0043 aa80         [3]     ORAA  0,SP
  0045 1ae81a       [2]     LEAX  26,Y
  0048 6c80         [2]     STD   0,SP
  004a e601         [3]     LDAB  1,X
  004c b710         [1]     TFR   B,A
  004e c7           [1]     CLRB  
  004f 3b           [2]     PSHD  
  0050 e6e81a       [3]     LDAB  26,Y
  0053 87           [1]     CLRA  
  0054 ea81         [3]     ORAB  1,SP
  0056 aa80         [3]     ORAA  0,SP
  0058 ca00         [1]     ORAB  #0
  005a 8a00         [1]     ORAA  #0
  005c eef016       [3]     LDX   22,SP
  005f 6c08         [2]     STD   8,X
  0061 ec82         [3]     LDD   2,SP
  0063 6c06         [2]     STD   6,X
 2974:  				} else {						/* The object is not a directory */
  0065 1b84         [2]     LEAS  4,SP
  0067 2005         [3]     BRA   *+7 ;abs = 006e
 2975:  					res = FR_NO_PATH;
  0069 c605         [1]     LDAB  #5
  006b 87           [1]     CLRA  
  006c 6c82         [2]     STD   2,SP
 2976:  				}
 2977:  			}
 2978:  			if (res == FR_OK) {
  006e ec82         [3]     LDD   2,SP
  0070 2610         [3/1]   BNE   *+18 ;abs = 0082
 2979:  				dj->id = dj->fs->id;
  0072 ed00         [3]     LDY   0,X
  0074 ec46         [3]     LDD   6,Y
  0076 6c02         [2]     STD   2,X
 2980:  				res = dir_sdi(dj, 0);			/* Rewind dir */
  0078 34           [2]     PSHX  
  0079 c7           [1]     CLRB  
  007a 87           [1]     CLRA  
  007b 160000       [4]     JSR   dir_sdi
  007e 1b82         [2]     LEAS  2,SP
  0080 6c82         [2]     STD   2,SP
 2981:  			}
 2982:  		}
 2983:  		if (res == FR_NO_FILE) res = FR_NO_PATH;
  0082 ec82         [3]     LDD   2,SP
  0084 8c0004       [2]     CPD   #4
  0087 2605         [3/1]   BNE   *+7 ;abs = 008e
  0089 c605         [1]     LDAB  #5
  008b 87           [1]     CLRA  
  008c 6c82         [2]     STD   2,SP
 2984:  	}
 2985:  
 2986:  	LEAVE_FF(dj->fs, res);
  008e ec82         [3]     LDD   2,SP
 2987:  }
  0090 1bf010       [2]     LEAS  16,SP
  0093 3d           [5]     RTS   
 2988:  
 2989:  
 2990:  
 2991:  
 2992:  /*-----------------------------------------------------------------------*/
 2993:  /* Read Directory Entry in Sequense                                      */
 2994:  /*-----------------------------------------------------------------------*/
 2995:  
 2996:  FRESULT f_readdir (
 2997:  	DIR *dj,			/* Pointer to the open directory object */
 2998:  	FILINFO *fno		/* Pointer to file information to return */
 2999:  )
 3000:  {
*** EVALUATION ***

Function: f_readdir
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b92         [2]     LEAS  -14,SP
  0002 3b           [2]     PSHD  
 3001:  	FRESULT res;
 3002:  	DEF_NAMEBUF;
 3003:  
 3004:  
 3005:  	res = validate(dj->fs, dj->id);			/* Check validity of the object */
  0003 eef012       [3]     LDX   18,SP
  0006 ec00         [3]     LDD   0,X
  0008 3b           [2]     PSHD  
  0009 ec02         [3]     LDD   2,X
  000b 160000       [4]     JSR   validate
  000e 1b82         [2]     LEAS  2,SP
  0010 6c82         [2]     STD   2,SP
 3006:  	if (res == FR_OK) {
  0012 264c         [3/1]   BNE   *+78 ;abs = 0060
 3007:  		if (!fno) {
  0014 ec80         [3]     LDD   0,SP
  0016 260d         [3/1]   BNE   *+15 ;abs = 0025
 3008:  			res = dir_sdi(dj, 0);			/* Rewind the directory object */
  0018 ecf012       [3]     LDD   18,SP
  001b 3b           [2]     PSHD  
  001c c7           [1]     CLRB  
  001d 87           [1]     CLRA  
  001e 160000       [4]     JSR   dir_sdi
  0021 1b82         [2]     LEAS  2,SP
 3009:  		} else {
  0023 2039         [3]     BRA   *+59 ;abs = 005e
 3010:  			INIT_BUF(*dj);
  0025 1a84         [2]     LEAX  4,SP
  0027 edf012       [3]     LDY   18,SP
  002a 6ee814       [3]     STX   20,Y
 3011:  			res = dir_read(dj);				/* Read an directory item */
  002d b764         [1]     TFR   Y,D
  002f 160000       [4]     JSR   dir_read
  0032 6c82         [2]     STD   2,SP
 3012:  			if (res == FR_NO_FILE) {		/* Reached end of dir */
  0034 8c0004       [2]     CPD   #4
  0037 2604         [3/1]   BNE   *+6 ;abs = 003d
 3013:  				dj->sect = 0;
  0039 072b         [4]     BSR   *+45 ;abs = 0066
  003b 2003         [3]     BRA   *+5 ;abs = 0040
 3014:  				res = FR_OK;
 3015:  			}
 3016:  			if (res == FR_OK) {				/* A valid entry is found */
  003d 046420       [3]     TBNE  D,*+35 ;abs = 0060
 3017:  				get_fileinfo(dj, fno);		/* Get the object information */
  0040 ecf012       [3]     LDD   18,SP
  0043 3b           [2]     PSHD  
  0044 ec82         [3]     LDD   2,SP
  0046 160000       [4]     JSR   get_fileinfo
  0049 3a           [3]     PULD  
 3018:  				res = dir_next(dj, 0);		/* Increment index for next */
  004a eef012       [3]     LDX   18,SP
  004d 34           [2]     PSHX  
  004e c7           [1]     CLRB  
  004f 87           [1]     CLRA  
  0050 160000       [4]     JSR   dir_next
  0053 1b82         [2]     LEAS  2,SP
  0055 6c82         [2]     STD   2,SP
 3019:  				if (res == FR_NO_FILE) {
  0057 8c0004       [2]     CPD   #4
  005a 2604         [3/1]   BNE   *+6 ;abs = 0060
 3020:  					dj->sect = 0;
  005c 0708         [4]     BSR   *+10 ;abs = 0066
 3021:  					res = FR_OK;
  005e 6c82         [2]     STD   2,SP
 3022:  				}
 3023:  			}
 3024:  			FREE_BUF();
 3025:  		}
 3026:  	}
 3027:  
 3028:  	LEAVE_FF(dj->fs, res);
  0060 ec82         [3]     LDD   2,SP
 3029:  }
  0062 1bf010       [2]     LEAS  16,SP
  0065 3d           [5]     RTS   
  0066 eef014       [3]     LDX   20,SP
  0069 c7           [1]     CLRB  
  006a 87           [1]     CLRA  
  006b 6c0e         [2]     STD   14,X
  006d 6ce010       [3]     STD   16,X
  0070 3d           [5]     RTS   
 3030:  
 3031:  
 3032:  
 3033:  #if _FS_MINIMIZE == 0
 3034:  /*-----------------------------------------------------------------------*/
 3035:  /* Get File Status                                                       */
 3036:  /*-----------------------------------------------------------------------*/
 3037:  
 3038:  FRESULT f_stat (
 3039:  	const TCHAR *path,	/* Pointer to the file path */
 3040:  	FILINFO *fno		/* Pointer to file information to return */
 3041:  )
 3042:  {
*** EVALUATION ***

Function: f_stat
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1dc       [2]     LEAS  -36,SP
  0003 3b           [2]     PSHD  
  0004 3b           [2]     PSHD  
 3043:  	FRESULT res;
 3044:  	DIR dj;
 3045:  	DEF_NAMEBUF;
 3046:  
 3047:  
 3048:  	res = chk_mounted(&path, &dj.fs, 0);
  0005 1af02a       [2]     LEAX  42,SP
  0008 34           [2]     PSHX  
  0009 1a88         [2]     LEAX  8,SP
  000b 34           [2]     PSHX  
  000c c7           [1]     CLRB  
  000d 160000       [4]     JSR   chk_mounted
  0010 1b84         [2]     LEAS  4,SP
  0012 6c84         [2]     STD   4,SP
 3049:  	if (res == FR_OK) {
  0014 262d         [3/1]   BNE   *+47 ;abs = 0043
 3050:  		INIT_BUF(dj);
  0016 1af01c       [2]     LEAX  28,SP
  0019 6ef01a       [3]     STX   26,SP
 3051:  		res = follow_path(&dj, path);	/* Follow the file path */
  001c 1a86         [2]     LEAX  6,SP
  001e 34           [2]     PSHX  
  001f ecf02c       [3]     LDD   44,SP
  0022 6e82         [2]     STX   2,SP
  0024 160000       [4]     JSR   follow_path
  0027 1b82         [2]     LEAS  2,SP
  0029 6c84         [2]     STD   4,SP
 3052:  		if (res == FR_OK) {				/* Follow completed */
  002b 2616         [3/1]   BNE   *+24 ;abs = 0043
 3053:  			if (dj.dir)		/* Found an object */
  002d ecf018       [3]     LDD   24,SP
  0030 270c         [3/1]   BEQ   *+14 ;abs = 003e
 3054:  				get_fileinfo(&dj, fno);
  0032 ec80         [3]     LDD   0,SP
  0034 3b           [2]     PSHD  
  0035 ec84         [3]     LDD   4,SP
  0037 160000       [4]     JSR   get_fileinfo
  003a 1b82         [2]     LEAS  2,SP
  003c 2005         [3]     BRA   *+7 ;abs = 0043
 3055:  			else			/* It is root dir */
 3056:  				res = FR_INVALID_NAME;
  003e c606         [1]     LDAB  #6
  0040 87           [1]     CLRA  
  0041 6c84         [2]     STD   4,SP
 3057:  		}
 3058:  		FREE_BUF();
 3059:  	}
 3060:  
 3061:  	LEAVE_FF(dj.fs, res);
  0043 ec84         [3]     LDD   4,SP
 3062:  }
  0045 1bf028       [2]     LEAS  40,SP
  0048 3d           [5]     RTS   
 3063:  
 3064:  
 3065:  
 3066:  #if !_FS_READONLY
 3067:  /*-----------------------------------------------------------------------*/
 3068:  /* Get Number of Free Clusters                                           */
 3069:  /*-----------------------------------------------------------------------*/
 3070:  
 3071:  FRESULT f_getfree (
 3072:  	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
 3073:  	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
 3074:  	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
 3075:  )
 3076:  {
*** EVALUATION ***

Function: f_getfree
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1e9       [2]     LEAS  -23,SP
  0003 3b           [2]     PSHD  
  0004 3b           [2]     PSHD  
 3077:  	FRESULT res;
 3078:  	DWORD n, clst, sect, stat;
 3079:  	UINT i;
 3080:  	BYTE fat, *p;
 3081:  
 3082:  
 3083:  	/* Get drive number */
 3084:  	res = chk_mounted(&path, fatfs, 0);
  0005 1af01f       [2]     LEAX  31,SP
  0008 34           [2]     PSHX  
  0009 3b           [2]     PSHD  
  000a c7           [1]     CLRB  
  000b 160000       [4]     JSR   chk_mounted
  000e 1b84         [2]     LEAS  4,SP
  0010 6cf018       [3]     STD   24,SP
 3085:  	if (res == FR_OK) {
  0013 2634         [3/1]   BNE   *+54 ;abs = 0049
 3086:  		/* If free_clust is valid, return it without full cluster scan */
 3087:  		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
  0015 ee82         [3]     LDX   2,SP
  0017 ed00         [3]     LDY   0,X
  0019 ece818       [3]     LDD   24,Y
  001c 830002       [2]     SUBD  #2
  001f 3b           [2]     PSHD  
  0020 ece816       [3]     LDD   22,Y
  0023 c200         [1]     SBCB  #0
  0025 8200         [1]     SBCA  #0
  0027 1a4e         [2]     LEAX  14,Y
  0029 3b           [2]     PSHD  
  002a ec82         [3]     LDD   2,SP
  002c 34           [2]     PSHX  
  002d ee82         [3]     LDX   2,SP
  002f 6d86         [2]     STY   6,SP
  0031 31           [3]     PULY  
  0032 160000       [4]     JSR   _LCMP_P
  0035 1b84         [2]     LEAS  4,SP
  0037 2513         [3/1]   BCS   *+21 ;abs = 004c
 3088:  			*nclst = (*fatfs)->free_clust;
  0039 ee80         [3]     LDX   0,SP
  003b ec0e         [3]     LDD   14,X
  003d b746         [1]     TFR   D,Y
  003f ece010       [3]     LDD   16,X
  0042 eef01d       [3]     LDX   29,SP
  0045 6c02         [2]     STD   2,X
  0047 6d00         [2]     STY   0,X
 3089:  		} else {
  0049 060000       [3]     JMP   f_getfree:0x01cb
 3090:  			/* Get number of free clusters */
 3091:  			fat = (*fatfs)->fs_type;
  004c ee80         [3]     LDX   0,SP
  004e e600         [3]     LDAB  0,X
  0050 6bf01a       [3]     STAB  26,SP
 3092:  			n = 0;
  0053 6987         [2]     CLR   7,SP
  0055 6986         [2]     CLR   6,SP
  0057 6985         [2]     CLR   5,SP
  0059 6984         [2]     CLR   4,SP
 3093:  			if (fat == FS_FAT12) {
  005b 042164       [3]     DBNE  B,*+103 ;abs = 00c2
 3094:  				clst = 2;
  005e c602         [1]     LDAB  #2
  0060 87           [1]     CLRA  
  0061 6c8a         [2]     STD   10,SP
  0063 c7           [1]     CLRB  
  0064 6c88         [2]     STD   8,SP
 3095:  				do {
 3096:  					stat = get_fat(*fatfs, clst);
  0066 ee82         [3]     LDX   2,SP
  0068 ec00         [3]     LDD   0,X
  006a 3b           [2]     PSHD  
  006b ec8c         [3]     LDD   12,SP
  006d ee8a         [3]     LDX   10,SP
  006f 160000       [4]     JSR   get_fat
  0072 1b82         [2]     LEAS  2,SP
  0074 6cf016       [3]     STD   22,SP
  0077 6ef014       [3]     STX   20,SP
 3097:  					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  007a 04a40b       [3]     IBNE  D,*+14 ;abs = 0088
  007d 04a508       [3]     IBNE  X,*+11 ;abs = 0088
  0080 c601         [1]     LDAB  #1
  0082 87           [1]     CLRA  
  0083 6cf018       [3]     STD   24,SP
  0086 2037         [3]     BRA   *+57 ;abs = 00bf
 3098:  					if (stat == 1) { res = FR_INT_ERR; break; }
  0088 ecf016       [3]     LDD   22,SP
  008b 04240d       [3]     DBNE  D,*+16 ;abs = 009b
  008e ecf014       [3]     LDD   20,SP
  0091 2608         [3/1]   BNE   *+10 ;abs = 009b
  0093 c602         [1]     LDAB  #2
  0095 87           [1]     CLRA  
  0096 6cf018       [3]     STD   24,SP
  0099 2024         [3]     BRA   *+38 ;abs = 00bf
 3099:  					if (stat == 0) n++;
  009b ecf016       [3]     LDD   22,SP
  009e 2608         [3/1]   BNE   *+10 ;abs = 00a8
  00a0 ecf014       [3]     LDD   20,SP
  00a3 2603         [3/1]   BNE   *+5 ;abs = 00a8
  00a5 160000       [4]     JSR   f_getfree:0x01d2
 3100:  				} while (++clst < (*fatfs)->n_fatent);
  00a8 ec8a         [3]     LDD   10,SP
  00aa ee88         [3]     LDX   8,SP
  00ac 160000       [4]     JSR   _LINC
  00af 6c8a         [2]     STD   10,SP
  00b1 6e88         [2]     STX   8,SP
  00b3 ed82         [3]     LDY   2,SP
  00b5 ed40         [3]     LDY   0,Y
  00b7 19e816       [2]     LEAY  22,Y
  00ba 160000       [4]     JSR   _LCMP_P
  00bd 25a7         [3/1]   BCS   *-87 ;abs = 0066
 3101:  			} else {
  00bf 060000       [3]     JMP   f_getfree:0x01a6
 3102:  				clst = (*fatfs)->n_fatent;
  00c2 ece016       [3]     LDD   22,X
  00c5 6c88         [2]     STD   8,SP
  00c7 ece018       [3]     LDD   24,X
  00ca 6c8a         [2]     STD   10,SP
 3103:  				sect = (*fatfs)->fatbase;
  00cc ece01e       [3]     LDD   30,X
  00cf 6cf010       [3]     STD   16,SP
  00d2 ece020       [3]     LDD   32,X
  00d5 6cf012       [3]     STD   18,SP
  00d8 2004         [3]     BRA   *+6 ;abs = 00de
 3104:  				i = 0; p = 0;
 3105:  				do {
 3106:  					if (!i) {
  00da ec8e         [3]     LDD   14,SP
  00dc 2634         [3/1]   BNE   *+54 ;abs = 0112
 3107:  						res = move_window(*fatfs, sect++);
  00de ee82         [3]     LDX   2,SP
  00e0 ec00         [3]     LDD   0,X
  00e2 3b           [2]     PSHD  
  00e3 ecf014       [3]     LDD   20,SP
  00e6 eef012       [3]     LDX   18,SP
  00e9 6e82         [2]     STX   2,SP
  00eb b746         [1]     TFR   D,Y
  00ed 160000       [4]     JSR   _LINC
  00f0 6cf014       [3]     STD   20,SP
  00f3 6ef012       [3]     STX   18,SP
  00f6 b764         [1]     TFR   Y,D
  00f8 ee82         [3]     LDX   2,SP
  00fa 160000       [4]     JSR   move_window
  00fd 1b82         [2]     LEAS  2,SP
  00ff 6cf018       [3]     STD   24,SP
 3108:  						if (res != FR_OK) break;
  0102 26bb         [3/1]   BNE   *-67 ;abs = 00bf
 3109:  						p = (*fatfs)->win;
  0104 ee82         [3]     LDX   2,SP
  0106 ec00         [3]     LDD   0,X
  0108 c3002e       [2]     ADDD  #46
  010b 6c8c         [2]     STD   12,SP
 3110:  						i = SS(*fatfs);
  010d 8602         [1]     LDAA  #2
  010f c7           [1]     CLRB  
  0110 6c8e         [2]     STD   14,SP
 3111:  					}
 3112:  					if (fat == FS_FAT16) {
  0112 e6f01a       [3]     LDAB  26,SP
  0115 c102         [1]     CMPB  #2
  0117 261d         [3/1]   BNE   *+31 ;abs = 0136
 3113:  						if (LD_WORD(p) == 0) n++;
  0119 ee8c         [3]     LDX   12,SP
  011b e601         [3]     LDAB  1,X
  011d b710         [1]     TFR   B,A
  011f c7           [1]     CLRB  
  0120 046407       [3]     TBNE  D,*+10 ;abs = 012a
  0123 e600         [3]     LDAB  0,X
  0125 2603         [3/1]   BNE   *+5 ;abs = 012a
  0127 160000       [4]     JSR   f_getfree:0x01d2
 3114:  						p += 2; i -= 2;
  012a ee8c         [3]     LDX   12,SP
  012c 1a02         [2]     LEAX  2,X
  012e 6e8c         [2]     STX   12,SP
  0130 ee8e         [3]     LDX   14,SP
  0132 1a1e         [2]     LEAX  -2,X
 3115:  					} else {
  0134 2056         [3]     BRA   *+88 ;abs = 018c
 3116:  						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
  0136 ee8c         [3]     LDX   12,SP
  0138 e603         [3]     LDAB  3,X
  013a 87           [1]     CLRA  
  013b b705         [1]     SEX   A,X
  013d b781         [1]     EXG   A,B
  013f c7           [1]     CLRB  
  0140 b756         [1]     TFR   X,Y
  0142 ee8c         [3]     LDX   12,SP
  0144 3b           [2]     PSHD  
  0145 e602         [3]     LDAB  2,X
  0147 87           [1]     CLRA  
  0148 b7c6         [1]     EXG   D,Y
  014a ca00         [1]     ORAB  #0
  014c 8a00         [1]     ORAA  #0
  014e b7c6         [1]     EXG   D,Y
  0150 ea81         [3]     ORAB  1,SP
  0152 aa80         [3]     ORAA  0,SP
  0154 ee8e         [3]     LDX   14,SP
  0156 6c80         [2]     STD   0,SP
  0158 e601         [3]     LDAB  1,X
  015a b710         [1]     TFR   B,A
  015c c7           [1]     CLRB  
  015d 35           [2]     PSHY  
  015e ea81         [3]     ORAB  1,SP
  0160 aab1         [3]     ORAA  2,SP+
  0162 3b           [2]     PSHD  
  0163 e600         [3]     LDAB  0,X
  0165 87           [1]     CLRA  
  0166 ea81         [3]     ORAB  1,SP
  0168 aa80         [3]     ORAA  0,SP
  016a 6c80         [2]     STD   0,SP
  016c ec82         [3]     LDD   2,SP
  016e 840f         [1]     ANDA  #15
  0170 ce0000       [2]     LDX   #0
  0173 34           [2]     PSHX  
  0174 34           [2]     PSHX  
  0175 b745         [1]     TFR   D,X
  0177 ec84         [3]     LDD   4,SP
  0179 160000       [4]     JSR   _LCMP
  017c 1b84         [2]     LEAS  4,SP
  017e 2602         [3/1]   BNE   *+4 ;abs = 0182
  0180 0750         [4]     BSR   *+82 ;abs = 01d2
 3117:  						p += 4; i -= 4;
  0182 ee8c         [3]     LDX   12,SP
  0184 1a04         [2]     LEAX  4,X
  0186 6e8c         [2]     STX   12,SP
  0188 ee8e         [3]     LDX   14,SP
  018a 1a1c         [2]     LEAX  -4,X
  018c 6e8e         [2]     STX   14,SP
 3118:  					}
 3119:  				} while (--clst);
  018e ec8a         [3]     LDD   10,SP
  0190 ee88         [3]     LDX   8,SP
  0192 160000       [4]     JSR   _LDEC
  0195 6c8a         [2]     STD   10,SP
  0197 6e88         [2]     STX   8,SP
  0199 c7           [1]     CLRB  
  019a 87           [1]     CLRA  
  019b 3b           [2]     PSHD  
  019c 3b           [2]     PSHD  
  019d ec8e         [3]     LDD   14,SP
  019f 160000       [4]     JSR   _LCMP
  01a2 1826ff34     [4/3]   LBNE  *-200 ;abs = 00da
 3120:  			}
 3121:  			(*fatfs)->free_clust = n;
  01a6 ee82         [3]     LDX   2,SP
  01a8 ed00         [3]     LDY   0,X
  01aa ec84         [3]     LDD   4,SP
  01ac 6c4e         [2]     STD   14,Y
  01ae ec86         [3]     LDD   6,SP
  01b0 6ce810       [3]     STD   16,Y
 3122:  			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  01b3 e6f01a       [3]     LDAB  26,SP
  01b6 c103         [1]     CMPB  #3
  01b8 2606         [3/1]   BNE   *+8 ;abs = 01c0
  01ba ed00         [3]     LDY   0,X
  01bc c601         [1]     LDAB  #1
  01be 6b45         [2]     STAB  5,Y
 3123:  			*nclst = n;
  01c0 eef01d       [3]     LDX   29,SP
  01c3 ec84         [3]     LDD   4,SP
  01c5 6c00         [2]     STD   0,X
  01c7 ec86         [3]     LDD   6,SP
  01c9 6c02         [2]     STD   2,X
 3124:  		}
 3125:  	}
 3126:  	LEAVE_FF(*fatfs, res);
  01cb ecf018       [3]     LDD   24,SP
 3127:  }
  01ce 1bf01b       [2]     LEAS  27,SP
  01d1 3d           [5]     RTS   
  01d2 ec88         [3]     LDD   8,SP
  01d4 ee86         [3]     LDX   6,SP
  01d6 160000       [4]     JSR   _LINC
  01d9 6c88         [2]     STD   8,SP
  01db 6e86         [2]     STX   6,SP
  01dd 3d           [5]     RTS   
 3128:  
 3129:  
 3130:  
 3131:  
 3132:  /*-----------------------------------------------------------------------*/
 3133:  /* Truncate File                                                         */
 3134:  /*-----------------------------------------------------------------------*/
 3135:  
 3136:  FRESULT f_truncate (
 3137:  	FIL *fp		/* Pointer to the file object */
 3138:  )
 3139:  {
*** EVALUATION ***

Function: f_truncate
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 6ca8         [2]     STD   8,-SP
  0002 3b           [2]     PSHD  
 3140:  	FRESULT res;
 3141:  	DWORD ncl;
 3142:  
 3143:  
 3144:  	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  0003 b745         [1]     TFR   D,X
  0005 ed00         [3]     LDY   0,X
  0007 35           [2]     PSHY  
  0008 ec02         [3]     LDD   2,X
  000a 160000       [4]     JSR   validate
  000d 1b82         [2]     LEAS  2,SP
  000f 6c84         [2]     STD   4,SP
 3145:  	if (res == FR_OK) {
  0011 2617         [3/1]   BNE   *+25 ;abs = 002a
 3146:  		if (fp->flag & FA__ERROR) {			/* Check abort flag */
  0013 ee82         [3]     LDX   2,SP
  0015 0f048008     [4]     BRCLR 4,X,#128,*+12 ;abs = 0021
 3147:  			res = FR_INT_ERR;
  0019 c602         [1]     LDAB  #2
  001b 87           [1]     CLRA  
  001c 6c84         [2]     STD   4,SP
 3148:  		} else {
  001e 060000       [3]     JMP   f_truncate:0x00ee
 3149:  			if (!(fp->flag & FA_WRITE))		/* Check access mode */
  0021 0e040205     [4]     BRSET 4,X,#2,*+9 ;abs = 002a
 3150:  				res = FR_DENIED;
  0025 c607         [1]     LDAB  #7
  0027 87           [1]     CLRA  
  0028 6c84         [2]     STD   4,SP
 3151:  		}
 3152:  	}
 3153:  	if (res == FR_OK) {
  002a ec84         [3]     LDD   4,SP
  002c 26f0         [3/1]   BNE   *-14 ;abs = 001e
 3154:  		if (fp->fsize > fp->fptr) {
  002e ed82         [3]     LDY   2,SP
  0030 ee4a         [3]     LDX   10,Y
  0032 ec4c         [3]     LDD   12,Y
  0034 34           [2]     PSHX  
  0035 1a46         [2]     LEAX  6,Y
  0037 34           [2]     PSHX  
  0038 ee82         [3]     LDX   2,SP
  003a 31           [3]     PULY  
  003b 160000       [4]     JSR   _LCMP_P
  003e 1b82         [2]     LEAS  2,SP
  0040 232c         [3/1]   BLS   *+46 ;abs = 006e
 3155:  			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
  0042 ee82         [3]     LDX   2,SP
  0044 ec06         [3]     LDD   6,X
  0046 6c0a         [2]     STD   10,X
  0048 ec08         [3]     LDD   8,X
  004a 6c0c         [2]     STD   12,X
 3156:  			fp->flag |= FA__WRITTEN;
  004c 0c0420       [4]     BSET  4,X,#32
 3157:  			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
  004f ec08         [3]     LDD   8,X
  0051 261d         [3/1]   BNE   *+31 ;abs = 0070
  0053 ec06         [3]     LDD   6,X
  0055 2619         [3/1]   BNE   *+27 ;abs = 0070
 3158:  				res = remove_chain(fp->fs, fp->sclust);
  0057 ec00         [3]     LDD   0,X
  0059 3b           [2]     PSHD  
  005a ece010       [3]     LDD   16,X
  005d ee0e         [3]     LDX   14,X
  005f 160000       [4]     JSR   remove_chain
  0062 30           [3]     PULX  
  0063 6c84         [2]     STD   4,SP
 3159:  				fp->sclust = 0;
  0065 ee82         [3]     LDX   2,SP
  0067 c7           [1]     CLRB  
  0068 87           [1]     CLRA  
  0069 6c0e         [2]     STD   14,X
  006b 6ce010       [3]     STD   16,X
 3160:  			} else {				/* When truncate a part of the file, remove remaining clusters */
  006e 2075         [3]     BRA   *+119 ;abs = 00e5
 3161:  				ncl = get_fat(fp->fs, fp->clust);
  0070 ec00         [3]     LDD   0,X
  0072 3b           [2]     PSHD  
  0073 ece014       [3]     LDD   20,X
  0076 eee012       [3]     LDX   18,X
  0079 160000       [4]     JSR   get_fat
  007c 1b82         [2]     LEAS  2,SP
  007e 6c88         [2]     STD   8,SP
  0080 6e86         [2]     STX   6,SP
 3162:  				res = FR_OK;
  0082 6985         [2]     CLR   5,SP
  0084 6984         [2]     CLR   4,SP
 3163:  				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
  0086 04a408       [3]     IBNE  D,*+11 ;abs = 0091
  0089 04a505       [3]     IBNE  X,*+8 ;abs = 0091
  008c c601         [1]     LDAB  #1
  008e 87           [1]     CLRA  
  008f 6c84         [2]     STD   4,SP
 3164:  				if (ncl == 1) res = FR_INT_ERR;
  0091 ec88         [3]     LDD   8,SP
  0093 04240b       [3]     DBNE  D,*+14 ;abs = 00a1
  0096 ec86         [3]     LDD   6,SP
  0098 2607         [3/1]   BNE   *+9 ;abs = 00a1
  009a c602         [1]     LDAB  #2
  009c 87           [1]     CLRA  
  009d 6c84         [2]     STD   4,SP
  009f 2048         [3]     BRA   *+74 ;abs = 00e9
 3165:  				if (res == FR_OK && ncl < fp->fs->n_fatent) {
  00a1 ec84         [3]     LDD   4,SP
  00a3 2640         [3/1]   BNE   *+66 ;abs = 00e5
  00a5 ee82         [3]     LDX   2,SP
  00a7 ed00         [3]     LDY   0,X
  00a9 1ae816       [2]     LEAX  22,Y
  00ac ec88         [3]     LDD   8,SP
  00ae 34           [2]     PSHX  
  00af ee88         [3]     LDX   8,SP
  00b1 6d82         [2]     STY   2,SP
  00b3 31           [3]     PULY  
  00b4 160000       [4]     JSR   _LCMP_P
  00b7 242c         [3/1]   BCC   *+46 ;abs = 00e5
 3166:  					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
  00b9 ec80         [3]     LDD   0,SP
  00bb 3b           [2]     PSHD  
  00bc ee84         [3]     LDX   4,SP
  00be ece014       [3]     LDD   20,X
  00c1 3b           [2]     PSHD  
  00c2 ece012       [3]     LDD   18,X
  00c5 3b           [2]     PSHD  
  00c6 ccffff       [2]     LDD   #65535
  00c9 ce0fff       [2]     LDX   #4095
  00cc 160000       [4]     JSR   put_fat
  00cf 1b86         [2]     LEAS  6,SP
  00d1 6c84         [2]     STD   4,SP
 3167:  					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
  00d3 2610         [3/1]   BNE   *+18 ;abs = 00e5
  00d5 ee82         [3]     LDX   2,SP
  00d7 ec00         [3]     LDD   0,X
  00d9 3b           [2]     PSHD  
  00da ec8a         [3]     LDD   10,SP
  00dc ee88         [3]     LDX   8,SP
  00de 160000       [4]     JSR   remove_chain
  00e1 1b82         [2]     LEAS  2,SP
  00e3 6c84         [2]     STD   4,SP
 3168:  				}
 3169:  			}
 3170:  		}
 3171:  		if (res != FR_OK) fp->flag |= FA__ERROR;
  00e5 ec84         [3]     LDD   4,SP
  00e7 2705         [3/1]   BEQ   *+7 ;abs = 00ee
  00e9 ee82         [3]     LDX   2,SP
  00eb 0c0480       [4]     BSET  4,X,#128
 3172:  	}
 3173:  
 3174:  	LEAVE_FF(fp->fs, res);
  00ee ec84         [3]     LDD   4,SP
 3175:  }
  00f0 1b8a         [2]     LEAS  10,SP
  00f2 3d           [5]     RTS   
 3176:  
 3177:  
 3178:  
 3179:  
 3180:  /*-----------------------------------------------------------------------*/
 3181:  /* Delete a File or Directory                                            */
 3182:  /*-----------------------------------------------------------------------*/
 3183:  
 3184:  FRESULT f_unlink (
 3185:  	const TCHAR *path		/* Pointer to the file or directory path */
 3186:  )
 3187:  {
*** EVALUATION ***

Function: f_unlink
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1c0       [2]     LEAS  -64,SP
  0003 3b           [2]     PSHD  
 3188:  	FRESULT res;
 3189:  	DIR dj, sdj;
 3190:  	BYTE *dir;
 3191:  	DWORD dclst;
 3192:  	DEF_NAMEBUF;
 3193:  
 3194:  
 3195:  	res = chk_mounted(&path, &dj.fs, 1);
  0004 1abe         [2]     LEAX  2,SP-
  0006 34           [2]     PSHX  
  0007 1a8c         [2]     LEAX  12,SP
  0009 34           [2]     PSHX  
  000a c601         [1]     LDAB  #1
  000c 160000       [4]     JSR   chk_mounted
  000f 1b84         [2]     LEAS  4,SP
  0011 6c84         [2]     STD   4,SP
 3196:  	if (res == FR_OK) {
  0013 2612         [3/1]   BNE   *+20 ;abs = 0027
 3197:  		INIT_BUF(dj);
  0015 1af038       [2]     LEAX  56,SP
  0018 6ef01e       [3]     STX   30,SP
 3198:  		res = follow_path(&dj, path);		/* Follow the file path */
  001b 1a8a         [2]     LEAX  10,SP
  001d 34           [2]     PSHX  
  001e ec84         [3]     LDD   4,SP
  0020 160000       [4]     JSR   follow_path
  0023 1b82         [2]     LEAS  2,SP
  0025 6c84         [2]     STD   4,SP
 3199:  		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 3200:  			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 3201:  #if _FS_SHARE
 3202:  		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
 3203:  #endif
 3204:  		if (res == FR_OK) {					/* The object is accessible */
  0027 182600d5     [4/3]   LBNE  *+217 ;abs = 0100
 3205:  			dir = dj.dir;
  002b ecf01c       [3]     LDD   28,SP
  002e 6cf036       [3]     STD   54,SP
 3206:  			if (!dir) {
  0031 2604         [3/1]   BNE   *+6 ;abs = 0037
 3207:  				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
  0033 c606         [1]     LDAB  #6
 3208:  			} else {
  0035 2008         [3]     BRA   *+10 ;abs = 003f
 3209:  				if (dir[DIR_Attr] & AM_RDO)
  0037 b745         [1]     TFR   D,X
  0039 0f0b0105     [4]     BRCLR 11,X,#1,*+9 ;abs = 0042
 3210:  					res = FR_DENIED;		/* Cannot remove R/O object */
  003d c607         [1]     LDAB  #7
  003f 87           [1]     CLRA  
  0040 6c84         [2]     STD   4,SP
 3211:  			}
 3212:  			dclst = LD_CLUST(dir);
  0042 eef036       [3]     LDX   54,SP
  0045 19e014       [2]     LEAY  20,X
  0048 e641         [3]     LDAB  1,Y
  004a b710         [1]     TFR   B,A
  004c c7           [1]     CLRB  
  004d 3b           [2]     PSHD  
  004e e6e014       [3]     LDAB  20,X
  0051 87           [1]     CLRA  
  0052 ea81         [3]     ORAB  1,SP
  0054 aa80         [3]     ORAA  0,SP
  0056 eef038       [3]     LDX   56,SP
  0059 19e01a       [2]     LEAY  26,X
  005c 6c80         [2]     STD   0,SP
  005e e641         [3]     LDAB  1,Y
  0060 b710         [1]     TFR   B,A
  0062 c7           [1]     CLRB  
  0063 3b           [2]     PSHD  
  0064 e6e01a       [3]     LDAB  26,X
  0067 87           [1]     CLRA  
  0068 ea81         [3]     ORAB  1,SP
  006a aa80         [3]     ORAA  0,SP
  006c ca00         [1]     ORAB  #0
  006e 8a00         [1]     ORAA  #0
  0070 6c8c         [2]     STD   12,SP
  0072 ec82         [3]     LDD   2,SP
  0074 6c8a         [2]     STD   10,SP
 3213:  			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
  0076 ec88         [3]     LDD   8,SP
  0078 1b84         [2]     LEAS  4,SP
  007a 2654         [3/1]   BNE   *+86 ;abs = 00d0
  007c 0f0b1050     [4]     BRCLR 11,X,#16,*+84 ;abs = 00d0
 3214:  				if (dclst < 2) {
  0080 ec86         [3]     LDD   6,SP
  0082 260b         [3/1]   BNE   *+13 ;abs = 008f
  0084 ec88         [3]     LDD   8,SP
  0086 8c0002       [2]     CPD   #2
  0089 2404         [3/1]   BCC   *+6 ;abs = 008f
 3215:  					res = FR_INT_ERR;
  008b c602         [1]     LDAB  #2
 3216:  				} else {
  008d 2035         [3]     BRA   *+55 ;abs = 00c4
 3217:  					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
  008f 1af020       [2]     LEAX  32,SP
  0092 34           [2]     PSHX  
  0093 198c         [2]     LEAY  12,SP
  0095 35           [2]     PSHY  
  0096 c616         [1]     LDAB  #22
  0098 87           [1]     CLRA  
  0099 6e84         [2]     STX   4,SP
  009b 160000       [4]     JSR   mem_cpy
  009e 1b84         [2]     LEAS  4,SP
 3218:  					sdj.sclust = dclst;
  00a0 ec88         [3]     LDD   8,SP
  00a2 6cf028       [3]     STD   40,SP
  00a5 ec86         [3]     LDD   6,SP
  00a7 6cf026       [3]     STD   38,SP
 3219:  					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
  00aa ec80         [3]     LDD   0,SP
  00ac 3b           [2]     PSHD  
  00ad c602         [1]     LDAB  #2
  00af 87           [1]     CLRA  
  00b0 160000       [4]     JSR   dir_sdi
  00b3 1b82         [2]     LEAS  2,SP
  00b5 6c84         [2]     STD   4,SP
 3220:  					if (res == FR_OK) {
  00b7 2617         [3/1]   BNE   *+25 ;abs = 00d0
 3221:  						res = dir_read(&sdj);
  00b9 ec80         [3]     LDD   0,SP
  00bb 160000       [4]     JSR   dir_read
  00be 6c84         [2]     STD   4,SP
 3222:  						if (res == FR_OK			/* Not empty dir */
  00c0 2605         [3/1]   BNE   *+7 ;abs = 00c7
 3223:  #if _FS_RPATH
 3224:  						|| dclst == sdj.fs->cdir	/* Current dir */
 3225:  #endif
 3226:  						) res = FR_DENIED;
  00c2 c607         [1]     LDAB  #7
  00c4 87           [1]     CLRA  
  00c5 2037         [3]     BRA   *+57 ;abs = 00fe
 3227:  						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
  00c7 8c0004       [2]     CPD   #4
  00ca 2604         [3/1]   BNE   *+6 ;abs = 00d0
  00cc c7           [1]     CLRB  
  00cd 87           [1]     CLRA  
  00ce 6c84         [2]     STD   4,SP
 3228:  					}
 3229:  				}
 3230:  			}
 3231:  			if (res == FR_OK) {
  00d0 ec84         [3]     LDD   4,SP
  00d2 262c         [3/1]   BNE   *+46 ;abs = 0100
 3232:  				res = dir_remove(&dj);		/* Remove the directory entry */
  00d4 1a8a         [2]     LEAX  10,SP
  00d6 b754         [1]     TFR   X,D
  00d8 160000       [4]     JSR   dir_remove
  00db 6c84         [2]     STD   4,SP
 3233:  				if (res == FR_OK) {
  00dd 2621         [3/1]   BNE   *+35 ;abs = 0100
 3234:  					if (dclst)				/* Remove the cluster chain if exist */
  00df ec88         [3]     LDD   8,SP
  00e1 2604         [3/1]   BNE   *+6 ;abs = 00e7
  00e3 ec86         [3]     LDD   6,SP
  00e5 270e         [3/1]   BEQ   *+16 ;abs = 00f5
 3235:  						res = remove_chain(dj.fs, dclst);
  00e7 ec8a         [3]     LDD   10,SP
  00e9 3b           [2]     PSHD  
  00ea ec8a         [3]     LDD   10,SP
  00ec ee88         [3]     LDX   8,SP
  00ee 160000       [4]     JSR   remove_chain
  00f1 1b82         [2]     LEAS  2,SP
  00f3 6c84         [2]     STD   4,SP
 3236:  					if (res == FR_OK) res = sync(dj.fs);
  00f5 ec84         [3]     LDD   4,SP
  00f7 2607         [3/1]   BNE   *+9 ;abs = 0100
  00f9 ec8a         [3]     LDD   10,SP
  00fb 160000       [4]     JSR   sync
  00fe 6c84         [2]     STD   4,SP
 3237:  				}
 3238:  			}
 3239:  		}
 3240:  		FREE_BUF();
 3241:  	}
 3242:  	LEAVE_FF(dj.fs, res);
  0100 ec84         [3]     LDD   4,SP
 3243:  }
  0102 1bf044       [2]     LEAS  68,SP
  0105 3d           [5]     RTS   
 3244:  
 3245:  
 3246:  
 3247:  
 3248:  /*-----------------------------------------------------------------------*/
 3249:  /* Create a Directory                                                    */
 3250:  /*-----------------------------------------------------------------------*/
 3251:  
 3252:  FRESULT f_mkdir (
 3253:  	const TCHAR *path		/* Pointer to the directory path */
 3254:  )
 3255:  {
*** EVALUATION ***

Function: f_mkdir
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1b94         [2]     LEAS  -12,SP
  0002 3b           [2]     PSHD  
  0003 1bf1d5       [2]     LEAS  -43,SP
 3256:  	FRESULT res;
 3257:  	DIR dj;
 3258:  	BYTE *dir, n;
 3259:  	DWORD dsc, dcl, pcl, tim = get_fattime();
  0006 160000       [4]     JSR   get_fattime
  0009 6c8c         [2]     STD   12,SP
  000b 6e8a         [2]     STX   10,SP
 3260:  	DEF_NAMEBUF;
 3261:  
 3262:  
 3263:  	res = chk_mounted(&path, &dj.fs, 1);
  000d 1af02b       [2]     LEAX  43,SP
  0010 34           [2]     PSHX  
  0011 1af010       [2]     LEAX  16,SP
  0014 34           [2]     PSHX  
  0015 c601         [1]     LDAB  #1
  0017 160000       [4]     JSR   chk_mounted
  001a 1b84         [2]     LEAS  4,SP
  001c 6c84         [2]     STD   4,SP
 3264:  	if (res == FR_OK) {
  001e 261e         [3/1]   BNE   *+32 ;abs = 003e
 3265:  		INIT_BUF(dj);
  0020 1af02d       [2]     LEAX  45,SP
  0023 6ef022       [3]     STX   34,SP
 3266:  		res = follow_path(&dj, path);			/* Follow the file path */
  0026 1a8e         [2]     LEAX  14,SP
  0028 34           [2]     PSHX  
  0029 ecf02d       [3]     LDD   45,SP
  002c 160000       [4]     JSR   follow_path
  002f 1b82         [2]     LEAS  2,SP
  0031 6c84         [2]     STD   4,SP
 3267:  		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
  0033 2606         [3/1]   BNE   *+8 ;abs = 003b
  0035 c608         [1]     LDAB  #8
  0037 87           [1]     CLRA  
  0038 060000       [3]     JMP   f_mkdir:0x01f6
 3268:  		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
 3269:  			res = FR_INVALID_NAME;
 3270:  		if (res == FR_NO_FILE) {				/* Can create a new directory */
  003b 8c0004       [2]     CPD   #4
  003e 182601b6     [4/3]   LBNE  *+442 ;abs = 01f8
 3271:  			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
  0042 ec8e         [3]     LDD   14,SP
  0044 3b           [2]     PSHD  
  0045 c7           [1]     CLRB  
  0046 87           [1]     CLRA  
  0047 b745         [1]     TFR   D,X
  0049 160000       [4]     JSR   create_chain
  004c 1b82         [2]     LEAS  2,SP
  004e 6c82         [2]     STD   2,SP
  0050 6e80         [2]     STX   0,SP
 3272:  			res = FR_OK;
  0052 6985         [2]     CLR   5,SP
  0054 6984         [2]     CLR   4,SP
 3273:  			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
  0056 046408       [3]     TBNE  D,*+11 ;abs = 0061
  0059 046505       [3]     TBNE  X,*+8 ;abs = 0061
  005c c607         [1]     LDAB  #7
  005e 87           [1]     CLRA  
  005f 6c84         [2]     STD   4,SP
 3274:  			if (dcl == 1) res = FR_INT_ERR;
  0061 ec82         [3]     LDD   2,SP
  0063 042409       [3]     DBNE  D,*+12 ;abs = 006f
  0066 ec80         [3]     LDD   0,SP
  0068 2605         [3/1]   BNE   *+7 ;abs = 006f
  006a c602         [1]     LDAB  #2
  006c 87           [1]     CLRA  
  006d 6c84         [2]     STD   4,SP
 3275:  			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
  006f ec82         [3]     LDD   2,SP
  0071 04a40d       [3]     IBNE  D,*+16 ;abs = 0081
  0074 ec80         [3]     LDD   0,SP
  0076 04a408       [3]     IBNE  D,*+11 ;abs = 0081
  0079 c601         [1]     LDAB  #1
  007b 87           [1]     CLRA  
  007c 6c84         [2]     STD   4,SP
  007e 060000       [3]     JMP   f_mkdir:0x01aa
 3276:  			if (res == FR_OK)					/* Flush FAT */
  0081 ec84         [3]     LDD   4,SP
  0083 2605         [3/1]   BNE   *+7 ;abs = 008a
 3277:  				res = move_window(dj.fs, 0);
  0085 160000       [4]     JSR   f_mkdir:0x01fe
  0088 6c84         [2]     STD   4,SP
 3278:  			if (res == FR_OK) {					/* Initialize the new directory table */
  008a ec84         [3]     LDD   4,SP
  008c 18260109     [4/3]   LBNE  *+269 ;abs = 0199
 3279:  				dsc = clust2sect(dj.fs, dcl);
  0090 ec8e         [3]     LDD   14,SP
  0092 3b           [2]     PSHD  
  0093 ec84         [3]     LDD   4,SP
  0095 ee82         [3]     LDX   2,SP
  0097 160000       [4]     JSR   clust2sect
  009a 31           [3]     PULY  
  009b 6cf028       [3]     STD   40,SP
  009e 6ef026       [3]     STX   38,SP
 3280:  				dir = dj.fs->win;
  00a1 ec8e         [3]     LDD   14,SP
  00a3 c3002e       [2]     ADDD  #46
  00a6 6cf024       [3]     STD   36,SP
 3281:  				mem_set(dir, 0, SS(dj.fs));
  00a9 3b           [2]     PSHD  
  00aa c7           [1]     CLRB  
  00ab 87           [1]     CLRA  
  00ac 3b           [2]     PSHD  
  00ad 8602         [1]     LDAA  #2
  00af 160000       [4]     JSR   mem_set
  00b2 1b84         [2]     LEAS  4,SP
 3282:  				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
  00b4 ecf024       [3]     LDD   36,SP
  00b7 3b           [2]     PSHD  
  00b8 c620         [1]     LDAB  #32
  00ba 87           [1]     CLRA  
  00bb 3b           [2]     PSHD  
  00bc c60b         [1]     LDAB  #11
  00be 160000       [4]     JSR   mem_set
  00c1 1b84         [2]     LEAS  4,SP
 3283:  				dir[DIR_Name] = '.';
  00c3 eef024       [3]     LDX   36,SP
  00c6 cc102e       [2]     LDD   #4142
  00c9 6b00         [2]     STAB  0,X
 3284:  				dir[DIR_Attr] = AM_DIR;
  00cb 6a0b         [2]     STAA  11,X
 3285:  				ST_DWORD(dir+DIR_WrtTime, tim);
  00cd e68d         [3]     LDAB  13,SP
  00cf 6be016       [3]     STAB  22,X
  00d2 19e016       [2]     LEAY  22,X
  00d5 e68c         [3]     LDAB  12,SP
  00d7 6b41         [2]     STAB  1,Y
  00d9 e68b         [3]     LDAB  11,SP
  00db 6b42         [2]     STAB  2,Y
  00dd e68a         [3]     LDAB  10,SP
  00df 6b43         [2]     STAB  3,Y
 3286:  				ST_CLUST(dir, dcl);
  00e1 e683         [3]     LDAB  3,SP
  00e3 6be01a       [3]     STAB  26,X
  00e6 19e01a       [2]     LEAY  26,X
  00e9 e682         [3]     LDAB  2,SP
  00eb 6b41         [2]     STAB  1,Y
  00ed e681         [3]     LDAB  1,SP
  00ef 6be014       [3]     STAB  20,X
  00f2 1ae014       [2]     LEAX  20,X
  00f5 e680         [3]     LDAB  0,SP
  00f7 6b01         [2]     STAB  1,X
 3287:  				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
  00f9 ecf024       [3]     LDD   36,SP
  00fc c30020       [2]     ADDD  #32
  00ff 3b           [2]     PSHD  
  0100 ecf026       [3]     LDD   38,SP
  0103 3b           [2]     PSHD  
  0104 c620         [1]     LDAB  #32
  0106 87           [1]     CLRA  
  0107 160000       [4]     JSR   mem_cpy
  010a 1b84         [2]     LEAS  4,SP
 3288:  				dir[33] = '.'; pcl = dj.sclust;
  010c eef024       [3]     LDX   36,SP
  010f c62e         [1]     LDAB  #46
  0111 6be021       [3]     STAB  33,X
  0114 ecf016       [3]     LDD   22,SP
  0117 6c88         [2]     STD   8,SP
  0119 ecf014       [3]     LDD   20,SP
  011c 6c86         [2]     STD   6,SP
 3289:  				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  011e ee8e         [3]     LDX   14,SP
  0120 e600         [3]     LDAB  0,X
  0122 c103         [1]     CMPB  #3
  0124 2614         [3/1]   BNE   *+22 ;abs = 013a
  0126 ec88         [3]     LDD   8,SP
  0128 ace024       [3]     CPD   36,X
  012b 260d         [3/1]   BNE   *+15 ;abs = 013a
  012d ec86         [3]     LDD   6,SP
  012f ace022       [3]     CPD   34,X
  0132 2606         [3/1]   BNE   *+8 ;abs = 013a
 3290:  					pcl = 0;
  0134 c7           [1]     CLRB  
  0135 87           [1]     CLRA  
  0136 6c88         [2]     STD   8,SP
  0138 6c86         [2]     STD   6,SP
 3291:  				ST_CLUST(dir+SZ_DIR, pcl);
  013a eef024       [3]     LDX   36,SP
  013d e689         [3]     LDAB  9,SP
  013f 6be03a       [3]     STAB  58,X
  0142 19e03a       [2]     LEAY  58,X
  0145 e688         [3]     LDAB  8,SP
  0147 6b41         [2]     STAB  1,Y
  0149 e687         [3]     LDAB  7,SP
  014b 6be034       [3]     STAB  52,X
  014e 1ae034       [2]     LEAX  52,X
  0151 e686         [3]     LDAB  6,SP
  0153 6b01         [2]     STAB  1,X
 3292:  				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
  0155 ee8e         [3]     LDX   14,SP
  0157 e602         [3]     LDAB  2,X
  0159 6bf02a       [3]     STAB  42,SP
  015c 2036         [3]     BRA   *+56 ;abs = 0194
 3293:  					dj.fs->winsect = dsc++;
  015e ee8e         [3]     LDX   14,SP
  0160 ecf028       [3]     LDD   40,SP
  0163 6ce02c       [3]     STD   44,X
  0166 eef026       [3]     LDX   38,SP
  0169 ed8e         [3]     LDY   14,SP
  016b 6ee82a       [3]     STX   42,Y
  016e 160000       [4]     JSR   _LINC
  0171 6cf028       [3]     STD   40,SP
  0174 6ef026       [3]     STX   38,SP
 3294:  					dj.fs->wflag = 1;
  0177 ee8e         [3]     LDX   14,SP
  0179 c601         [1]     LDAB  #1
  017b 6b04         [2]     STAB  4,X
 3295:  					res = move_window(dj.fs, 0);
  017d 077f         [4]     BSR   *+129 ;abs = 01fe
  017f 6c84         [2]     STD   4,SP
 3296:  					if (res != FR_OK) break;
  0181 2616         [3/1]   BNE   *+24 ;abs = 0199
 3297:  					mem_set(dir, 0, SS(dj.fs));
  0183 ecf024       [3]     LDD   36,SP
  0186 3b           [2]     PSHD  
  0187 c7           [1]     CLRB  
  0188 87           [1]     CLRA  
  0189 3b           [2]     PSHD  
  018a 8602         [1]     LDAA  #2
  018c 160000       [4]     JSR   mem_set
  018f 1b84         [2]     LEAS  4,SP
  0191 63f02a       [4]     DEC   42,SP
  0194 e6f02a       [3]     LDAB  42,SP
  0197 26c5         [3/1]   BNE   *-57 ;abs = 015e
 3298:  				}
 3299:  			}
 3300:  			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
  0199 ec84         [3]     LDD   4,SP
  019b 2609         [3/1]   BNE   *+11 ;abs = 01a6
  019d 1a8e         [2]     LEAX  14,SP
  019f b754         [1]     TFR   X,D
  01a1 160000       [4]     JSR   dir_register
  01a4 6c84         [2]     STD   4,SP
 3301:  			if (res != FR_OK) {
  01a6 ec84         [3]     LDD   4,SP
  01a8 270e         [3/1]   BEQ   *+16 ;abs = 01b8
 3302:  				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
  01aa ec8e         [3]     LDD   14,SP
  01ac 3b           [2]     PSHD  
  01ad ec84         [3]     LDD   4,SP
  01af ee82         [3]     LDX   2,SP
  01b1 160000       [4]     JSR   remove_chain
  01b4 1b82         [2]     LEAS  2,SP
 3303:  			} else {
  01b6 2040         [3]     BRA   *+66 ;abs = 01f8
 3304:  				dir = dj.dir;
 3305:  				dir[DIR_Attr] = AM_DIR;				/* Attribute */
  01b8 eef020       [3]     LDX   32,SP
  01bb c610         [1]     LDAB  #16
  01bd 6b0b         [2]     STAB  11,X
 3306:  				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
  01bf a68d         [3]     LDAA  13,SP
  01c1 6ae016       [3]     STAA  22,X
  01c4 19e016       [2]     LEAY  22,X
  01c7 a68c         [3]     LDAA  12,SP
  01c9 6a41         [2]     STAA  1,Y
  01cb a68b         [3]     LDAA  11,SP
  01cd 6a42         [2]     STAA  2,Y
  01cf a68a         [3]     LDAA  10,SP
  01d1 6a43         [2]     STAA  3,Y
 3307:  				ST_CLUST(dir, dcl);					/* Table start cluster */
  01d3 a683         [3]     LDAA  3,SP
  01d5 6ae01a       [3]     STAA  26,X
  01d8 19e01a       [2]     LEAY  26,X
  01db a682         [3]     LDAA  2,SP
  01dd 6a41         [2]     STAA  1,Y
  01df a681         [3]     LDAA  1,SP
  01e1 6ae014       [3]     STAA  20,X
  01e4 1ae014       [2]     LEAX  20,X
  01e7 a680         [3]     LDAA  0,SP
  01e9 6a01         [2]     STAA  1,X
 3308:  				dj.fs->wflag = 1;
  01eb ee8e         [3]     LDX   14,SP
  01ed 8601         [1]     LDAA  #1
  01ef 6a04         [2]     STAA  4,X
 3309:  				res = sync(dj.fs);
  01f1 ec8e         [3]     LDD   14,SP
  01f3 160000       [4]     JSR   sync
  01f6 6c84         [2]     STD   4,SP
 3310:  			}
 3311:  		}
 3312:  		FREE_BUF();
 3313:  	}
 3314:  
 3315:  	LEAVE_FF(dj.fs, res);
  01f8 ec84         [3]     LDD   4,SP
 3316:  }
  01fa 1bf039       [2]     LEAS  57,SP
  01fd 3d           [5]     RTS   
  01fe ecf010       [3]     LDD   16,SP
  0201 3b           [2]     PSHD  
  0202 c7           [1]     CLRB  
  0203 87           [1]     CLRA  
  0204 b745         [1]     TFR   D,X
  0206 160000       [4]     JSR   move_window
  0209 1b82         [2]     LEAS  2,SP
  020b 3d           [5]     RTS   
 3317:  
 3318:  
 3319:  
 3320:  
 3321:  /*-----------------------------------------------------------------------*/
 3322:  /* Change Attribute                                                      */
 3323:  /*-----------------------------------------------------------------------*/
 3324:  
 3325:  FRESULT f_chmod (
 3326:  	const TCHAR *path,	/* Pointer to the file path */
 3327:  	BYTE value,			/* Attribute bits */
 3328:  	BYTE mask			/* Attribute mask to change */
 3329:  )
 3330:  {
*** EVALUATION ***

Function: f_chmod
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1da       [2]     LEAS  -38,SP
  0003 37           [2]     PSHB  
 3331:  	FRESULT res;
 3332:  	DIR dj;
 3333:  	BYTE *dir;
 3334:  	DEF_NAMEBUF;
 3335:  
 3336:  
 3337:  	res = chk_mounted(&path, &dj.fs, 1);
  0004 1af02a       [2]     LEAX  42,SP
  0007 34           [2]     PSHX  
  0008 1a87         [2]     LEAX  7,SP
  000a 34           [2]     PSHX  
  000b c601         [1]     LDAB  #1
  000d 160000       [4]     JSR   chk_mounted
  0010 1b84         [2]     LEAS  4,SP
  0012 6c81         [2]     STD   1,SP
 3338:  	if (res == FR_OK) {
  0014 2642         [3/1]   BNE   *+68 ;abs = 0058
 3339:  		INIT_BUF(dj);
  0016 1af01b       [2]     LEAX  27,SP
  0019 6ef019       [3]     STX   25,SP
 3340:  		res = follow_path(&dj, path);		/* Follow the file path */
  001c 1a85         [2]     LEAX  5,SP
  001e 34           [2]     PSHX  
  001f ecf02c       [3]     LDD   44,SP
  0022 160000       [4]     JSR   follow_path
  0025 1b82         [2]     LEAS  2,SP
  0027 6c81         [2]     STD   1,SP
 3341:  		FREE_BUF();
 3342:  		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 3343:  			res = FR_INVALID_NAME;
 3344:  		if (res == FR_OK) {
  0029 262d         [3/1]   BNE   *+47 ;abs = 0058
 3345:  			dir = dj.dir;
  002b ecf017       [3]     LDD   23,SP
  002e 6c83         [2]     STD   3,SP
 3346:  			if (!dir) {						/* Is it a root directory? */
  0030 2605         [3/1]   BNE   *+7 ;abs = 0037
 3347:  				res = FR_INVALID_NAME;
  0032 c606         [1]     LDAB  #6
  0034 87           [1]     CLRA  
 3348:  			} else {						/* File or sub directory */
  0035 201f         [3]     BRA   *+33 ;abs = 0056
 3349:  				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
  0037 0d80d8       [4]     BCLR  0,SP,#216
 3350:  				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
  003a e680         [3]     LDAB  0,SP
  003c 51           [1]     COMB  
  003d ee83         [3]     LDX   3,SP
  003f e40b         [3]     ANDB  11,X
  0041 a680         [3]     LDAA  0,SP
  0043 a4f029       [3]     ANDA  41,SP
  0046 37           [2]     PSHB  
  0047 aab0         [3]     ORAA  1,SP+
  0049 6a0b         [2]     STAA  11,X
 3351:  				dj.fs->wflag = 1;
  004b ee85         [3]     LDX   5,SP
  004d c601         [1]     LDAB  #1
  004f 6b04         [2]     STAB  4,X
 3352:  				res = sync(dj.fs);
  0051 ec85         [3]     LDD   5,SP
  0053 160000       [4]     JSR   sync
  0056 6c81         [2]     STD   1,SP
 3353:  			}
 3354:  		}
 3355:  	}
 3356:  
 3357:  	LEAVE_FF(dj.fs, res);
  0058 ec81         [3]     LDD   1,SP
 3358:  }
  005a 1bf027       [2]     LEAS  39,SP
  005d 3d           [5]     RTS   
 3359:  
 3360:  
 3361:  
 3362:  
 3363:  /*-----------------------------------------------------------------------*/
 3364:  /* Change Timestamp                                                      */
 3365:  /*-----------------------------------------------------------------------*/
 3366:  
 3367:  FRESULT f_utime (
 3368:  	const TCHAR *path,	/* Pointer to the file/directory name */
 3369:  	const FILINFO *fno	/* Pointer to the time stamp to be set */
 3370:  )
 3371:  {
*** EVALUATION ***

Function: f_utime
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1da       [2]     LEAS  -38,SP
  0003 3b           [2]     PSHD  
 3372:  	FRESULT res;
 3373:  	DIR dj;
 3374:  	BYTE *dir;
 3375:  	DEF_NAMEBUF;
 3376:  
 3377:  
 3378:  	res = chk_mounted(&path, &dj.fs, 1);
  0004 1af02a       [2]     LEAX  42,SP
  0007 34           [2]     PSHX  
  0008 1a88         [2]     LEAX  8,SP
  000a 34           [2]     PSHX  
  000b c601         [1]     LDAB  #1
  000d 160000       [4]     JSR   chk_mounted
  0010 1b84         [2]     LEAS  4,SP
  0012 6c82         [2]     STD   2,SP
 3379:  	if (res == FR_OK) {
  0014 2652         [3/1]   BNE   *+84 ;abs = 0068
 3380:  		INIT_BUF(dj);
  0016 1af01c       [2]     LEAX  28,SP
  0019 6ef01a       [3]     STX   26,SP
 3381:  		res = follow_path(&dj, path);	/* Follow the file path */
  001c 1a86         [2]     LEAX  6,SP
  001e 34           [2]     PSHX  
  001f ecf02c       [3]     LDD   44,SP
  0022 160000       [4]     JSR   follow_path
  0025 1b82         [2]     LEAS  2,SP
  0027 6c82         [2]     STD   2,SP
 3382:  		FREE_BUF();
 3383:  		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 3384:  			res = FR_INVALID_NAME;
 3385:  		if (res == FR_OK) {
  0029 263d         [3/1]   BNE   *+63 ;abs = 0068
 3386:  			dir = dj.dir;
  002b ecf018       [3]     LDD   24,SP
  002e 6c84         [2]     STD   4,SP
 3387:  			if (!dir) {					/* Root directory */
  0030 2605         [3/1]   BNE   *+7 ;abs = 0037
 3388:  				res = FR_INVALID_NAME;
  0032 c606         [1]     LDAB  #6
  0034 87           [1]     CLRA  
 3389:  			} else {					/* File or sub-directory */
  0035 202f         [3]     BRA   *+49 ;abs = 0066
 3390:  				ST_WORD(dir+DIR_WrtTime, fno->ftime);
  0037 ee80         [3]     LDX   0,SP
  0039 e607         [3]     LDAB  7,X
  003b ee84         [3]     LDX   4,SP
  003d 6be016       [3]     STAB  22,X
  0040 19e016       [2]     LEAY  22,X
  0043 ee80         [3]     LDX   0,SP
  0045 e606         [3]     LDAB  6,X
  0047 6b41         [2]     STAB  1,Y
 3391:  				ST_WORD(dir+DIR_WrtDate, fno->fdate);
  0049 ee80         [3]     LDX   0,SP
  004b e605         [3]     LDAB  5,X
  004d ee84         [3]     LDX   4,SP
  004f 6be018       [3]     STAB  24,X
  0052 1ae018       [2]     LEAX  24,X
  0055 ed80         [3]     LDY   0,SP
  0057 e644         [3]     LDAB  4,Y
  0059 6b01         [2]     STAB  1,X
 3392:  				dj.fs->wflag = 1;
  005b ee86         [3]     LDX   6,SP
  005d c601         [1]     LDAB  #1
  005f 6b04         [2]     STAB  4,X
 3393:  				res = sync(dj.fs);
  0061 ec86         [3]     LDD   6,SP
  0063 160000       [4]     JSR   sync
  0066 6c82         [2]     STD   2,SP
 3394:  			}
 3395:  		}
 3396:  	}
 3397:  
 3398:  	LEAVE_FF(dj.fs, res);
  0068 ec82         [3]     LDD   2,SP
 3399:  }
  006a 1bf028       [2]     LEAS  40,SP
  006d 3d           [5]     RTS   
 3400:  
 3401:  
 3402:  
 3403:  
 3404:  /*-----------------------------------------------------------------------*/
 3405:  /* Rename File/Directory                                                 */
 3406:  /*-----------------------------------------------------------------------*/
 3407:  
 3408:  FRESULT f_rename (
 3409:  	const TCHAR *path_old,	/* Pointer to the old name */
 3410:  	const TCHAR *path_new	/* Pointer to the new name */
 3411:  )
 3412:  {
*** EVALUATION ***

Function: f_rename
Source  : D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources\ff.c
Options : -Cc -CPUHCS12 -D_HCS12_SERIALMON -D__NO_FLOAT__ -Env"GENPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\prm;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\cmd;D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\Sources;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\lib;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\src;C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"LIBPATH=C:\Program Files\Freescale\CodeWarrior for S12(X) V5.0\lib\HC12c\include" -Env"OBJPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Env"TEXTPATH=D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\bin" -Lasm=%n.lst -Ms -ObjN="D:\My Dropbox\EE345L\9S12DP512\SDC_DP512\SDC_Data\Standard\ObjectCode\ff.c.o"

  0000 1bf1ab       [2]     LEAS  -85,SP
  0003 3b           [2]     PSHD  
  0004 1b9c         [2]     LEAS  -4,SP
 3413:  	FRESULT res;
 3414:  	DIR djo, djn;
 3415:  	BYTE buf[21], *dir;
 3416:  	DWORD dw;
 3417:  	DEF_NAMEBUF;
 3418:  
 3419:  
 3420:  	res = chk_mounted(&path_old, &djo.fs, 1);
  0006 1af05d       [2]     LEAX  93,SP
  0009 34           [2]     PSHX  
  000a 1af026       [2]     LEAX  38,SP
  000d 34           [2]     PSHX  
  000e c601         [1]     LDAB  #1
  0010 160000       [4]     JSR   chk_mounted
  0013 1b84         [2]     LEAS  4,SP
  0015 6c86         [2]     STD   6,SP
 3421:  	if (res == FR_OK) {
  0017 261b         [3/1]   BNE   *+29 ;abs = 0034
 3422:  		djn.fs = djo.fs;
  0019 ecf024       [3]     LDD   36,SP
  001c 6c8e         [2]     STD   14,SP
 3423:  		INIT_BUF(djo);
  001e 1af04f       [2]     LEAX  79,SP
  0021 6ef038       [3]     STX   56,SP
 3424:  		res = follow_path(&djo, path_old);		/* Check old object */
  0024 1af024       [2]     LEAX  36,SP
  0027 34           [2]     PSHX  
  0028 ecf05f       [3]     LDD   95,SP
  002b 6e82         [2]     STX   2,SP
  002d 160000       [4]     JSR   follow_path
  0030 1b82         [2]     LEAS  2,SP
  0032 6c86         [2]     STD   6,SP
 3425:  		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
 3426:  			res = FR_INVALID_NAME;
 3427:  #if _FS_SHARE
 3428:  		if (res == FR_OK) res = chk_lock(&djo, 2);
 3429:  #endif
 3430:  		if (res == FR_OK) {						/* Old object is found */
  0034 263c         [3/1]   BNE   *+62 ;abs = 0072
 3431:  			if (!djo.dir) {						/* Is root dir? */
  0036 eef036       [3]     LDX   54,SP
  0039 2604         [3/1]   BNE   *+6 ;abs = 003f
 3432:  				res = FR_NO_FILE;
  003b c604         [1]     LDAB  #4
 3433:  			} else {
  003d 202d         [3]     BRA   *+47 ;abs = 006c
 3434:  				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
  003f 19f03a       [2]     LEAY  58,SP
  0042 35           [2]     PSHY  
  0043 1a0b         [2]     LEAX  11,X
  0045 34           [2]     PSHX  
  0046 c615         [1]     LDAB  #21
  0048 87           [1]     CLRA  
  0049 160000       [4]     JSR   mem_cpy
  004c 1b84         [2]     LEAS  4,SP
 3435:  				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
  004e 1a8e         [2]     LEAX  14,SP
  0050 34           [2]     PSHX  
  0051 ec82         [3]     LDD   2,SP
  0053 3b           [2]     PSHD  
  0054 c616         [1]     LDAB  #22
  0056 87           [1]     CLRA  
  0057 6e84         [2]     STX   4,SP
  0059 160000       [4]     JSR   mem_cpy
 3436:  				res = follow_path(&djn, path_new);
  005c eca3         [3]     LDD   4,+SP
  005e 3b           [2]     PSHD  
  005f ec86         [3]     LDD   6,SP
  0061 160000       [4]     JSR   follow_path
  0064 1b82         [2]     LEAS  2,SP
  0066 6c86         [2]     STD   6,SP
 3437:  				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
  0068 2605         [3/1]   BNE   *+7 ;abs = 006f
  006a c608         [1]     LDAB  #8
  006c 060000       [3]     JMP   f_rename:0x0101
 3438:  				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
  006f 8c0004       [2]     CPD   #4
  0072 2609         [3/1]   BNE   *+11 ;abs = 007d
 3439:  /* Start critical section that any interruption or error can cause cross-link */
 3440:  					res = dir_register(&djn);			/* Register the new entry */
  0074 1a8e         [2]     LEAX  14,SP
  0076 b754         [1]     TFR   X,D
  0078 160000       [4]     JSR   dir_register
  007b 6c86         [2]     STD   6,SP
 3441:  					if (res == FR_OK) {
  007d 182600fd     [4/3]   LBNE  *+257 ;abs = 017e
 3442:  						dir = djn.dir;					/* Copy object information except for name */
  0081 eef020       [3]     LDX   32,SP
  0084 6e8c         [2]     STX   12,SP
 3443:  						mem_cpy(dir+13, buf+2, 19);
  0086 1a0d         [2]     LEAX  13,X
  0088 34           [2]     PSHX  
  0089 1af03e       [2]     LEAX  62,SP
  008c 34           [2]     PSHX  
  008d c613         [1]     LDAB  #19
  008f 87           [1]     CLRA  
  0090 160000       [4]     JSR   mem_cpy
  0093 1b84         [2]     LEAS  4,SP
 3444:  						dir[DIR_Attr] = buf[0] | AM_ARC;
  0095 e6f03a       [3]     LDAB  58,SP
  0098 ca20         [1]     ORAB  #32
  009a ee8c         [3]     LDX   12,SP
  009c 6b0b         [2]     STAB  11,X
 3445:  						djo.fs->wflag = 1;
  009e eef024       [3]     LDX   36,SP
  00a1 c601         [1]     LDAB  #1
  00a3 6b04         [2]     STAB  4,X
 3446:  						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
  00a5 ecf02c       [3]     LDD   44,SP
  00a8 acf016       [3]     CPD   22,SP
  00ab 260a         [3/1]   BNE   *+12 ;abs = 00b7
  00ad ecf02a       [3]     LDD   42,SP
  00b0 acf014       [3]     CPD   20,SP
  00b3 182700af     [4/3]   LBEQ  *+179 ;abs = 0166
  00b7 ee8c         [3]     LDX   12,SP
  00b9 0e0b1003     [4]     BRSET 11,X,#16,*+7 ;abs = 00c0
  00bd 060000       [3]     JMP   f_rename:0x0166
 3447:  							dw = clust2sect(djn.fs, LD_CLUST(dir));
  00c0 ec8e         [3]     LDD   14,SP
  00c2 3b           [2]     PSHD  
  00c3 19e014       [2]     LEAY  20,X
  00c6 e641         [3]     LDAB  1,Y
  00c8 b710         [1]     TFR   B,A
  00ca c7           [1]     CLRB  
  00cb 6c82         [2]     STD   2,SP
  00cd e6e014       [3]     LDAB  20,X
  00d0 87           [1]     CLRA  
  00d1 ea83         [3]     ORAB  3,SP
  00d3 aa82         [3]     ORAA  2,SP
  00d5 ee8e         [3]     LDX   14,SP
  00d7 19e01a       [2]     LEAY  26,X
  00da 6c82         [2]     STD   2,SP
  00dc e641         [3]     LDAB  1,Y
  00de b710         [1]     TFR   B,A
  00e0 c7           [1]     CLRB  
  00e1 6c84         [2]     STD   4,SP
  00e3 e6e01a       [3]     LDAB  26,X
  00e6 87           [1]     CLRA  
  00e7 ea85         [3]     ORAB  5,SP
  00e9 aa84         [3]     ORAA  4,SP
  00eb ca00         [1]     ORAB  #0
  00ed 8a00         [1]     ORAA  #0
  00ef ee82         [3]     LDX   2,SP
  00f1 160000       [4]     JSR   clust2sect
  00f4 1b82         [2]     LEAS  2,SP
  00f6 6c8a         [2]     STD   10,SP
  00f8 6e88         [2]     STX   8,SP
 3448:  							if (!dw) {
  00fa 046407       [3]     TBNE  D,*+10 ;abs = 0104
  00fd 2605         [3/1]   BNE   *+7 ;abs = 0104
 3449:  								res = FR_INT_ERR;
  00ff c602         [1]     LDAB  #2
  0101 87           [1]     CLRA  
 3450:  							} else {
  0102 2078         [3]     BRA   *+122 ;abs = 017c
 3451:  								res = move_window(djn.fs, dw);
  0104 ec8e         [3]     LDD   14,SP
  0106 3b           [2]     PSHD  
  0107 ec8c         [3]     LDD   12,SP
  0109 ee8a         [3]     LDX   10,SP
  010b 160000       [4]     JSR   move_window
  010e 30           [3]     PULX  
  010f 6c86         [2]     STD   6,SP
 3452:  								dir = djn.fs->win+SZ_DIR;	/* .. entry */
  0111 ee8e         [3]     LDX   14,SP
  0113 19e04e       [2]     LEAY  78,X
  0116 6d8c         [2]     STY   12,SP
 3453:  								if (res == FR_OK && dir[1] == '.') {
  0118 04644b       [3]     TBNE  D,*+78 ;abs = 0166
  011b e641         [3]     LDAB  1,Y
  011d c12e         [1]     CMPB  #46
  011f 2645         [3/1]   BNE   *+71 ;abs = 0166
 3454:  									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
  0121 e600         [3]     LDAB  0,X
  0123 c103         [1]     CMPB  #3
  0125 2610         [3/1]   BNE   *+18 ;abs = 0137
  0127 ecf016       [3]     LDD   22,SP
  012a ace024       [3]     CPD   36,X
  012d 2608         [3/1]   BNE   *+10 ;abs = 0137
  012f ecf014       [3]     LDD   20,SP
  0132 ace022       [3]     CPD   34,X
  0135 2708         [3/1]   BEQ   *+10 ;abs = 013f
  0137 ecf016       [3]     LDD   22,SP
  013a eef014       [3]     LDX   20,SP
  013d 2005         [3]     BRA   *+7 ;abs = 0144
  013f ce0000       [2]     LDX   #0
  0142 b754         [1]     TFR   X,D
  0144 6c8a         [2]     STD   10,SP
  0146 6e88         [2]     STX   8,SP
 3455:  									ST_CLUST(dir, dw);
  0148 e68b         [3]     LDAB  11,SP
  014a 6be81a       [3]     STAB  26,Y
  014d 1ae81a       [2]     LEAX  26,Y
  0150 e68a         [3]     LDAB  10,SP
  0152 6b01         [2]     STAB  1,X
  0154 e689         [3]     LDAB  9,SP
  0156 6be814       [3]     STAB  20,Y
  0159 19e814       [2]     LEAY  20,Y
  015c e688         [3]     LDAB  8,SP
  015e 6b41         [2]     STAB  1,Y
 3456:  									djn.fs->wflag = 1;
  0160 ee8e         [3]     LDX   14,SP
  0162 c601         [1]     LDAB  #1
  0164 6b04         [2]     STAB  4,X
 3457:  								}
 3458:  							}
 3459:  						}
 3460:  						if (res == FR_OK) {
  0166 ec86         [3]     LDD   6,SP
  0168 2614         [3/1]   BNE   *+22 ;abs = 017e
 3461:  							res = dir_remove(&djo);		/* Remove old entry */
  016a 1af024       [2]     LEAX  36,SP
  016d b754         [1]     TFR   X,D
  016f 160000       [4]     JSR   dir_remove
  0172 6c86         [2]     STD   6,SP
 3462:  							if (res == FR_OK)
  0174 2608         [3/1]   BNE   *+10 ;abs = 017e
 3463:  								res = sync(djo.fs);
  0176 ecf024       [3]     LDD   36,SP
  0179 160000       [4]     JSR   sync
  017c 6c86         [2]     STD   6,SP
 3464:  						}
 3465:  					}
 3466:  /* End critical section */
 3467:  				}
 3468:  			}
 3469:  		}
 3470:  		FREE_BUF();
 3471:  	}
 3472:  	LEAVE_FF(djo.fs, res);
  017e ec86         [3]     LDD   6,SP
 3473:  }
  0180 1bf05b       [2]     LEAS  91,SP
  0183 3d           [5]     RTS   
 3474:  
 3475:  #endif /* !_FS_READONLY */
 3476:  #endif /* _FS_MINIMIZE == 0 */
 3477:  #endif /* _FS_MINIMIZE <= 1 */
 3478:  #endif /* _FS_MINIMIZE <= 2 */
 3479:  
 3480:  
 3481:  
 3482:  /*-----------------------------------------------------------------------*/
 3483:  /* Forward data to the stream directly (available on only tiny cfg)      */
 3484:  /*-----------------------------------------------------------------------*/
 3485:  #if _USE_FORWARD && _FS_TINY
 3486:  
 3487:  FRESULT f_forward (
 3488:  	FIL *fp, 						/* Pointer to the file object */
 3489:  	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
 3490:  	UINT btr,						/* Number of bytes to forward */
 3491:  	UINT *bf						/* Pointer to number of bytes forwarded */
 3492:  )
 3493:  {
 3494:  	FRESULT res;
 3495:  	DWORD remain, clst, sect;
 3496:  	UINT rcnt;
 3497:  	BYTE csect;
 3498:  
 3499:  
 3500:  	*bf = 0;	/* Initialize byte counter */
 3501:  
 3502:  	res = validate(fp->fs, fp->id);					/* Check validity of the object */
 3503:  	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 3504:  	if (fp->flag & FA__ERROR)						/* Check error flag */
 3505:  		LEAVE_FF(fp->fs, FR_INT_ERR);
 3506:  	if (!(fp->flag & FA_READ))						/* Check access mode */
 3507:  		LEAVE_FF(fp->fs, FR_DENIED);
 3508:  
 3509:  	remain = fp->fsize - fp->fptr;
 3510:  	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
 3511:  
 3512:  	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
 3513:  		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
 3514:  		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 3515:  		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
 3516:  			if (!csect) {							/* On the cluster boundary? */
 3517:  				clst = (fp->fptr == 0) ?			/* On the top of the file? */
 3518:  					fp->sclust : get_fat(fp->fs, fp->clust);
 3519:  				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
 3520:  				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 3521:  				fp->clust = clst;					/* Update current cluster */
 3522:  			}
 3523:  		}
 3524:  		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
 3525:  		if (!sect) ABORT(fp->fs, FR_INT_ERR);
 3526:  		sect += csect;
 3527:  		if (move_window(fp->fs, sect))				/* Move sector window */
 3528:  			ABORT(fp->fs, FR_DISK_ERR);
 3529:  		fp->dsect = sect;
 3530:  		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
 3531:  		if (rcnt > btr) rcnt = btr;
 3532:  		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
 3533:  		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
 3534:  	}
 3535:  
 3536:  	LEAVE_FF(fp->fs, FR_OK);
 3537:  }
 3538:  #endif /* _USE_FORWARD */
 3539:  
 3540:  
 3541:  
 3542:  #if _USE_MKFS && !_FS_READONLY
 3543:  /*-----------------------------------------------------------------------*/
 3544:  /* Create File System on the Drive                                       */
 3545:  /*-----------------------------------------------------------------------*/
 3546:  #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
 3547:  #define N_FATS		1		/* Number of FAT copies (1 or 2) */
 3548:  
 3549:  
 3550:  FRESULT f_mkfs (
 3551:  	BYTE drv,		/* Logical drive number */
 3552:  	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
 3553:  	UINT au			/* Allocation unit size [bytes] */
 3554:  )
 3555:  {
 3556:  	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
 3557:  	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
 3558:  	BYTE fmt, md, *tbl;
 3559:  	DWORD n_clst, vs, n, wsect;
 3560:  	UINT i;
 3561:  	DWORD b_vol, b_fat, b_dir, b_data;	/* Offset (LBA) */
 3562:  	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
 3563:  	FATFS *fs;
 3564:  	DSTATUS stat;
 3565:  
 3566:  
 3567:  	/* Check mounted drive and clear work area */
 3568:  	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 3569:  	fs = FatFs[drv];
 3570:  	if (!fs) return FR_NOT_ENABLED;
 3571:  	fs->fs_type = 0;
 3572:  	drv = LD2PD(drv);
 3573:  
 3574:  	/* Get disk statics */
 3575:  	stat = disk_initialize(drv);
 3576:  	if (stat & STA_NOINIT) return FR_NOT_READY;
 3577:  	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 3578:  #if _MAX_SS != 512					/* Get disk sector size */
 3579:  	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK)
 3580:  		return FR_DISK_ERR;
 3581:  #endif
 3582:  	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
 3583:  		return FR_DISK_ERR;
 3584:  	b_vol = (sfd) ? 0 : 63;	/* Volume start sector */
 3585:  	n_vol -= b_vol;
 3586:  	if (au & (au - 1)) au = 0;	/* Check validity of the AU size */
 3587:  	if (!au) {					/* AU auto selection */
 3588:  		vs = n_vol / (2000 / (SS(fs) / 512));
 3589:  		for (i = 0; vs < vst[i]; i++) ;
 3590:  		au = cst[i];
 3591:  	}
 3592:  	au /= SS(fs);		/* Number of sectors per cluster */
 3593:  	if (au == 0) au = 1;
 3594:  	if (au > 128) au = 128;
 3595:  
 3596:  	/* Pre-compute number of clusters and FAT syb-type */
 3597:  	n_clst = n_vol / au;
 3598:  	fmt = FS_FAT12;
 3599:  	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
 3600:  	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
 3601:  
 3602:  	/* Determine offset and size of FAT structure */
 3603:  	if (fmt == FS_FAT32) {
 3604:  		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
 3605:  		n_rsv = 32;
 3606:  		n_dir = 0;
 3607:  	} else {
 3608:  		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
 3609:  		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
 3610:  		n_rsv = 1;
 3611:  		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
 3612:  	}
 3613:  	b_fat = b_vol + n_rsv;				/* FAT area start sector */
 3614:  	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
 3615:  	b_data = b_dir + n_dir;				/* Data area start sector */
 3616:  	if (n_vol < b_data + au) return FR_MKFS_ABORTED;	/* Too small volume */
 3617:  
 3618:  	/* Align data start sector to erase block boundary (for flash memory media) */
 3619:  	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
 3620:  	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
 3621:  	n = (n - b_data) / N_FATS;
 3622:  	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
 3623:  		n_rsv += n;
 3624:  		b_fat += n;
 3625:  	} else {					/* FAT12/16: Expand FAT size */
 3626:  		n_fat += n;
 3627:  	}
 3628:  
 3629:  	/* Determine number of clusters and final check of validity of the FAT sub-type */
 3630:  	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
 3631:  	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
 3632:  		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
 3633:  		return FR_MKFS_ABORTED;
 3634:  
 3635:  	/* Create partition table if required */
 3636:  	if (sfd) {	/* No patition table (SFD) */
 3637:  		md = 0xF0;
 3638:  	} else {	/* With patition table (FDISK) */
 3639:  		DWORD n_disk = b_vol + n_vol;
 3640:  
 3641:  		mem_set(fs->win, 0, SS(fs));
 3642:  		tbl = fs->win+MBR_Table;
 3643:  		ST_DWORD(tbl, 0x00010180);			/* Partition start in CHS */
 3644:  		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
 3645:  			n_disk = n_disk / 63 / 255;
 3646:  			tbl[7] = (BYTE)n_disk;
 3647:  			tbl[6] = (BYTE)((n_disk >> 2) | 63);
 3648:  		} else {
 3649:  			ST_WORD(&tbl[6], 0xFFFF);	/* CHS saturated */
 3650:  		}
 3651:  		tbl[5] = 254;
 3652:  		if (fmt != FS_FAT32)				/* System ID */
 3653:  			tbl[4] = (n_vol < 0x10000) ? 0x04 : 0x06;
 3654:  		else
 3655:  			tbl[4] = 0x0c;
 3656:  		ST_DWORD(tbl+8, 63);				/* Partition start in LBA */
 3657:  		ST_DWORD(tbl+12, n_vol);			/* Partition size in LBA */
 3658:  		ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
 3659:  		if (disk_write(drv, fs->win, 0, 1) != RES_OK)	/* Put the MBR into first physical sector */
 3660:  			return FR_DISK_ERR;
 3661:  		md = 0xF8;
 3662:  	}
 3663:  
 3664:  	/* Create volume boot record */
 3665:  	tbl = fs->win;							/* Clear sector */
 3666:  	mem_set(tbl, 0, SS(fs));
 3667:  	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
 3668:  	i = SS(fs);								/* Sector size */
 3669:  	ST_WORD(tbl+BPB_BytsPerSec, i);
 3670:  	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
 3671:  	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
 3672:  	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
 3673:  	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
 3674:  	ST_WORD(tbl+BPB_RootEntCnt, i);
 3675:  	if (n_vol < 0x10000) {					/* Number of total sectors */
 3676:  		ST_WORD(tbl+BPB_TotSec16, n_vol);
 3677:  	} else {
 3678:  		ST_DWORD(tbl+BPB_TotSec32, n_vol);
 3679:  	}
 3680:  	tbl[BPB_Media] = md;					/* Media descriptor */
 3681:  	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
 3682:  	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
 3683:  	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
 3684:  	n = get_fattime();						/* Use current time as VSN */
 3685:  	if (fmt == FS_FAT32) {
 3686:  		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
 3687:  		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
 3688:  		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
 3689:  		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
 3690:  		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
 3691:  		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
 3692:  		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
 3693:  		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
 3694:  	} else {
 3695:  		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
 3696:  		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
 3697:  		tbl[BS_DrvNum] = 0x80;				/* Drive number */
 3698:  		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
 3699:  		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 3700:  	}
 3701:  	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
 3702:  	if (disk_write(drv, tbl, b_vol, 1) != RES_OK)	/* Write VBR */
 3703:  		return FR_DISK_ERR;
 3704:  	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
 3705:  		disk_write(drv, tbl, b_vol + 6, 1);
 3706:  
 3707:  	/* Initialize FAT area */
 3708:  	wsect = b_fat;
 3709:  	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
 3710:  		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
 3711:  		n = md;								/* Media descriptor byte */
 3712:  		if (fmt != FS_FAT32) {
 3713:  			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
 3714:  			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
 3715:  		} else {
 3716:  			n |= 0xFFFFFF00;
 3717:  			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
 3718:  			ST_DWORD(tbl+4, 0xFFFFFFFF);
 3719:  			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
 3720:  		}
 3721:  		if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
 3722:  			return FR_DISK_ERR;
 3723:  		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
 3724:  		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
 3725:  			if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
 3726:  				return FR_DISK_ERR;
 3727:  		}
 3728:  	}
 3729:  
 3730:  	/* Initialize root directory */
 3731:  	i = (fmt == FS_FAT32) ? au : n_dir;
 3732:  	do {
 3733:  		if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
 3734:  			return FR_DISK_ERR;
 3735:  	} while (--i);
 3736:  
 3737:  #if _USE_ERASE	/* Erase data area if needed */
 3738:  	{
 3739:  		DWORD eb[2];
 3740:  
 3741:  		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
 3742:  		disk_ioctl(drv, CTRL_ERASE_SECTOR, eb);
 3743:  	}
 3744:  #endif
 3745:  
 3746:  	/* Create FSInfo if needed */
 3747:  	if (fmt == FS_FAT32) {
 3748:  		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 3749:  		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 3750:  		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
 3751:  		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
 3752:  		ST_WORD(tbl+BS_55AA, 0xAA55);
 3753:  		disk_write(drv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
 3754:  		disk_write(drv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
 3755:  	}
 3756:  
 3757:  	return (disk_ioctl(drv, CTRL_SYNC, (void*)0) == RES_OK) ? FR_OK : FR_DISK_ERR;
 3758:  }
 3759:  
 3760:  #endif /* _USE_MKFS && !_FS_READONLY */
 3761:  
 3762:  
 3763:  
 3764:  
 3765:  #if _USE_STRFUNC
 3766:  /*-----------------------------------------------------------------------*/
 3767:  /* Get a string from the file                                            */
 3768:  /*-----------------------------------------------------------------------*/
 3769:  TCHAR* f_gets (
 3770:  	TCHAR* buff,	/* Pointer to the string buffer to read */
 3771:  	int len,		/* Size of string buffer (characters) */
 3772:  	FIL* fil		/* Pointer to the file object */
 3773:  )
 3774:  {
 3775:  	int n = 0;
 3776:  	TCHAR c, *p = buff;
 3777:  	BYTE s[2];
 3778:  	UINT rc;
 3779:  
 3780:  
 3781:  	while (n < len - 1) {			/* Read bytes until buffer gets filled */
 3782:  		f_read(fil, s, 1, &rc);
 3783:  		if (rc != 1) break;			/* Break on EOF or error */
 3784:  		c = s[0];
 3785:  #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
 3786:  		if (c >= 0x80) {
 3787:  			if (c < 0xC0) continue;	/* Skip stray trailer */
 3788:  			if (c < 0xE0) {			/* Two-byte sequense */
 3789:  				f_read(fil, s, 1, &rc);
 3790:  				if (rc != 1) break;
 3791:  				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
 3792:  				if (c < 0x80) c = '?';
 3793:  			} else {
 3794:  				if (c < 0xF0) {		/* Three-byte sequense */
 3795:  					f_read(fil, s, 2, &rc);
 3796:  					if (rc != 2) break;
 3797:  					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
 3798:  					if (c < 0x800) c = '?';
 3799:  				} else {			/* Reject four-byte sequense */
 3800:  					c = '?';
 3801:  				}
 3802:  			}
 3803:  		}
 3804:  #endif
 3805:  #if _USE_STRFUNC >= 2
 3806:  		if (c == '\r') continue;	/* Strip '\r' */
 3807:  #endif
 3808:  		*p++ = c;
 3809:  		n++;
 3810:  		if (c == '\n') break;		/* Break on EOL */
 3811:  	}
 3812:  	*p = 0;
 3813:  	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
 3814:  }
 3815:  
 3816:  
 3817:  
 3818:  #if !_FS_READONLY
 3819:  #include <stdarg.h>
 3820:  /*-----------------------------------------------------------------------*/
 3821:  /* Put a character to the file                                           */
 3822:  /*-----------------------------------------------------------------------*/
 3823:  int f_putc (
 3824:  	TCHAR c,	/* A character to be output */
 3825:  	FIL* fil	/* Pointer to the file object */
 3826:  )
 3827:  {
 3828:  	UINT bw, btw;
 3829:  	BYTE s[3];
 3830:  
 3831:  
 3832:  #if _USE_STRFUNC >= 2
 3833:  	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
 3834:  #endif
 3835:  
 3836:  #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
 3837:  	if (c < 0x80) {			/* 7-bit */
 3838:  		s[0] = (BYTE)c;
 3839:  		btw = 1;
 3840:  	} else {
 3841:  		if (c < 0x800) {	/* 11-bit */
 3842:  			s[0] = (BYTE)(0xC0 | (c >> 6));
 3843:  			s[1] = (BYTE)(0x80 | (c & 0x3F));
 3844:  			btw = 2;
 3845:  		} else {			/* 16-bit */
 3846:  			s[0] = (BYTE)(0xE0 | (c >> 12));
 3847:  			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
 3848:  			s[2] = (BYTE)(0x80 | (c & 0x3F));
 3849:  			btw = 3;
 3850:  		}
 3851:  	}
 3852:  #else				/* Write the character without conversion */
 3853:  	s[0] = (BYTE)c;
 3854:  	btw = 1;
 3855:  #endif
 3856:  	f_write(fil, s, btw, &bw);		/* Write the char to the file */
 3857:  	return (bw == btw) ? 1 : EOF;	/* Return the result */
 3858:  }
 3859:  
 3860:  
 3861:  
 3862:  
 3863:  /*-----------------------------------------------------------------------*/
 3864:  /* Put a string to the file                                              */
 3865:  /*-----------------------------------------------------------------------*/
 3866:  int f_puts (
 3867:  	const TCHAR* str,	/* Pointer to the string to be output */
 3868:  	FIL* fil			/* Pointer to the file object */
 3869:  )
 3870:  {
 3871:  	int n;
 3872:  
 3873:  
 3874:  	for (n = 0; *str; str++, n++) {
 3875:  		if (f_putc(*str, fil) == EOF) return EOF;
 3876:  	}
 3877:  	return n;
 3878:  }
 3879:  
 3880:  
 3881:  
 3882:  
 3883:  /*-----------------------------------------------------------------------*/
 3884:  /* Put a formatted string to the file                                    */
 3885:  /*-----------------------------------------------------------------------*/
 3886:  int f_printf (
 3887:  	FIL* fil,			/* Pointer to the file object */
 3888:  	const TCHAR* str,	/* Pointer to the format string */
 3889:  	...					/* Optional arguments... */
 3890:  )
 3891:  {
 3892:  	va_list arp;
 3893:  	BYTE f, r;
 3894:  	UINT i, j, w;
 3895:  	ULONG v;
 3896:  	TCHAR c, d, s[16], *p;
 3897:  	int res, cc;
 3898:  
 3899:  
 3900:  	va_start(arp, str);
 3901:  
 3902:  	for (cc = res = 0; cc != EOF; res += cc) {
 3903:  		c = *str++;
 3904:  		if (c == 0) break;			/* End of string */
 3905:  		if (c != '%') {				/* Non escape character */
 3906:  			cc = f_putc(c, fil);
 3907:  			if (cc != EOF) cc = 1;
 3908:  			continue;
 3909:  		}
 3910:  		w = f = 0;
 3911:  		c = *str++;
 3912:  		if (c == '0') {				/* Flag: '0' padding */
 3913:  			f = 1; c = *str++;
 3914:  		} else {
 3915:  			if (c == '-') {			/* Flag: left justified */
 3916:  				f = 2; c = *str++;
 3917:  			}
 3918:  		}
 3919:  		while (IsDigit(c)) {		/* Precision */
 3920:  			w = w * 10 + c - '0';
 3921:  			c = *str++;
 3922:  		}
 3923:  		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 3924:  			f |= 4; c = *str++;
 3925:  		}
 3926:  		if (!c) break;
 3927:  		d = c;
 3928:  		if (IsLower(d)) d -= 0x20;
 3929:  		switch (d) {				/* Type is... */
 3930:  		case 'S' :					/* String */
 3931:  			p = va_arg(arp, TCHAR*);
 3932:  			for (j = 0; p[j]; j++) ;
 3933:  			res = 0;
 3934:  			while (!(f & 2) && j++ < w) res += (cc = f_putc(' ', fil));
 3935:  			res += (cc = f_puts(p, fil));
 3936:  			while (j++ < w) res += (cc = f_putc(' ', fil));
 3937:  			if (cc != EOF) cc = res;
 3938:  			continue;
 3939:  		case 'C' :					/* Character */
 3940:  			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
 3941:  		case 'B' :					/* Binary */
 3942:  			r = 2; break;
 3943:  		case 'O' :					/* Octal */
 3944:  			r = 8; break;
 3945:  		case 'D' :					/* Signed decimal */
 3946:  		case 'U' :					/* Unsigned decimal */
 3947:  			r = 10; break;
 3948:  		case 'X' :					/* Hexdecimal */
 3949:  			r = 16; break;
 3950:  		default:					/* Unknown type (passthrough) */
 3951:  			cc = f_putc(c, fil); continue;
 3952:  		}
 3953:  
 3954:  		/* Get an argument and put it in numeral */
 3955:  		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : va_arg(arp, unsigned int));
 3956:  		if (d == 'D' && (v & 0x80000000)) {
 3957:  			v = 0 - v;
 3958:  			f |= 8;
 3959:  		}
 3960:  		i = 0;
 3961:  		do {
 3962:  			d = (TCHAR)(v % r); v /= r;
 3963:  			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 3964:  			s[i++] = d + '0';
 3965:  		} while (v && i < sizeof(s) / sizeof(s[0]));
 3966:  		if (f & 8) s[i++] = '-';
 3967:  		j = i; d = (f & 1) ? '0' : ' ';
 3968:  		res = 0;
 3969:  		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
 3970:  		do res += (cc = f_putc(s[--i], fil)); while(i);
 3971:  		while (j++ < w) res += (cc = f_putc(' ', fil));
 3972:  		if (cc != EOF) cc = res;
 3973:  	}
 3974:  
 3975:  	va_end(arp);
 3976:  	return (cc == EOF) ? cc : res;
 3977:  }
 3978:  
 3979:  #endif /* !_FS_READONLY */
 3980:  #endif /* _USE_STRFUNC */
 3981:  
